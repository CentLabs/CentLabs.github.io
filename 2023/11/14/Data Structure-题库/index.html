<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CentLabs | CentLabs</title><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 绪论【计算机算法】 计算机算法是指 解决问题的步骤序列，它必须具备 可执行性、确定性、有穷性 这 3 个特性 【连续存储】 连续存储设计时，存储单元的地址 一定连续 【习题】  【解析】A  【习题】  【解析】C，有序表指出了表中数据是根据一定逻辑结构顺序排列的，是一种逻辑结构 【习题】  【解析】ABC 线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元">
<meta property="og:type" content="article">
<meta property="og:title" content="CentLabs">
<meta property="og:url" content="https://centlabs.github.io/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="1 绪论【计算机算法】 计算机算法是指 解决问题的步骤序列，它必须具备 可执行性、确定性、有穷性 这 3 个特性 【连续存储】 连续存储设计时，存储单元的地址 一定连续 【习题】  【解析】A  【习题】  【解析】C，有序表指出了表中数据是根据一定逻辑结构顺序排列的，是一种逻辑结构 【习题】  【解析】ABC 线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-11-14T13:59:04.475Z">
<meta property="article:modified_time" content="2023-11-14T13:57:54.770Z">
<meta property="article:author" content="Cappuccino">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CentLabs',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-14 21:57:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-14T13:59:04.475Z" title="Created 2023-11-14 21:59:04">2023-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-14T13:57:54.770Z" title="Updated 2023-11-14 21:57:54">2023-11-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h3><p>【计算机算法】</p>
<p>计算机算法是指 <strong>解决问题的步骤序列</strong>，它必须具备 <strong>可执行性、确定性、有穷性</strong> 这 3 个特性</p>
<p>【连续存储】</p>
<p>连续存储设计时，存储单元的地址 <strong>一定连续</strong></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200522163232335.png" alt="在这里插入图片描述"></p>
<p>【解析】A</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200522163308532.png" alt="img"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200522163525273.png" alt="在这里插入图片描述"></p>
<p>【解析】C，有序表指出了表中数据是根据一定逻辑结构顺序排列的，是一种逻辑结构</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117154902498.png" alt="在这里插入图片描述"></p>
<p>【解析】ABC</p>
<p>线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元素或节点，非线性是一个元素后面可以有多个后继或前继节点</p>
<p>顺序是指存储结构连续，例如数组是顺序的，链表不是顺序的，但它们都是线性的。当然顺序结构也可以是非线性的，例如顺序结构存储非线性结构的二叉树</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117160749543.png" alt="在这里插入图片描述"></p>
<p>【解析】A，树只是表现数据的层次关系，不是一种存储结构，通常使用链表来存储树结构</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201009140903323.png" alt="在这里插入图片描述"></p>
<p>【解析】C，其实 s u m &#x3D; 1 + 2 + 3 + ⋯ + k &#x3D; ( k + 1 ) k 2 sum&#x3D;1+2+3+\cdots+k&#x3D;\frac{(k+1)k}{2}sum&#x3D;1+2+3+⋯+k&#x3D; (k+1)k&#x2F;2</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116164258590.png" alt="在这里插入图片描述"></p>
<p>【解析】B，循环终止的条件<br>$$<br>循环终止的条件等价于 x^2 ≤ n，即 x ≤ n^{1&#x2F;2},x是线性增长的，故复杂度为 O (n^{1&#x2F;2})<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200522164118276.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201104201113273.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200529172405381.png" alt="在这里插入图片描述"></p>
<p>【解析】B</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201104202821984.png" alt="在这里插入图片描述"></p>
<h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h3><p>【线性表的定义】</p>
<p>线性表是具有 n 个相同特性 <strong>数据元素</strong> 的一个序列</p>
<p>【静态链表】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200524163705955.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200524163543807.png" alt="在这里插入图片描述"></p>
<p>【解析】C，理论如上描述</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201005150848216.png" alt="在这里插入图片描述"></p>
<p>【解析】D，理论如上描述</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200524165236343.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200524165316819.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200524171305781.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020052417133515.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200529173115564.png" alt="在这里插入图片描述"></p>
<p>【解析】D，最好、最坏情况下都是 O(m+n)&#x3D;O(max(m,n))</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201104203834165.png" alt="在这里插入图片描述"></p>
<p>【解析】A，尾部插入和删除，且随机访问</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201105203025206.png" alt="在这里插入图片描述"></p>
<p>【解析】D，尾指针方便尾插入，单循环方便头删除</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201105203237911.png" alt="在这里插入图片描述"></p>
<p>【解析】D，如下所示</p>
<p><img src="https://img-blog.csdnimg.cn/20201105204242378.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjA0MzAy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201104202518921.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p>1）采用链表。如果采用顺序表，在多个表并存的情况下，在问题求解的过程中，一旦发现某个表有存满并溢出的情况，很可能需要移动其他表以腾出位置为其扩充空间，导致不断地把大片数据移来移去，不但时间耗费很多，而且操作复杂，容易出错。如果表的总数还要变化，则会带来需要在不影响其他表工作的情况下开辟新表空间或者释放就表空间的操作上的麻烦。如果采用链表就没有这些问题，一般在内存空间足够的情况下，各个表的空间分配或释放不受其他表的影响</p>
<p>2）采用顺序表。若表的总数基本稳定，且很少进行插入或删除，则顺序表可以充分发挥其存取速度快、存储效率高的优点</p>
<h3 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h3><p>【栈的数学性质】</p>
<p>当 n个元素以某种顺序进栈，并且可以在任意时刻出栈（满足 FIFO 的前提下），所获得的元素排列的数目 N是卡特兰数，即</p>
<p>$$<br>N&#x3D;\frac{C_{2n}^n}{n+1}<br>$$</p>
<p>【双端栈】</p>
<p>若栈采用顺序存储方式存储，现两栈共享空间，两栈栈底分别在顺序空间的两端，则栈满的条件 top[1]+1&#x3D;top[2] </p>
<p>【中缀表达式转后缀表达式】</p>
<ul>
<li>当前字符为数字，保存到后缀表达式字符串中</li>
<li>当前字符为 ( ，入栈</li>
<li>当前字符 ) ，弹出栈中 ( 前的所有运算符，包括 (</li>
<li>当前字符为普通运算符，依次弹出栈中优先级大于等于当前运算符的运算符，保存到后缀表达式字符串中，将当前运算符入栈</li>
<li>例如:</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20190530133057843.png" alt="在这里插入图片描述"></p>
<p>【循环队列】</p>
<p>队空：front&#x3D;&#x3D;rear （少用一个元素空间，约定队列头指针在尾指针的下一位置为满）<br>队满：(rear+1)%maxsize&#x3D;&#x3D;front<br>入队：rear&#x3D;(rear+1)%maxsize<br>出队：front&#x3D;(front+1)%maxsize<br>求长度：(rear−front+maxsize)%maxsize</p>
<p>【抽象数据类型】</p>
<p>一个抽象数据类型（ADT），可以看作一些数据对象以及附加在这些数据对象上的操作的集合。ADT 重在对功能的描述而不关心具体实现</p>
<p>ADT 包括数据对象集、数据关系集合操作集</p>
<p>以一道题为例简单过一下 ADT 可能出考题的情况，例如. 设计一个图书馆 ADT</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201107170157428.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201126150214703.png" alt="在这里插入图片描述"></p>
<p>【解析】C，根据卡特兰数，3 个元素进栈，出栈有 5 种情况，标识符要求只能以字母或下划线开头，于是，去掉 3_t 和 3t_ 两种情况，故还剩下 3 种情况符合表示符的要求</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201001164656870.png" alt="在这里插入图片描述"></p>
<p>【解析】A，调用的顺序依次为 main()→ \rightarrow→S(1)→ \rightarrow→S(0)，即进栈的顺序</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201005151135865.png" alt="在这里插入图片描述"></p>
<p>【解析】C，4 个轨道分别如下：保证队列中后进入的元素小于先进入的元素</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>队列元素</th>
</tr>
</thead>
<tbody><tr>
<td>队列 1</td>
<td>8，4，2，1</td>
</tr>
<tr>
<td>队列 2</td>
<td>5，3</td>
</tr>
<tr>
<td>队列 3</td>
<td>直通（9，7）</td>
</tr>
<tr>
<td>队列 4</td>
<td>6</td>
</tr>
</tbody></table>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020110920012633.png" alt="在这里插入图片描述"></p>
<p>【解析】D</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020110920035857.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109200446581.png" alt="在这里插入图片描述"></p>
<p>【解析】D，理由同上题所述</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109200648538.png" alt="在这里插入图片描述"></p>
<p>【解析】D，考虑出栈，因为链栈在链表的头部进行操作，需要很方便找到链表开始结点的前驱，而只有表头指针、没有表尾指针的循环单链表找前驱的时间复杂度是O(n)</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020110920123346.png" alt="在这里插入图片描述"></p>
<p>【解析】C，p3 &#x3D; 1 且 1 是第一个出栈元素，p1，p2，p3这三个元素连续进栈，第二个出栈的是2，此时栈顶是p2，故只有 p2, …, pn 可能为2</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020110920150885.png" alt="在这里插入图片描述"></p>
<p>【解析】C，8除 3 之外，其他值是均有可能取到的</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109201744850.png" alt="在这里插入图片描述"></p>
<p>【解析】C，p1 是第一个出栈的，p1 &#x3D; 3 的话，栈里面至少还存在 2、1（2 在 1 上）这样的部分，显然第二个出栈的元素不可能是 1</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109202239655.png" alt="在这里插入图片描述"></p>
<p>【解析】BC，当队列只有一个元素时，头指针指向尾结点；当队列中元素大于一个时，头指针指向链中（链中位置是指除去头节点、尾结点的位置）</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109202444491.png" alt="在这里插入图片描述"></p>
<p>【解析】B，当带有头结点的单链表用作队列的存储结构时，链尾即队尾</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109202745459.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109202942243.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201109203018623.png" alt="在这里插入图片描述"></p>
<p>【解析】B</p>
<p>注意队列非空时 front 和 rear 分别指向队头和队尾元素，但这里并不满足我们说的 rear &#x3D;&#x3D; front 表示对空，如果一定要这样认为选择 D 的话，则在进入一个元素后 front&#x3D;n-1，rear&#x3D;0，这时队列是 n 个元素</p>
<p>为什么会产生这样的差异呢？原因是在我们熟知的循环队列中，rear 所指向的位置应该视为一个空位置（即使有元素存在），即入队元素填在此位置上，然后 rear 再向后移动一次，而本题中，rear 指向的就是队尾元素，是一个实实在在队列中的元素</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201110195135714.png" alt="在这里插入图片描述"></p>
<p>【解析】A，在栈中，栈底指针保持不变，有元素入栈，栈顶指针增加，有元素出栈，栈顶指针减少；在循环队列中，队头指针和队尾指针的动态变化决定队列的长度，故 B 错误；无论在循环链表还是线性链表中，要插入或删除元素，只需要改变相应位置的结点指针即可，头指针和尾指针无法决定链表长度，故 C、D 错误</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117163728165.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p>后缀表达式转中缀表达式的过程如下</p>
<ul>
<li>把后缀表达式逐个元素的压入到栈中，当压入的都是字符，则不采取任何操作，当压入的是运算符，则把运算符下面的两个数字弹出和运算符进行运算，然后把结果继续压入到栈中</li>
<li>对后缀表达式中的所有元素执行该操作，直到结束</li>
<li>于是，对于本题，计算过程如下</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117164542197.png" alt="在这里插入图片描述"></p>
<p>【习题】写出下列中缀表达式的后缀形式<br>                                            (!(A&amp;&amp;(!((B&lt;C)∣∣(C&gt;D)))))∣∣(C&lt;E)</p>
<p>​				注：单目运算符，! A !A!A 的后缀表达式是 A ! A!A!</p>
<p>【解析】取反运算符的优先级高于加减乘除，后缀表达式为<code>ABC&lt;CD&gt;∣∣ ! &amp;&amp; ! CE&lt;∣∣</code>，具体过程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201110201027515.png" alt="在这里插入图片描述"></p>
<p>【2019年真题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201214162919864.png" alt="在这里插入图片描述"></p>
<p>【解析】从题目的意思看来应该是指循环队列</p>
<p>（1）要求入队时允许增加队列占用空间，显然队列可以动态增长，则应该选择链式存储结构</p>
<p>（2）我们考虑用循环单链表实现该队列，且设置 f r o n t frontfront 和 r e a r rearrear 两个指针，当 f r o n t &#x3D; &#x3D; r e a r front&#x3D;&#x3D;rearfront&#x3D;&#x3D;rear 表示队空，f r o n t &#x3D; &#x3D; r e a r → n e x t front&#x3D;&#x3D;rear\rightarrow nextfront&#x3D;&#x3D;rear→next 表示队满。出队时，不释放结点，只将 f r o n t frontfront 指针后移。入队时，如果有空闲结点则利用队尾指针后的第一个空闲结点，否则则在队尾指针后插入一个结点。于是，初始状态如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201214162959254.png" alt="在这里插入图片描述"></p>
<p>（3）如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201124141812136.png" alt="在这里插入图片描述"></p>
<p>（4）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201214163031869.png" alt="在这里插入图片描述"></p>
<p>6 树<br>【一些关于树的计算公式的总结】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231113230514004.png" alt="image-20231113230514004"><br>【树的遍历】</p>
<p>&lt;前，中&gt;、&lt;后、中&gt; 的遍历序列可以唯一确定一颗二叉树，而 &lt;前，后&gt; 的遍历序列是不能唯一地确定一颗二叉树</p>
<p><strong>逆后序遍历序列只不过是先序遍历过程中对左右子树遍历顺序交换所得的结果</strong>，如考虑如下二叉树</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201114151122951.png" alt="在这里插入图片描述"></p>
<p>【线索二叉树】</p>
<p><strong>线索二叉树的高效性体现在哪里</strong>？ 答：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就转化为了近似于线性结构的遍历操作，通过线索的辅助使得寻找当前结点前驱或者后继的平均效率大大提高。至于线索二叉树是否对空间的利用率有所提高，不好回答，因为每个结点多了两个标志域ltag 和rtag，它们导致的额外空间开销是否对比非递归遍历算法中的栈空间开销少，在不同的场合下很难确定</p>
<p>线索二叉树的结点结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020111415370183.png" alt="在这里插入图片描述"></p>
<p>如果ltag&#x3D;0，则表示 lchild 为指针，指向结点的左孩子；ltag&#x3D;1，则表示 lchild 为线索，指向结点的直接前驱</p>
<p>【二叉树和森林】</p>
<h5 id="1）树转化为二叉树"><a href="#1）树转化为二叉树" class="headerlink" title="1）树转化为二叉树"></a>1）树转化为二叉树</h5><ul>
<li><p>将同一结点的各孩子用线串起来</p>
</li>
<li><p>将每个结点的分支从左往右除第一个以外，其余全部减掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201114164741219.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h5 id="2）二叉树转化为树"><a href="#2）二叉树转化为树" class="headerlink" title="2）二叉树转化为树"></a>2）二叉树转化为树</h5><ul>
<li>将一棵二叉树从左上到右下分为若干层（捋平）</li>
<li>找到每一层结点在其上的父结点</li>
<li>将每一层的结点和父结点相连，然后再删除每一层结点之间的连接</li>
<li><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201114165117551.png" alt="在这里插入图片描述"></li>
</ul>
<h5 id="3）森林转化为二叉树"><a href="#3）森林转化为二叉树" class="headerlink" title="3）森林转化为二叉树"></a>3）森林转化为二叉树</h5><ul>
<li>将每棵树转化为其各自对应的二叉树</li>
<li>将第二棵二叉树作为第一棵二叉树的右子树，依此类推，直到把所有的二叉树合并成为一棵二叉树</li>
</ul>
<p>二叉树转化为森林只需要逆向执行上述过程即可：不停地将根结点有右孩子的二叉树的右孩子链接断开，直到不存在根结点有右孩子为止；然后，将得到的多棵二叉树转化为树</p>
<h5 id="4）树和森林的遍历"><a href="#4）树和森林的遍历" class="headerlink" title="4）树和森林的遍历"></a>4）树和森林的遍历</h5><ul>
<li><p>树的先序遍历：先访问根结点，再依次访问根结点的每棵子树，访问字子树时仍然遵循先根再子树的规则</p>
</li>
<li><p>树的后序遍历：先依次访问根结点的每棵子树，再访问根结点，访问子树时仍然遵循先子树再根的规则</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115142708397.png" alt="在这里插入图片描述"></p>
<p>森林的先序遍历对应二叉树的先序遍历，森林的后序遍历对应二叉树的中序遍历（森林的中序遍历等同于后序遍历）</p>
<p>【哈夫曼树】</p>
<h5 id="1）哈夫曼树的特点"><a href="#1）哈夫曼树的特点" class="headerlink" title="1）哈夫曼树的特点"></a>1）哈夫曼树的特点</h5><ol>
<li>哈夫曼树为带权路径最小的二叉树，但不一定是完全二叉树</li>
<li>树中没有度为 1 的结点</li>
<li>权值越大的结点，距离根结点越近</li>
<li>对于同一组结点，构造出的哈夫曼树可能不唯一</li>
</ol>
<h5 id="2）哈夫曼编码"><a href="#2）哈夫曼编码" class="headerlink" title="2）哈夫曼编码"></a>2）哈夫曼编码</h5><p>任一字符的编码串都不是另一字符编码串的前缀</p>
<h5 id="3）哈夫曼-n-叉树"><a href="#3）哈夫曼-n-叉树" class="headerlink" title="3）哈夫曼 n 叉树"></a>3）哈夫曼 n 叉树</h5><p>对于结点数目大于等于 2 的待处理序列，都可以构造哈夫曼二叉树，但却不一定能构造哈夫曼 n 叉树。当发现无法构造时，需要补上权值为 0 的结点，让整个序列凑成可以构造哈夫曼 n 叉树的序列</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115144726586.png" alt="在这里插入图片描述"></p>
<p>与树、二叉树定义相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201126145734363.png" alt="在这里插入图片描述"></p>
<p>【解析】B，二叉树的度至多为 2，可以小于2，故 A、C 错误；在度为 2 的有序树中，孩子结点的左右顺序是相对于其兄弟结点而言的，如果仅有一个孩子结点，那么无所谓左右孩子，但是在二叉树中即使只有一个孩子结点，该孩子结点仍然要区分左孩子还是右孩子，故 D 错误</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115160557775.png" alt="在这里插入图片描述"></p>
<p>【解析】B，由树的度的定义可知，树中各个结点度的最大值为树的度，单个结点也算是一棵树。那么对于一个只有一个节点的二叉树，其度为 0</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117155605806.png" alt="在这里插入图片描述"></p>
<p>【解析】B，<strong>二叉树可以为空，但是树不可以空，树是图的特例，故图也不能为空</strong></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117163341335.png" alt="在这里插入图片描述"></p>
<p>【解析】除去根结点的 n−1 个结点都有一个指针指向它，故在二叉树中有 n−1 非空指针域</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201119112813578.png" alt="在这里插入图片描述"></p>
<p>【解析】二叉树不是树的特殊情况，因为具有两个结点的二叉树是区分左右子树的，具有两种形态；而树的结点位置是相对于其他节点位置而言的，具有两个结点的树不区分左右，因此其只有一种形态</p>
<p>与二叉树的遍历相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115161418337.png" alt="在这里插入图片描述"></p>
<p>【解析】B，不论是哪一种遍历方式，所得遍历序列中叶子结点的相对位置都是不变的</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201126150059423.png" alt="在这里插入图片描述"></p>
<p>【解析】D</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201119103811673.png" alt="在这里插入图片描述"></p>
<p>【解析】三种遍历方法的指针游走都是根左右，只是打印顺序不同</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020111911172739.png" alt="在这里插入图片描述"></p>
<p>【解析】画棵树出来是很容易理解的</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020071016545813.png" alt="在这里插入图片描述"></p>
<p>【解析】C</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200710162512760.png" alt="在这里插入图片描述"></p>
<p>【解析】C，要交换所有分支结点左、右子树的位置，可以递归地进行如下的操作：先递归交换左子树中的所有分支结点，再递归地交换右子树中的所有分支结点，最后对根结点交换其所有子树的位置</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115151124819.png" alt="在这里插入图片描述"></p>
<p>【解析】D，考虑如下几种情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115152521158.png" alt="在这里插入图片描述"></p>
<p>【习题】（入栈出栈和先序中序的关系）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115150047637.png" alt="在这里插入图片描述"></p>
<p>【解析】B</p>
<p><strong>根据二叉树前序遍历和中序遍历的递归算法中递归栈的工作状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序，因此前序序列和中序序列可以唯一的确定一棵二叉树</strong></p>
<p>于是，题目的意思相当于以给定序列 a b c d 为入栈序列，则出栈序列的个数为多少，对于n 个不同元素进栈，出栈序列的个数为<br>$$<br>\frac{1}{n+1}C_{2n}^n<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200713144752770.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p>二叉树的遍历都是递归的，便会用到栈</p>
<p><strong>先序遍历相当于结点在入栈时进行打印所得的结果，中序遍历相当于结点在出栈时打印所得的结果</strong></p>
<p>如此一来，这道题就清晰了，知道入栈序列和出栈序列就相当于知道了一棵二叉树的先序遍历结果和中序遍历结果，根据先序遍历和中序遍历即可以唯一地确定一棵唯一的二叉树</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200713145249470.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020111716104596.png" alt="在这里插入图片描述"></p>
<p>【解析】D</p>
<p>有两种思路：1）综合起来看是否能构成一棵二叉树；2）设abcdefg为进栈的顺序，符合出栈顺序的则可能是中序遍历的结果</p>
<p>这里我们选用第二种思路，很显然，在 e 出栈之后，栈内有两个元素a、d 且 d 在栈顶，故不可能得到 ad 的出栈序列</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115160706281.png" alt="在这里插入图片描述"></p>
<p>【解析】B</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116141248378.png" alt="在这里插入图片描述"></p>
<p>【解析】A</p>
<p>先说二叉树遍历的性质：</p>
<ol>
<li>&lt;前，中&gt; 可以唯一确定一棵二叉树</li>
<li>&lt;后，中&gt; 可以唯一确定一棵二叉树</li>
<li>&lt;前，后&gt; 是不能确定一棵二叉树</li>
<li>题中问的是根结点的孩子结点，&lt;前，后&gt; 是可以确定的，但是一般情况下不能确定整个二叉树。当前序关系为 X Y XYXY 而后序关系为 Y X YXYX 时，则 X XX 为 Y YY 的祖先</li>
</ol>
<p>于是，对此题有如下分析：</p>
<ol>
<li>前序遍历： a,e,b,d,c 后序遍历：b,c,d,e,a</li>
<li>由此可说明 a 是 e 的直接根结点</li>
<li>前序遍历： a,e,（b,d,c） 后序遍历：（b,c,d）,e,a</li>
<li>此时把 bdc 当作整体，忽略内部顺序。由此可见 e 是 bdc 整体的双亲结点，所以 e 是 a 的唯一孩子结点</li>
</ol>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117152250160.png" alt="在这里插入图片描述"></p>
<p>【解析】C</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117153416887.png" alt="在这里插入图片描述"></p>
<p>【习题】（表达式生成树）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115155328777.png" alt="在这里插入图片描述"></p>
<p>【解析】D，对应看成中序遍历结果和后续遍历结果，唯一确定一棵表达式生成树如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115155523434.png" alt="在这里插入图片描述"></p>
<p>与线索树相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115162901801.png" alt="在这里插入图片描述"></p>
<p>【解析】C，基础理论而已</p>
<p>与树的抽象计算相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117154129182.png" alt="在这里插入图片描述"></p>
<p>【解析】<br>$$<br>n_0+n_1+(n_0-1)&#x3D;2n, 2n_0+n_1-1&#x3D;2n，又n_0&#x3D;1\ or\ 0,取n_0 &#x3D; 1,可得n_0&#x3D;n<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115161122410.png" alt="在这里插入图片描述"></p>
<p>【解析】C，完全二叉树的最少情况是最后一层只有最左边有一个叶子结点。<br>$$<br>于是，上面的 k-1 层数满二叉树节点数为2^{(k-1)}-1，因此完全二叉树的节点数是 2^{(k-1)}-1+1&#x3D;2^{(k-1)}<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020111516122146.png" alt="在这里插入图片描述"></p>
<p>【解析】A，即满二叉树</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117161745517.png" alt="在这里插入图片描述"></p>
<p>【解析】根据完全二叉树的性质，第 7 层最多能容26 &#x3D; 64 个结点。而根据题意，第7层有10个叶子结点</p>
<p>① 结点最少的情况：第 7 层仅有10个结点（即全部为叶子结点），前 6 层共有 26-1 &#x3D; 63 个结点，加上第 7 层的 10 个叶子结点，就是 73 个结点，即题中描述的二叉树最少有73个结点</p>
<p>② 结点最多的情况：第 7 层有 64 个结点，其中前 54 个结点有孩子结点，剩下的 10 个结点为叶子结点，于是，前 7 层总计结点数为 27-1 &#x3D; 127个结点，第八层有 54×2&#x3D;108 个结点，两者相加为 235 个结点，即题中描述的二叉树最多有235个结点</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200712211831217.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p>（1）二叉树的第d层最多有  2^{d-1}个结点，故深度为 d 的不同的完全二叉树有 2^{d-1}棵（每多一个叶子结点即是一颗不同的完全二叉树）</p>
<p>（2）深度为d的满二叉树就只有一棵</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200710165547227.png" alt="在这里插入图片描述"></p>
<p>【解析】C，当每层只有一个结点是我们能得到最大高度，即 h&#x3D;1025；当这颗二叉树是满二叉树时高度最小，即<br>$$<br>h&#x3D;\left \lceil log_21025 \right \rceil+1&#x3D;11<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201005153459245.png" alt="在这里插入图片描述"></p>
<p>【解析】 C，考虑对一棵树而言，如果其有 n 个结点，故而有 n−1 条边。于是，设有 k 棵树，第 i 棵树有 xi个结点，于是满足以下两个关系式：<br>$$<br>\sum_{i&#x3D;1}^k x_i&#x3D;25\ \sum_{i&#x3D;1}^k(x_i-1)&#x3D;15<br>$$<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115155156704.png" alt="在这里插入图片描述"></p>
<p>【解析】C</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231113234058900.png" alt="image-20231113234058900"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2020111614091594.png" alt="在这里插入图片描述"></p>
<p>【解析】D</p>
<p>普通树转化为二叉树后，度为 1 的结点只有左孩子而无右孩子，考虑如下特殊情况，那么，也就是最后一层上面的 1895 个结点再加最后一个叶子结点没有右孩子</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116141017858.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117154712617.png" alt="在这里插入图片描述"></p>
<p>【解析】C，取 h&#x3D;1，这棵二叉树中只有一个结点</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117155332728.png" alt="在这里插入图片描述"></p>
<p>【解析】A，对完全二叉树，如果当前结点的编号哦 i ≠ 1 ，其对应的双亲编号为 ⌊i&#x2F;2⌋</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117164826843.png" alt="在这里插入图片描述"></p>
<p>【解析】D，注意要是完全二叉树 B）选项才正确</p>
<p>【习题】（十分经典的树的抽象分析，可以直接背下来）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201006160235399.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p>（1）由题意可知，对正则 k 叉树，仅有度为 k 的非叶结点和叶节点。于是，设叶结点的个数为 n0，那么</p>
<p>$$<br>总结点数&#x3D;n_0+m<br>$$<br>同时根据生成树定理，有</p>
<p>$$<br>总结点数&#x3D;mk+1<br>$$<br>故，<br>$$<br>n_0+m&#x3D;mk+1,解之得 n_0&#x3D;mk-m+1<br>$$<br>（2）含结点最多的情况：除第 h 层外，第 1 层到第 h−1 层的结点的度均为 k，而第 h 层均为叶结点，此时第 i 层有 k^{i-1} 个结点，总结点数为</p>
<p>$$<br>\sum_{i&#x3D;1}^hk^{i-1}&#x3D;1+\cdots+k^{h-1}&#x3D;\frac{k^h-1}{k-1}<br>$$<br>含结点最少的情况：第 1 层只有根结点，第 2 层到第 h−1 层仅含 1 个分支节点和 k−1 个叶结点，此时第 2 层到第 h  层中每层的结点数均为 k ，总结点数位 1+(h−1)k</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115145715102.png" alt="在这里插入图片描述"></p>
<p>【习题】（这抽象分析绝了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116152425897.png" alt="在这里插入图片描述"></p>
<p>【解析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231113234800057.png" alt="image-20231113234800057"></p>
<p>（在此题最后，要说一句很关键的话，在编程中有用到的十叉树，不是真正的一个结点带十个指针，而是如此题形式一般的通过理论分析给出结点之间编号上的关系，依次完成其他的逻辑操作）</p>
<p>与森林相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201126144744787.png" alt="在这里插入图片描述"></p>
<p>【解析】B，具体分析如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201126145552827.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200710161104534.png" alt="在这里插入图片描述"></p>
<p>【解析】A，根结点 p 属于第一棵树的结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115160130669.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201119110045104.png" alt="在这里插入图片描述"></p>
<p>【解析】C，分析如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201119111331292.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20200711211735553.png" alt="在这里插入图片描述"></p>
<p>【解析】B，分析如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116151225760.png" alt="在这里插入图片描述"></p>
<p>与哈夫曼树相关的习题<br>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117162226598.png" alt="在这里插入图片描述"></p>
<p>【解析】构造的哈夫曼树如下所示，带权路径长为 229</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201117163154997.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116155659696.png" alt="在这里插入图片描述"></p>
<p>【解析】A，哈夫曼树不一定是完全二叉树，C）选项注意题目中给定权值均不相同</p>
<p>【习题】（强调哈夫曼树左右子树可以对调）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201018155237546.png" alt="在这里插入图片描述"></p>
<p>【解析】A</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201018155956916.png" alt="在这里插入图片描述"></p>
<p>即便是题目中给出的一组权值都互不相同，且构造过程中产生的二叉树根权值也是互不相同的，照样能构造出不同的哈夫曼树和哈夫曼编码，此时只需要调换一下左右子树的位置即可，如上图所示</p>
<p>【习题】（从哈夫曼编码构造哈夫曼树）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115152800952.png" alt="在这里插入图片描述"></p>
<p>【解析】D，哈夫曼树的结点要么是叶子节点，要么是度为2的节点，不可能出现度为1的节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115154736285.png" alt="在这里插入图片描述"></p>
<p>【习题】（从路径构造哈夫曼树）</p>
<p><img src="https://img-blog.csdnimg.cn/20201116143450779.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjA0MzAy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>【解析】D，只有 D）选项能成功构造哈夫曼树，我们以 A）为反例，可以看出 24—10—7 是不存在的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116144119407.png" alt="在这里插入图片描述"></p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115153403219.png" alt="在这里插入图片描述"></p>
<p>【解析】C，哈夫曼编码为前缀码，即编码中任何一个序列都不是另一个序列的前缀</p>
<p>【习题】（哈夫曼树合并过程的计算）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201115163148766.png" alt="在这里插入图片描述"></p>
<p>【解析】C，在构造 m 哈夫曼树的过程中，从结点集中选出m个叶子结点合并为一个父结点，每次合并结点集减少m−1 个结点，从 n 个叶子结点减少到最后结点集中只剩一个根结点共需要⌈(n−1)&#x2F;(m−1)⌉，此过程中每次合并增加一个非叶子结点。</p>
<p>【习题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116155911135.png" alt="在这里插入图片描述"></p>
<p>【解析】B，对于结点数大于等于 2 的待处理序列都可以构造哈夫曼二叉树，但是不一定能构成哈夫曼 n 叉树。当发现无法构造时，需要补上权值为 0 的结点。故补上权值为 0 的结点后，本题序列构造出的哈夫曼 3 叉数为</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116160007620.png" alt="在这里插入图片描述"></p>
<p>【习题】（符号和哈夫曼树叶结点的关系）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20201116164625886.png" alt="在这里插入图片描述"></p>
<p>【解析】C，<br>$$<br>n_0+n_2 &#x3D; 115,n_0&#x3D;n_2+1 ，解之得n_0&#x3D;58,n_2&#x3D;57，故n&#x3D;58<br>$$</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/">https://centlabs.github.io/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Data Structure - 王道</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1 绪论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">2 线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">3 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.0.1.</span> <span class="toc-text">1）树转化为二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91"><span class="toc-number">3.0.2.</span> <span class="toc-text">2）二叉树转化为树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.0.3.</span> <span class="toc-text">3）森林转化为二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.0.4.</span> <span class="toc-text">4）树和森林的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.0.5.</span> <span class="toc-text">1）哈夫曼树的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">3.0.6.</span> <span class="toc-text">2）哈夫曼编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC-n-%E5%8F%89%E6%A0%91"><span class="toc-number">3.0.7.</span> <span class="toc-text">3）哈夫曼 n 叉树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="No title"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="No title">No title</a><time datetime="2023-11-14T13:59:04.475Z" title="Created 2023-11-14 21:59:04">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 王道"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道">Data Structure - 王道</a><time datetime="2023-11-12T15:05:01.134Z" title="Created 2023-11-12 23:05:01">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure Algorithm"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm">Data Structure Algorithm</a><time datetime="2023-11-12T13:02:28.408Z" title="Created 2023-11-12 21:02:28">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure/" title="Data Structure"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure/" title="Data Structure">Data Structure</a><time datetime="2023-11-12T09:47:27.180Z" title="Created 2023-11-12 17:47:27">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CTF竞赛介绍以及刷题网址"/></a><div class="content"><a class="title" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址">CTF竞赛介绍以及刷题网址</a><time datetime="2023-03-11T03:46:03.959Z" title="Created 2023-03-11 11:46:03">2023-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>