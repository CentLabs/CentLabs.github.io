<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Data Structure Algorithm | CentLabs</title><meta name="keywords" content="408"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构算法1.数组1.1.将一个数组前后翻转 12345678910111213bool Delete_Min(int A[], n, &amp;min) &amp;#123;    if (!n) return false;    &#x2F;&#x2F;数组长度为0，返回false    int temp &#x3D; INT_MAX, m;    &#x2F;&#x2F;INT_MAX为int类型的最大值    for (int i &#x3D; 0; i">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure Algorithm">
<meta property="og:url" content="https://centlabs.github.io/2023/11/12/Data%20Structure%20Algorithm/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="数据结构算法1.数组1.1.将一个数组前后翻转 12345678910111213bool Delete_Min(int A[], n, &amp;min) &amp;#123;    if (!n) return false;    &#x2F;&#x2F;数组长度为0，返回false    int temp &#x3D; INT_MAX, m;    &#x2F;&#x2F;INT_MAX为int类型的最大值    for (int i &#x3D; 0; i">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-11-12T13:02:28.408Z">
<meta property="article:modified_time" content="2023-11-12T13:04:17.781Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2023/11/12/Data%20Structure%20Algorithm/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Data Structure Algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-12 21:04:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Data Structure Algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-12T13:02:28.408Z" title="Created 2023-11-12 21:02:28">2023-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-12T13:04:17.781Z" title="Updated 2023-11-12 21:04:17">2023-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">计算机学科专业基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Data Structure Algorithm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><h4 id="1-1-将一个数组前后翻转"><a href="#1-1-将一个数组前后翻转" class="headerlink" title="1.1.将一个数组前后翻转"></a>1.1.将一个数组前后翻转</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2d672ffc94cc488eb5e08e30f3bae137.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete_Min</span><span class="params">(<span class="type">int</span> A[], n, &amp;min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//数组长度为0，返回false</span></span><br><span class="line">    <span class="type">int</span> temp = INT_MAX, m;    <span class="comment">//INT_MAX为int类型的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//遍历数组，找到数组当前的最小元素</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; temp) &#123;</span><br><span class="line">            temp = A[i];    <span class="comment">//更新数组最小值</span></span><br><span class="line">            m = i;    <span class="comment">//记录数组下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    min = temp;    <span class="comment">//min保存最小值</span></span><br><span class="line">    A[m] = A[n - <span class="number">1</span>];    <span class="comment">//m用数组中最后一个元素替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-删除数组中值为x的元素"><a href="#1-2-删除数组中值为x的元素" class="headerlink" title="1.2.删除数组中值为x的元素"></a>1.2.删除数组中值为x的元素</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/8ba31946533945ec9d1e6b217e7201b1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteX</span><span class="params">(<span class="type">int</span> A[], x, n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != x) &#123;    <span class="comment">//当前元素的值不为x</span></span><br><span class="line">            A[j] = A[i];    <span class="comment">//将其保存到数组下标为j的元素中</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = j;    </span><br><span class="line">    <span class="keyword">return</span> n;    <span class="comment">//返回删除x后的数组元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-将两个有序数组合并成一个有序数组"><a href="#1-3-将两个有序数组合并成一个有序数组" class="headerlink" title="1.3.将两个有序数组合并成一个有序数组"></a>1.3.将两个有序数组合并成一个有序数组</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/33e38c804362416196aa097e9b1ffb6c.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], B[], lenA, lenB)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *C = (<span class="type">int</span>*)<span class="built_in">malloc</span>((lenA + lenB) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>; a &lt; lenA &amp;&amp; b &lt; lenB; c++) &#123;    <span class="comment">//选择两个数组中的较小值放入数组C中</span></span><br><span class="line">        <span class="keyword">if</span> (A[a] &lt;= B[b]) C[c] = A[a++];</span><br><span class="line">        <span class="keyword">else</span> C[c] = B[b++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; lenA) C[c++] = A[a++];    <span class="comment">//将剩余数组放入C中</span></span><br><span class="line">    <span class="keyword">while</span> (b &lt; lenB) C[c++] = B[b++];</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-真题"><a href="#1-4-真题" class="headerlink" title="1.4.真题"></a>1.4.真题</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d7998333125745099e9e8105376d411a.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> A[], n, p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> B[n], i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = p; j &lt; n; i++, j++) B[i] = A[j];    <span class="comment">//数组后部分前移</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; p; i++, j++) B[i] = A[j];    <span class="comment">//数组前部分后移</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; B[i];    <span class="comment">//输出循环前移后的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/63e9f7fd08b448d08b08ae0714bc92d1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= B[j]) &#123;    <span class="comment">//当前A数组的元素小，保存A[i]</span></span><br><span class="line">            mid = A[i];</span><br><span class="line">            i++;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//当前B数组的元素小，保存B[j]</span></span><br><span class="line">            mid = B[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(<span class="type">int</span> A[], L, R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;    <span class="comment">//当前数组区间&lt;= 1，返回</span></span><br><span class="line">    随机选择数组中一个元素和A[L]交换    <span class="comment">//快速排序优化，使得基准元素的选取随机</span></span><br><span class="line">    <span class="type">int</span> key = A[L], i = L, j = R;    <span class="comment">//选择A[L]作为基准元素，i和j分别为左右指针</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt; A[j]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[i] &lt;= key) i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(A[i], A[j]);    <span class="comment">//交换A[i]和A[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[i], A[L]);</span><br><span class="line">    <span class="built_in">Qsort</span>(A, L, i - <span class="number">1</span>);    <span class="comment">//递归排序左区间</span></span><br><span class="line">    <span class="built_in">Qsort</span>(A, i + <span class="number">1</span>, R);    <span class="comment">//递归排序右区间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> C[<span class="number">2</span>n], i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) C[i] = A[i];    <span class="comment">//复制数组A和数组B的元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; i++, j++) C[i] = B[j];</span><br><span class="line">    <span class="built_in">Qsort</span>(C, <span class="number">0</span>, <span class="number">2</span>n - <span class="number">1</span>);    <span class="comment">//对数组C进行快速排序</span></span><br><span class="line">    <span class="keyword">return</span> C[n - <span class="number">1</span>];    <span class="comment">//返回中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e24f9027d944449f9f267da69c9a9428.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e68b14727533463bb184108542e51197.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> A[], n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) count[i] = <span class="number">0</span>;    <span class="comment">//初始化count数组</span></span><br><span class="line">    <span class="comment">//遍历A数组，其元素的值作为count数组下标的元素+1，表示该元素在A数组中出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) count[A[i]]++;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//当前元素出现次数符合主元素定义</span></span><br><span class="line">        <span class="keyword">if</span> (count[i] &gt; n / <span class="number">2</span>) <span class="keyword">return</span> i;    <span class="comment">//返回i，即该元素的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//没有元素符合主元素定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/9fd06f5530b2430da410e14815da0fdd.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> A[], n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> B[n + <span class="number">2</span>];    <span class="comment">//B用来标记数组中出现的正整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) B[i] = <span class="literal">false</span>;    <span class="comment">//初始化B数组</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; <span class="number">0</span> &amp;&amp; A[i] &lt;= n)&#123;    <span class="comment">//当前数组元素为正，并且在数组B的下标范围内</span></span><br><span class="line">            count = A[i];</span><br><span class="line">            B[count] = <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] == <span class="literal">false</span>) <span class="keyword">return</span> i;    <span class="comment">//返回数组B中第一个false的元素下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(<span class="type">int</span> A[], L, R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;	<span class="comment">//数组区间&lt;= 1，返回</span></span><br><span class="line">	随机选择数组中一元素和A[L]交换;<span class="comment">//快排优化，使得基准元素的选取随机</span></span><br><span class="line">	<span class="type">int</span> key = A[L], i = L, j = R;	<span class="comment">//A[L]为基准元素，ij为左右指针</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt; A[j]) j--;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; A[i] &lt;= key) i++;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">Swap</span>(A[i], A[j]);	<span class="comment">//交换A[i]和A[j]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Swap</span>(A[L], A[i]);</span><br><span class="line">	<span class="built_in">Qsort</span>(A, L, i - <span class="number">1</span>);	<span class="comment">//递归排序左区间</span></span><br><span class="line">	<span class="built_in">Qsort</span>(A, i + <span class="number">1</span>, R);	<span class="comment">//递归排序右区间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> A[], n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Qsort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);	<span class="comment">//快速排序</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (A[i] &lt;= <span class="number">0</span>) i++;	<span class="comment">//找到数组中第一个大于0的元素</span></span><br><span class="line">	<span class="keyword">if</span> (n == i) <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//数组中没有元素大于0，返回1</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//第一个整数不是1，则返回1</span></span><br><span class="line">		<span class="keyword">else</span> &#123;    <span class="comment">//第一个整数为1，找到数组中正整数第一个间断点</span></span><br><span class="line">			<span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] == a[j - <span class="number">1</span>]) j++;    <span class="comment">//相邻元素相等</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a[j] == a[j - <span class="number">1</span>] + <span class="number">1</span>) j++;    <span class="comment">//相邻元素是连续数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> A[j - <span class="number">1</span>] + <span class="number">1</span>;    <span class="comment">//相邻元素是间断点</span></span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">		&#125;<span class="comment">//else</span></span><br><span class="line">	&#125;<span class="comment">//else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/6ebfa00824c04488a0e1538e123a20f8.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dis</span><span class="params">(<span class="type">int</span> a, b, c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">abs</span>(a - b) + <span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(b - c);    <span class="comment">//计算绝对值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> C[], <span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">int</span> n3)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min = INT_MAX, i, j, k, temp;    <span class="comment">//min取整型的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;    <span class="comment">//循环遍历数组A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;    <span class="comment">//循环遍历数组B</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n3; k++) &#123;    <span class="comment">//循环遍历数组C</span></span><br><span class="line">                temp = <span class="built_in">Dis</span>(A[i], B[j], C[k]);</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; min) min = temp;    <span class="comment">//当前元素之间的距离更小，更新最小距离</span></span><br><span class="line">            &#125;<span class="comment">//for</span></span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> min;    <span class="comment">//返回最小距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><h4 id="2-1-链表的数据结构定义"><a href="#2-1-链表的数据结构定义" class="headerlink" title="2.1.链表的数据结构定义"></a>2.1.链表的数据结构定义</h4><h5 id="2-1-1-单链表"><a href="#2-1-1-单链表" class="headerlink" title="2.1.1.单链表"></a>2.1.1.单链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-双链表"><a href="#2-1-2-双链表" class="headerlink" title="2.1.2.双链表"></a>2.1.2.双链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *prior, *next;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-链表的操作"><a href="#2-2-链表的操作" class="headerlink" title="2.2.链表的操作"></a>2.2.链表的操作</h4><h5 id="2-2-1-头插法（插入到链表头）"><a href="#2-2-1-头插法（插入到链表头）" class="headerlink" title="2.2.1.头插法（插入到链表头）"></a>2.2.1.头插法（插入到链表头）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;data = key;</span><br><span class="line">    p-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-尾插法（插入到链表尾）"><a href="#2-2-2-尾插法（插入到链表尾）" class="headerlink" title="2.2.2.尾插法（插入到链表尾）"></a>2.2.2.尾插法（插入到链表尾）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TailInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    LNode *q = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode);</span><br><span class="line">    q-&gt;data = key;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L-&gt;next, *pre = L;</span><br><span class="line">    <span class="keyword">while</span> (!p) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-链表逆置（头插法实现）"><a href="#2-2-3-链表逆置（头插法实现）" class="headerlink" title="2.2.3.链表逆置（头插法实现）"></a>2.2.3.链表逆置（头插法实现）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//将L表断开</span></span><br><span class="line">    <span class="keyword">while</span> (!p) &#123;</span><br><span class="line">        q = p-&gt;next;    <span class="comment">//q指向p的下一个结点</span></span><br><span class="line">        p-&gt;next = L-&gt;next;    <span class="comment">//头插法</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-链表的遍历"><a href="#2-2-4-链表的遍历" class="headerlink" title="2.2.4.链表的遍历"></a>2.2.4.链表的遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (!p) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(p);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-5-链表的删除"><a href="#2-2-5-链表的删除" class="headerlink" title="2.2.5.链表的删除"></a>2.2.5.链表的删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> &amp;key)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *pre = L;</span><br><span class="line">    移动p和pre到指定结点    <span class="comment">//pre指向p的前驱结点</span></span><br><span class="line">    key = p-&gt;data;    <span class="comment">//key保存p的data领</span></span><br><span class="line">    pre-&gt;next = p-&gt;next;    <span class="comment">//pre的next指针指向p的后继节点</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-链表算法题"><a href="#2-3-链表算法题" class="headerlink" title="2.3.链表算法题"></a>2.3.链表算法题</h4><h5 id="2-3-1-删除值为x的结点"><a href="#2-3-1-删除值为x的结点" class="headerlink" title="2.3.1.删除值为x的结点"></a>2.3.1.删除值为x的结点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteX</span><span class="params">(LinkList &amp;L, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *pre = L;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) &#123;    <span class="comment">//当前元素值为x</span></span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//当前元素值非x，p和pre向后移动</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-单链表就地逆置"><a href="#2-3-2-单链表就地逆置" class="headerlink" title="2.3.2.单链表就地逆置"></a>2.3.2.单链表就地逆置</h5><p><img src="https://img-blog.csdnimg.cn/99e7afe97aa04a699c22f929a0b6f198.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//断链</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;    <span class="comment">//q指向p的下一个结点</span></span><br><span class="line">        p-&gt;next = L-&gt;next;    <span class="comment">//头插法</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-将链表排序"><a href="#2-3-3-将链表排序" class="headerlink" title="2.3.3.将链表排序"></a>2.3.3.将链表排序</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/83649d0dd1504382b5f534f74b959ff0.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">Sort</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">	LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Lnode));</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	LNode* t = L-&gt;next, * tpre = L, *min, *minpre, *r = p;</span><br><span class="line">	<span class="type">int</span> m = INT_MAX;</span><br><span class="line">	<span class="keyword">while</span> (t) &#123;</span><br><span class="line">		<span class="keyword">while</span> (t) &#123;    <span class="comment">//遍历链表</span></span><br><span class="line">			<span class="keyword">if</span> (t-&gt;data &lt; m) &#123;	<span class="comment">//更新最小值结点</span></span><br><span class="line">				min = t;</span><br><span class="line">				minpre = tpre;</span><br><span class="line">				m = t-&gt;data;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">            tpre = t;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">		&#125;<span class="comment">//while</span></span><br><span class="line">		minpre-&gt;next = min-&gt;next;	<span class="comment">//将min从L中删除</span></span><br><span class="line">		r-&gt;next = min;	<span class="comment">//将min插入p</span></span><br><span class="line">		r = min;	<span class="comment">//r后移</span></span><br><span class="line">		m = INT_MAX;	<span class="comment">//重新初始化</span></span><br><span class="line">		t = L-&gt;next;</span><br><span class="line">		tpre = L;</span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-拆分链表"><a href="#2-3-4-拆分链表" class="headerlink" title="2.3.4.拆分链表"></a>2.3.4.拆分链表</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/87bccb5146f44a919002d0af76a41f96.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LNode* (LinkList &amp;L) &#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode);</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//p为新链的头结点</span></span><br><span class="line">    LNode *q = L-&gt;next, *t = <span class="literal">NULL</span>, *r = L;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//r结点始终指向L的最后一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        t = q-&gt;next;</span><br><span class="line">        r-&gt;next = q;    <span class="comment">//奇数结点尾插法</span></span><br><span class="line">        r = q;</span><br><span class="line">        q = t;</span><br><span class="line">        t = q-&gt;next;</span><br><span class="line">        q-&gt;next = p-&gt;next;    <span class="comment">//偶数节点头插法</span></span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//将r的next指针置空</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-删除链表中的重复元素"><a href="#2-3-5-删除链表中的重复元素" class="headerlink" title="2.3.5.删除链表中的重复元素"></a>2.3.5.删除链表中的重复元素</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/897f91ea488e437280ebd1fddfc4c064.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        LNode *post = p-&gt;next;    <span class="comment">//post指向p的下一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (post &amp;&amp; post-&gt;data == p-&gt;data) &#123;    <span class="comment">//post存在并且值和p相等时</span></span><br><span class="line">            LNode *temp = post;    <span class="comment">//temp指向post</span></span><br><span class="line">            post = post-&gt;next;    <span class="comment">//post向后移动</span></span><br><span class="line">            p-&gt;next = post;    <span class="comment">//将p的下一个结点修改为post</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-6-将两个递增链表合并成一个递减链表"><a href="#2-3-6-将两个递增链表合并成一个递减链表" class="headerlink" title="2.3.6.将两个递增链表合并成一个递减链表"></a>2.3.6.将两个递增链表合并成一个递减链表</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/31bcee4271af4b03b808c33a52267356.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(LinkList &amp;L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LNode *p = L1-&gt;next, *q = L2-&gt;next, *temp;</span><br><span class="line">    L1-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//L1断链</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;    <span class="comment">//当前p指向的元素更小</span></span><br><span class="line">            temp = p-&gt;next;    <span class="comment">//temp指向p的下一个结点</span></span><br><span class="line">            p-&gt;next = L1-&gt;next;    <span class="comment">//将p用头插法插入L1</span></span><br><span class="line">            L1-&gt;next = p;</span><br><span class="line">            p = temp;    <span class="comment">//p指向temp</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//当前q指向的元素更小</span></span><br><span class="line">            temp = q-&gt;next;</span><br><span class="line">            q-&gt;next = L1-&gt;next;</span><br><span class="line">            L1-&gt;next = q;</span><br><span class="line">            q = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;    <span class="comment">//将剩余节点插入L1</span></span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = L1-&gt;next;</span><br><span class="line">        L1-&gt;next = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        temp = q-&gt;next;</span><br><span class="line">        q-&gt;next = L1-&gt;next;</span><br><span class="line">        L1-&gt;next = q;</span><br><span class="line">        q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-7-将两个递增链表合并为一个递增链表"><a href="#2-3-7-将两个递增链表合并为一个递增链表" class="headerlink" title="2.3.7.将两个递增链表合并为一个递增链表"></a>2.3.7.将两个递增链表合并为一个递增链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">Merge</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LNode *p = L1-&gt;next, *q = L2-&gt;next, *r, *temp;</span><br><span class="line">    LNode *L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;    <span class="comment">//当前p指向的结点小于等于q</span></span><br><span class="line">            temp = p-&gt;next;</span><br><span class="line">            r-&gt;next = p;    <span class="comment">//p尾插法插入L中</span></span><br><span class="line">            r = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = q-&gt;next;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            r = q;</span><br><span class="line">            q = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;    <span class="comment">//插入剩余结点</span></span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        temp = q-&gt;next;</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">        r = q;</span><br><span class="line">        q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//将r的next指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-8-判断链表是否对称"><a href="#2-3-8-判断链表是否对称" class="headerlink" title="2.3.8.判断链表是否对称"></a>2.3.8.判断链表是否对称</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/68d0f4f27e6d4417a2c3776c06645b4f.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ans</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">	LNode* post = L-&gt;prior, * pre = L-&gt;next;    <span class="comment">//前后指针</span></span><br><span class="line">    <span class="comment">//表中元素为奇数时，终止条件为两者移动到同一结点</span></span><br><span class="line">    <span class="comment">//表中元素为偶数时，终止条件为两者后指针的next指向前指针</span></span><br><span class="line">	<span class="keyword">while</span> (post != pre &amp;&amp; post-&gt;next != pre) &#123;    </span><br><span class="line">		<span class="keyword">if</span> (post-&gt;data != pre-&gt;data) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//前后指针的指针域不相等</span></span><br><span class="line">		pre = pre-&gt;next;    <span class="comment">//前指针前移</span></span><br><span class="line">		post = post-&gt;prior;    <span class="comment">//后指针后移</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//表对称</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ans</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">	LNode* p = L-&gt;next;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;    <span class="comment">//记录表中的元素个数</span></span><br><span class="line">	<span class="keyword">while</span> (p != L) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(len * <span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">//定义跟链表结点个数相等的长度的数组</span></span><br><span class="line">	len = <span class="number">0</span>;</span><br><span class="line">	p = L-&gt;next</span><br><span class="line">	<span class="keyword">while</span> (p != L) &#123;    <span class="comment">//遍历链表，用数组保存链表中每个结点的值</span></span><br><span class="line">		a[len] = p-&gt;next;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//遍历数组，前后指针指向元素的值不相等，返回false</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-9-依次输出链表中结点值最小的元素"><a href="#2-3-9-依次输出链表中结点值最小的元素" class="headerlink" title="2.3.9.依次输出链表中结点值最小的元素"></a>2.3.9.依次输出链表中结点值最小的元素</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/da5a120bd343499eb0f1dd383d35b0a1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMin</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *ppre = L-&gt;next, *min, *minpre;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != L) &#123;</span><br><span class="line">        p = L-&gt;next;</span><br><span class="line">        ppre = L;</span><br><span class="line">        <span class="type">int</span> tempMin = INT_MAX;    <span class="comment">//当前最小值</span></span><br><span class="line">        <span class="keyword">while</span> (p != L) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &lt; tempMin) &#123;    <span class="comment">//当前结点值更小，更新最小结点</span></span><br><span class="line">                min = p;</span><br><span class="line">                minpre = ppre;</span><br><span class="line">            &#125;    <span class="comment">//p向后移动</span></span><br><span class="line">            ppre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; min-&gt;data;    <span class="comment">//输出最小结点的值</span></span><br><span class="line">        minpre-&gt;next = min-&gt;next;    <span class="comment">//删除min结点</span></span><br><span class="line">        <span class="built_in">free</span>(min);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="built_in">free</span>(L);    <span class="comment">//删除头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-10-真题"><a href="#2-3-10-真题" class="headerlink" title="2.3.10.真题"></a>2.3.10.真题</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/a822bd0933d74051bf109284bedcdd31.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(LinkList L, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;link, *q = L-&gt;link;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) p = p-&gt;link;    <span class="comment">//p指针向后移动k个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">        q = q-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; q-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/0d293bb78b334ecf8ee9dfdc7392f538.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(LinkList str1, LinkList str2)</span> </span>&#123;</span><br><span class="line">	LNode *p = str1-&gt;next, *q = str2-&gt;next;</span><br><span class="line">	<span class="type">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;    <span class="comment">//遍历str1，得到str1的长度</span></span><br><span class="line">		len1++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;    <span class="comment">//遍历str2，得到str2的长度</span></span><br><span class="line">		len2++;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">abs</span>(len1 - len2);    <span class="comment">//得到两表长度之差</span></span><br><span class="line">	p = str1-&gt;next;    <span class="comment">//重置pq指向第一个结点</span></span><br><span class="line">	q = str2-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (len1 &gt;= len2) &#123;    <span class="comment">//长表向前移动，使得两表剩余元素相等</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;    <span class="comment">//遍历剩余结点，找到两者指向的第一个共同结点</span></span><br><span class="line">		<span class="keyword">if</span> (p == q) <span class="keyword">return</span> p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//两者没有共同后缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/c0f0efeb281542c5863afd80a37ddea1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> A[n + <span class="number">1</span>];    <span class="comment">//长度为n + 1的数组，用来标记该数是否出现过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) A[i] = <span class="literal">false</span>;    <span class="comment">//初始化A数组</span></span><br><span class="line">    LNode *p = head-&gt;next, *pre = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">abs</span>(p-&gt;data);    <span class="comment">//取当前结点值的绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (A[t]) &#123;    <span class="comment">//该值出现过，删除该结点</span></span><br><span class="line">            LNode *r = p-&gt;next;</span><br><span class="line">            pre-&gt;next = r;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//该值没有出现过，在数组A中标记该值，p和pre向后移动</span></span><br><span class="line">            A[t] = <span class="literal">true</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/6e9952902c0a498ab760546c23af4047.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(NODE *L)</span> </span>&#123;</span><br><span class="line">	NODE* p = L-&gt;next, *f = L-&gt;next, *s = L-&gt;next, *q, *t;</span><br><span class="line">	<span class="keyword">while</span> (f-&gt;next-&gt;next &amp;&amp; f-&gt;next) &#123;	<span class="comment">//找到前半链的最后一个结点</span></span><br><span class="line">		f = f-&gt;next-&gt;next;    <span class="comment">//快指针移动两个结点</span></span><br><span class="line">		s = s-&gt;next;    <span class="comment">//慢指针移动一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	q = s-&gt;next;	<span class="comment">//q指向后半链的第一个结点</span></span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//前半链后半链断开</span></span><br><span class="line">	LNode* post = (NODE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(NODE));</span><br><span class="line">	post-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;	<span class="comment">//后半链逆置</span></span><br><span class="line">		t = q-&gt;next;</span><br><span class="line">		q-&gt;next = post-&gt;next;</span><br><span class="line">		post-&gt;next = q;</span><br><span class="line">		q = t;</span><br><span class="line">	&#125;</span><br><span class="line">	q = post-&gt;next;	<span class="comment">//q指向逆置后的后半链的第一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		r = q-&gt;next;	<span class="comment">//r指向后半链的下一个结点</span></span><br><span class="line">		t = p-&gt;next;	<span class="comment">//t指向前半链下一个插入位置</span></span><br><span class="line">		q-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = q;</span><br><span class="line">		q = r;	<span class="comment">//重置pq</span></span><br><span class="line">		p = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><h4 id="3-1-栈的数据结构定义"><a href="#3-1-栈的数据结构定义" class="headerlink" title="3.1.栈的数据结构定义"></a>3.1.栈的数据结构定义</h4><h5 id="3-1-1-顺序栈"><a href="#3-1-1-顺序栈" class="headerlink" title="3.1.1.顺序栈"></a>3.1.1.顺序栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-链栈"><a href="#3-1-2-链栈" class="headerlink" title="3.1.2.链栈"></a>3.1.2.链栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LStack</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LStack</span> *next;</span><br><span class="line">&#125;SNode, *LStack;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-顺序栈的操作"><a href="#3-2-顺序栈的操作" class="headerlink" title="3.2.顺序栈的操作"></a>3.2.顺序栈的操作</h4><h5 id="3-2-1-栈的初始化"><a href="#3-2-1-栈的初始化" class="headerlink" title="3.2.1.栈的初始化"></a>3.2.1.栈的初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span> <span class="params">(Stack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-入栈"><a href="#3-2-2-入栈" class="headerlink" title="3.2.2.入栈"></a>3.2.2.入栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(Stack &amp;S, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MAXSIZE - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈满</span></span><br><span class="line">    S.data[++top] = key;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-出栈"><a href="#3-2-3-出栈" class="headerlink" title="3.2.3.出栈"></a>3.2.3.出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span> <span class="params">(Stack &amp;S, <span class="type">int</span> &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈空</span></span><br><span class="line">    key = S.data[top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-判断栈空"><a href="#3-2-4-判断栈空" class="headerlink" title="3.2.4.判断栈空"></a>3.2.4.判断栈空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span> <span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-链栈的基本操作"><a href="#3-3-链栈的基本操作" class="headerlink" title="3.3.链栈的基本操作"></a>3.3.链栈的基本操作</h4><h5 id="3-3-1-初始化"><a href="#3-3-1-初始化" class="headerlink" title="3.3.1.初始化"></a>3.3.1.初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span> <span class="params">(LStack &amp;S)</span> </span>&#123;</span><br><span class="line">    SNode *s = (SNode*)<span class="built_in">malloc</span>(<span class="built_in">Sizeof</span>(SNode));</span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-入栈"><a href="#3-3-2-入栈" class="headerlink" title="3.3.2.入栈"></a>3.3.2.入栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span> <span class="params">(LStack &amp;S, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    SNode *p = (SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    p-&gt;data = key;</span><br><span class="line">    p-&gt;next = S-&gt;next;    <span class="comment">//头插法</span></span><br><span class="line">    S-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-出栈"><a href="#3-3-3-出栈" class="headerlink" title="3.3.3.出栈"></a>3.3.3.出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span> <span class="params">(LStack &amp;S, <span class="type">int</span> &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈空</span></span><br><span class="line">    SNode *p = S-&gt;next;</span><br><span class="line">    key = p-&gt;data;    <span class="comment">//key保存栈顶元素的值</span></span><br><span class="line">    S-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-判断栈空"><a href="#3-3-4-判断栈空" class="headerlink" title="3.3.4.判断栈空"></a>3.3.4.判断栈空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><h4 id="4-1-队列的数据结构定义"><a href="#4-1-队列的数据结构定义" class="headerlink" title="4.1.队列的数据结构定义"></a>4.1.队列的数据结构定义</h4><h5 id="4-1-1-顺序队列"><a href="#4-1-1-顺序队列" class="headerlink" title="4.1.1.顺序队列"></a>4.1.1.顺序队列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-链式队列"><a href="#4-1-2-链式队列" class="headerlink" title="4.1.2.链式队列"></a>4.1.2.链式队列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;LNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    LNode *front, *rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-顺序队列的基本操作"><a href="#4-2-顺序队列的基本操作" class="headerlink" title="4.2.顺序队列的基本操作"></a>4.2.顺序队列的基本操作</h4><h5 id="4-2-1-初始化"><a href="#4-2-1-初始化" class="headerlink" title="4.2.1.初始化"></a>4.2.1.初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(Queue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-入队"><a href="#4-2-2-入队" class="headerlink" title="4.2.2.入队"></a>4.2.2.入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(Queue &amp;Q, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == (Q.rear + <span class="number">1</span>) % MAXSIZE) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队满</span></span><br><span class="line">    Q.data[rear] = key;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-出队"><a href="#4-2-3-出队" class="headerlink" title="4.2.3.出队"></a>4.2.3.出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(Queue &amp;Q, <span class="type">int</span> &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队空</span></span><br><span class="line">    key = Q.front;</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-判断队空"><a href="#4-2-4-判断队空" class="headerlink" title="4.2.4.判断队空"></a>4.2.4.判断队空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-链式队列的基本操作"><a href="#4-3-链式队列的基本操作" class="headerlink" title="4.3.链式队列的基本操作"></a>4.3.链式队列的基本操作</h4><h5 id="4-3-1-初始化"><a href="#4-3-1-初始化" class="headerlink" title="4.3.1.初始化"></a>4.3.1.初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(Queue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LNode*)<span class="built_in">maloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-入队"><a href="#4-3-2-入队" class="headerlink" title="4.3.2.入队"></a>4.3.2.入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue</span><span class="params">(Queue &amp;Q, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));    <span class="comment">//申明一个新结点</span></span><br><span class="line">    p-&gt;data = key;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;    <span class="comment">//尾插法插入到rear后</span></span><br><span class="line">    Q.rear = p;    <span class="comment">//更新rear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-3-出队"><a href="#4-3-3-出队" class="headerlink" title="4.3.3.出队"></a>4.3.3.出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(Queue &amp;Q, <span class="type">int</span> &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队空</span></span><br><span class="line">    LNode *p = Q.front-&gt;next;</span><br><span class="line">    key = p-&gt;data;    <span class="comment">//保存队首元素的数据</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) Q.rear = Q.front;    <span class="comment">//队列中只有一个元素</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-4-判断队空"><a href="#4-3-4-判断队空" class="headerlink" title="4.3.4.判断队空"></a>4.3.4.判断队空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-树"><a href="#5-树" class="headerlink" title="5.树"></a>5.树</h3><h4 id="5-1-树的数据结构定义"><a href="#5-1-树的数据结构定义" class="headerlink" title="5.1.树的数据结构定义"></a>5.1.树的数据结构定义</h4><h5 id="5-1-1-二叉树的链式存储"><a href="#5-1-1-二叉树的链式存储" class="headerlink" title="5.1.1.二叉树的链式存储"></a>5.1.1.二叉树的链式存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTree</span>&#123;</span><br><span class="line">    sturct BiTree *lchild, *rchild;    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> value;    <span class="comment">//结点数据</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-2-二叉树的顺序存储"><a href="#5-1-2-二叉树的顺序存储" class="headerlink" title="5.1.2.二叉树的顺序存储"></a>5.1.2.二叉树的顺序存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;    <span class="comment">//结点数据</span></span><br><span class="line">    <span class="type">bool</span> IsEmpty;    <span class="comment">//该结点是否存在</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTree</span><span class="params">(TreeNode T[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) T[i].IsEmpty = <span class="literal">true</span>;    <span class="comment">//将该结点初始化为空结点</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode T[MAXSIZE];    <span class="comment">//申明一个长度为MAXSIZE的TreeNode数组</span></span><br><span class="line">    <span class="built_in">InitTree</span>(T);    <span class="comment">//初始化树</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-双亲表示法"><a href="#5-1-3-双亲表示法" class="headerlink" title="5.1.3.双亲表示法"></a>5.1.3.双亲表示法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100    <span class="comment">//树中最多结点数</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//结点数据</span></span><br><span class="line">    <span class="type">int</span> parent;    <span class="comment">//该结点的双亲结点在数组的下标</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    TreeNode T[MAXSIZE];    <span class="comment">//长度为MAXSIZE的TreeNode类型的数组</span></span><br><span class="line">    <span class="type">int</span> treeNum;    <span class="comment">//结点数</span></span><br><span class="line">&#125;Tree;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/9344d2449429412183b84614f3955c09.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/a75355abee7945b8aacbb30fad270bc4.png" alt="img"></p>
<h5 id="5-1-4-孩子表示法"><a href="#5-1-4-孩子表示法" class="headerlink" title="5.1.4.孩子表示法"></a>5.1.4.孩子表示法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Child</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;    <span class="comment">//该结点的编号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Child</span> *next;    <span class="comment">//指向该结点的下一个孩子结点的指针</span></span><br><span class="line">&#125;Child;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结点信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    Child *firstTNode;    <span class="comment">//指向该结点的第一个孩子结点的指针</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//该结点数据</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"> </span><br><span class="line">TreeNode T[MAXSIZE];    <span class="comment">//定义一个长度为MAXSIZE的树</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/db9ca806369046e0889425d88ff49236.png" alt="img"></p>
<h5 id="5-1-5-孩子兄弟表示法"><a href="#5-1-5-孩子兄弟表示法" class="headerlink" title="5.1.5.孩子兄弟表示法"></a>5.1.5.孩子兄弟表示法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstChild, *nextSibling;    <span class="comment">//指向第一个孩子和右兄弟节点</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//该结点数据</span></span><br><span class="line">&#125;CSNode;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d74cc9d397b6442485c8887d78ff1a25.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/dbddf95d63ed459b9d45925ac1b8e123.png" alt="img"></p>
<h5 id="5-1-6-线索二叉树"><a href="#5-1-6-线索二叉树" class="headerlink" title="5.1.6.线索二叉树"></a>5.1.6.线索二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;    <span class="comment">//左右线索标志</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//结点数据    </span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-二叉树的基本操作"><a href="#5-2-二叉树的基本操作" class="headerlink" title="5.2.二叉树的基本操作"></a>5.2.二叉树的基本操作</h4><h5 id="5-2-1-先序遍历"><a href="#5-2-1-先序遍历" class="headerlink" title="5.2.1.先序遍历"></a>5.2.1.先序遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-中序遍历"><a href="#5-2-2-中序遍历" class="headerlink" title="5.2.2.中序遍历"></a>5.2.2.中序遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-后序遍历"><a href="#5-2-3-后序遍历" class="headerlink" title="5.2.3.后序遍历"></a>5.2.3.后序遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    BiTNode *Node[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    BiTNode *p, *pre;</span><br><span class="line">    <span class="keyword">while</span> (p || !<span class="built_in">IsEmpty</span>(S)）&#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;    <span class="comment">//往左下走到尽头</span></span><br><span class="line">            <span class="built_in">Push</span>(p);    <span class="comment">//p入栈</span></span><br><span class="line">            p = p-&gt;lchild;    <span class="comment">//进入其左子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">GetTop</span>(S, p);    <span class="comment">//查看栈顶元素</span></span><br><span class="line">            <span class="comment">//栈顶元素的右孩子存在，并且不是上一个访问的结点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != pre) &#123;</span><br><span class="line">                p = p-&gt;rchild;    <span class="comment">//进入栈顶元素的右子树</span></span><br><span class="line">                <span class="built_in">Push</span>(p);    <span class="comment">//该结点入栈</span></span><br><span class="line">                p = p-&gt;lchild;    <span class="comment">//进入该结点左子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//栈顶元素的右孩子被访问过</span></span><br><span class="line">                <span class="built_in">Pop</span>(S, p);    <span class="comment">//弹出栈顶元素</span></span><br><span class="line">                <span class="built_in">visit</span>(p);    <span class="comment">//访问该结点</span></span><br><span class="line">                pre = p;    <span class="comment">//用pre标记该结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;    <span class="comment">//将p置空</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">                </span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//whil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-层次遍历"><a href="#5-2-4-层次遍历" class="headerlink" title="5.2.4.层次遍历"></a>5.2.4.层次遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-并查集"><a href="#5-3-并查集" class="headerlink" title="5.3.并查集"></a>5.3.并查集</h4><h5 id="5-3-1-并查集的定义和初始化"><a href="#5-3-1-并查集的定义和初始化" class="headerlink" title="5.3.1.并查集的定义和初始化"></a>5.3.1.并查集的定义和初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSet[MAXSIZE];    <span class="comment">//并查集通过数组表示</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSet</span><span class="params">(<span class="type">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++) S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-FIND操作"><a href="#5-3-2-FIND操作" class="headerlink" title="5.3.2.FIND操作"></a>5.3.2.FIND操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FIND操作用于查找该结点的所属集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>) x = S[x];    <span class="comment">//递归寻找直到该结点的值为负数（该树的根节点）</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-UNION操作"><a href="#5-3-3-UNION操作" class="headerlink" title="5.3.3.UNION操作"></a>5.3.3.UNION操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], root1, root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要求root1和root2是不同的集合</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将root2合并到root1中</span></span><br><span class="line">    S[root2] = root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-4-FIND优化——压缩路径"><a href="#5-3-4-FIND优化——压缩路径" class="headerlink" title="5.3.4.FIND优化——压缩路径"></a>5.3.4.FIND优化——压缩路径</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先找到根节点，然后进行压缩路径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>) root = S[root];    <span class="comment">//循环找到当前结点的根节点</span></span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;    <span class="comment">//循环直到x指向根节点</span></span><br><span class="line">        <span class="type">int</span> temp = S[x];    <span class="comment">//用temp保存x的父结点</span></span><br><span class="line">        S[x] = root;    <span class="comment">//将结点x的父节点修改为根节点</span></span><br><span class="line">        x = temp;    <span class="comment">//x更新为原父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-5-UNION优化——小树合并大树"><a href="#5-3-5-UNION优化——小树合并大树" class="headerlink" title="5.3.5.UNION优化——小树合并大树"></a>5.3.5.UNION优化——小树合并大树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中根节点的值为其集合中结点的总数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], root1, root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 &lt;= root2) &#123;    <span class="comment">//root1的结点数更多或者二者相等</span></span><br><span class="line">        S[root1] += S[root2];    <span class="comment">//更新root1的结点数为root1和root2的总和</span></span><br><span class="line">        S[root2] = root1;    <span class="comment">//将root2合并到root1中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//root2的结点数更多</span></span><br><span class="line">        S[root2] += S[root1];</span><br><span class="line">        S[root1] = root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-二叉树算法题"><a href="#5-4-二叉树算法题" class="headerlink" title="5.4.二叉树算法题"></a>5.4.二叉树算法题</h4><h5 id="5-4-1-计算二叉树中双分支结点的个数"><a href="#5-4-1-计算二叉树中双分支结点的个数" class="headerlink" title="5.4.1.计算二叉树中双分支结点的个数"></a>5.4.1.计算二叉树中双分支结点的个数</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/cafb376f570b4fada2460af133fee7fa.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">//双分支结点个数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="comment">//当前结点的左右孩子都存在，count++</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild) count++;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild) <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;rchild) <span class="built_in">Preorder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PreOrder</span>(T);    <span class="comment">//先序遍历该树</span></span><br><span class="line">    cout &lt;&lt; count;    <span class="comment">//输出双分支结点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-交换二叉树中所有左右子树"><a href="#5-4-2-交换二叉树中所有左右子树" class="headerlink" title="5.4.2.交换二叉树中所有左右子树"></a>5.4.2.交换二叉树中所有左右子树</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/a64f890e722b45f78fe588f23ecca770.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);</span><br><span class="line">        BiTNode *t = T-&gt;lchild;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild;</span><br><span class="line">        T-&gt;rchild = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Post</span>(<span class="built_in">Order</span>(T));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-求先序遍历第k个元素"><a href="#5-4-3-求先序遍历第k个元素" class="headerlink" title="5.4.3.求先序遍历第k个元素"></a>5.4.3.求先序遍历第k个元素</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/6805b416eefa4dc9a7aa4ea3b053c7c2.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        t--;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) res = T-&gt;data;    <span class="comment">//第k个结点，用res保存当前结点的值</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归访问左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(BiTree T, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    t = k;</span><br><span class="line">    <span class="built_in">PreOrder</span>(T);</span><br><span class="line">    cout &lt;&lt; res;    <span class="comment">//输出第k个结点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-4-删去值为x的子树"><a href="#5-4-4-删去值为x的子树" class="headerlink" title="5.4.4.删去值为x的子树"></a>5.4.4.删去值为x的子树</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/54aaa4bce6424c299e487ebbaa87ae16.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;T)</span></span>&#123;    <span class="comment">//后序遍历的方式删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">DeleteX</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">DeleteX</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        BiTNode *t;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild-&gt;data == k) &#123;    <span class="comment">//左子树的值为x，删除左子树</span></span><br><span class="line">            t = T-&gt;lchild;</span><br><span class="line">            T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">Delete</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;rchild-&gt;data == k) &#123;    <span class="comment">//右子树的值为x，删除右子树</span></span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">            T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">Delete</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild) <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;rchild) <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;<span class="comment">//if</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(BiTree &amp;T, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    k = x;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) &#123;    <span class="comment">//根节点的值为x，删除整个树并返回</span></span><br><span class="line">        <span class="built_in">Delete</span>(T);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">PreOrder</span>(T);    <span class="comment">//先序遍历x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;T)</span> </span>&#123;    <span class="comment">//后序遍历，并删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree &amp;T, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) &#123;    <span class="comment">//根节点的值为x，删除整个树，并返回</span></span><br><span class="line">        <span class="built_in">Delete</span>(T);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);    <span class="comment">//初始化队列</span></span><br><span class="line">    BiTNode *p = T;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, p);    <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild-&gt;data == x) &#123;</span><br><span class="line">                BiTNode *q = p-&gt;lchild;</span><br><span class="line">                p-&gt;lchild = <span class="literal">NULL</span>;    <span class="comment">//左孩子指针置空</span></span><br><span class="line">                <span class="built_in">Delete</span>(q);    <span class="comment">//以q为根节点的子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">EnQueue</span>(Q, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) &#123; &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild-&gt;data == x) &#123;</span><br><span class="line">                BiTNode *q = p-&gt;rchild;</span><br><span class="line">                p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">Delete</span>(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">EnQueue</span>(Q, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-5-查找二叉树中两个结点的公共祖先结点"><a href="#5-4-5-查找二叉树中两个结点的公共祖先结点" class="headerlink" title="5.4.5.查找二叉树中两个结点的公共祖先结点"></a>5.4.5.查找二叉树中两个结点的公共祖先结点</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/59da31125bff423a875a1b8ce85b8673.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTNode *<span class="title">ans</span><span class="params">(BiTree ROOT, BiTNode *p, BiTNode *q)</span> </span>&#123;</span><br><span class="line">	Stack S, Sp, Sq;	<span class="comment">//Sp和Sq分别用来保存p和q的祖先结点</span></span><br><span class="line">	S.top = <span class="number">-1</span>;	<span class="comment">//初始化队列</span></span><br><span class="line">	BiTNode* t = ROOT, *pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (t || S.top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t) &#123;	<span class="comment">//t结点非空</span></span><br><span class="line">			S.data[++S.top] = t;	<span class="comment">//t结点入队</span></span><br><span class="line">			t = t-&gt;lchild;	<span class="comment">//进入t的左子树</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//t结点为空</span></span><br><span class="line">			t = S.data[S.top];	<span class="comment">//查看栈顶元素</span></span><br><span class="line">            <span class="comment">//t的右子树存在，并且上一个访问的并不是其右子树</span></span><br><span class="line">			<span class="keyword">if</span> (t-&gt;rchild &amp;&amp; t-&gt;rchild != pre) &#123;	</span><br><span class="line">				t = t-&gt;rchild;	<span class="comment">//进入右子树</span></span><br><span class="line">				S.data[++S.top] = t;	<span class="comment">//入栈该结点</span></span><br><span class="line">				t = t-&gt;rchild;	<span class="comment">//进入左子树</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//右子树不存在，或者存在但是上一个访问的是右子树</span></span><br><span class="line">				S.top--;	<span class="comment">//出栈该结点，并访问</span></span><br><span class="line">				<span class="keyword">if</span> (t == p) &#123;	<span class="comment">//当前结点为p，保存栈中内容，即其所有祖先结点</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.top; i++) Sp.data[i] = S.data[i];</span><br><span class="line">					Sp.top = S.top;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (t == q) &#123;	<span class="comment">//当前结点为q，保存栈中内容，即其所有祖先结点</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.top; i++) Sq.data[i] = S.data[i];</span><br><span class="line">					Sq.top = S.top;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">		&#125;<span class="comment">//if</span></span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">    <span class="comment">//自栈顶到栈顶分别遍历Sp和Sq找到最接近栈顶的相同祖先结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Sp.top; i &gt;= <span class="number">0</span>; i--) &#123;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = Sq.top; i &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Sp.data[i] == Sq.data[j]) <span class="keyword">return</span> Sp.data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//无相同祖先顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-6-求二叉树的宽度"><a href="#5-4-6-求二叉树的宽度" class="headerlink" title="5.4.6.求二叉树的宽度"></a>5.4.6.求二叉树的宽度</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/ccb1ae7ce764475ea764c119315612e4.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    BiTNode *data[MAXSIZE];    <span class="comment">//足够大的数组</span></span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//空树，返回0</span></span><br><span class="line">    BiTNode *p = T;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, p);    <span class="comment">//将p入队</span></span><br><span class="line">    <span class="comment">//rear指向当前层的最后一个结点，count记录当前层的结点数，max记录最大结点数</span></span><br><span class="line">    <span class="type">int</span> last = Q.rear, count = <span class="number">0</span>, max = INT_MIN;    </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        count++;    <span class="comment">//结点数+1</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);    <span class="comment">//p的左子树存在，左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);    <span class="comment">//p的右孩子存在，右孩子入队</span></span><br><span class="line">        <span class="keyword">if</span> (last == Q.front) &#123;    <span class="comment">//当前结点是本层的最后一个节点</span></span><br><span class="line">            last = Q.rear;    <span class="comment">//last指向下一层的最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; max) max = temp;    <span class="comment">//更新最大结点数</span></span><br><span class="line">            count = <span class="number">0</span>;    <span class="comment">//结点数归零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;	<span class="comment">//足够大的非循环数组</span></span><br><span class="line">	BiTNode *data[MAXSIZE];	<span class="comment">//结点数组，保存每个结点</span></span><br><span class="line">	<span class="type">int</span> level[MAXSIZE];	<span class="comment">//层数数组，记录每个结点的层数</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//头尾指针</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	BiTNode* p = T;</span><br><span class="line">	Queue Q;</span><br><span class="line">	Q.rear = Q.front = <span class="number">0</span>;	<span class="comment">//初始化队列</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		Q.data[Q.rear] = T;	<span class="comment">//根节点入队</span></span><br><span class="line">		Q.level[Q.rear] = <span class="number">1</span>;</span><br><span class="line">		Q.rear++;</span><br><span class="line">		<span class="keyword">while</span> (Q.front &lt; Q.rear) &#123;</span><br><span class="line">			p = Q.data[Q.front];	<span class="comment">//出队队首元素</span></span><br><span class="line">			<span class="type">int</span> level = Q.level[Q.front];	<span class="comment">//保存当前结点的层数</span></span><br><span class="line">			Q.front++;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild) &#123;	<span class="comment">//左孩子入队</span></span><br><span class="line">				Q.data[Q.rear] = p-&gt;lchild;</span><br><span class="line">				Q.level[Q.rear] = level + <span class="number">1</span>;</span><br><span class="line">				Q.rear++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild) &#123;	<span class="comment">//右孩子入队</span></span><br><span class="line">				Q.data[Q.rear] = p-&gt;rchild;</span><br><span class="line">				Q.level[Q.rear] = level + <span class="number">1</span>;</span><br><span class="line">				Q.rear++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//while</span></span><br><span class="line">		<span class="type">int</span> max = INT_MIN, i = <span class="number">0</span>, level = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= Q.rear) &#123;</span><br><span class="line">			<span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">//记录当前层的结点数</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt;= Q.rear &amp;&amp; level == Q.level[i]) &#123;</span><br><span class="line">				count++;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (count &gt; max) max = count;	<span class="comment">//更新每层的最大结点数</span></span><br><span class="line">			level = Q.level[i];	<span class="comment">//更新层数，while循环结束时，i指向下一层的第一个结点</span></span><br><span class="line">		&#125;<span class="comment">//while</span></span><br><span class="line">		<span class="keyword">return</span> max;	<span class="comment">//返回最大结点数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//空树，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-7-求二叉树的高度"><a href="#5-4-7-求二叉树的高度" class="headerlink" title="5.4.7.求二叉树的高度"></a>5.4.7.求二叉树的高度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Heigh</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;	<span class="comment">//前后指针</span></span><br><span class="line">	BiTNode* p = T;</span><br><span class="line">	BiTNode *data[MAXSIZE];	<span class="comment">//足够大的队列，元素是二叉树结点</span></span><br><span class="line">	data[rear++] = p;	<span class="comment">//根节点入队</span></span><br><span class="line">	<span class="type">int</span> last = rear, level = <span class="number">0</span>;	<span class="comment">//rear标记本层最后一个结点, level记录当前层数</span></span><br><span class="line">	<span class="keyword">while</span> (front &lt; rear) &#123;	<span class="comment">//循环直到队空</span></span><br><span class="line">		p = data[front++];	<span class="comment">//出队队首结点</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild) data[Q.rear++] = p-&gt;lchild;	<span class="comment">//左右孩子入队</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild) data[Q.rear++] = p-&gt;rchild;</span><br><span class="line">		<span class="keyword">if</span> (last == front) &#123;	<span class="comment">//当前结点为本层的最后一个结点</span></span><br><span class="line">			last = rear;	<span class="comment">//标记下层的最后一个结点</span></span><br><span class="line">			level++;	<span class="comment">//层数+1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">	<span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_High</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//空树返回0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> hl = <span class="built_in">Get_High</span>(T-&gt;lchild);    <span class="comment">//递归求左右子树高度</span></span><br><span class="line">        <span class="type">int</span> hr = <span class="built_in">Get_High</span>(T-&gt;rchild);</span><br><span class="line">        <span class="type">int</span> maxH = <span class="built_in">max</span>(hl, hr) + <span class="number">1</span>;    <span class="comment">//树高等于左右子树更高的那个+1</span></span><br><span class="line">        <span class="keyword">return</span> maxH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-8-排序二叉树的判定"><a href="#5-4-8-排序二叉树的判定" class="headerlink" title="5.4.8.排序二叉树的判定"></a>5.4.8.排序二叉树的判定</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pre = INT_MIN;	<span class="comment">//标记上一个结点的值，初始值为INT类型的最小值</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//空树，是排序二叉树</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">JudgeBST</span>(T-&gt;lchild);	<span class="comment">//判断左子树</span></span><br><span class="line">        <span class="comment">//当前值小于等于pre的值，或左子树不满足排序二叉树定义，返回0</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data &lt;= pre|| l == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pre = T-&gt;data;	<span class="comment">//更新pre为当前结点值</span></span><br><span class="line">		<span class="type">int</span> r = <span class="built_in">JudgeBST</span>(T-&gt;rchild);	<span class="comment">//判断右子树</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[n];	<span class="comment">//足够大的数组，保存每个节点的值</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">//记录结点个数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;lchild);	</span><br><span class="line">		A[count++] = T-&gt;data;	<span class="comment">//记录当前结点值，并且count+1</span></span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ans</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//空树为排序二叉树</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//只有根节点，是排序二叉树</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T);	<span class="comment">//中序遍历二叉树，并且记录每个结点的值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt;= A[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//非排序二叉树</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//排序二叉树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-9-平衡二叉树的判定"><a href="#5-4-9-平衡二叉树的判定" class="headerlink" title="5.4.9.平衡二叉树的判定"></a>5.4.9.平衡二叉树的判定</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Height</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> hl = <span class="built_in">Get_Height</span>(T-&gt;lchild);	<span class="comment">//递归求左子树高度</span></span><br><span class="line">		<span class="type">int</span> hr = <span class="built_in">Get_Height</span>(T-&gt;rchild);	<span class="comment">//递归求右子树高度</span></span><br><span class="line">		<span class="type">int</span> maxH = <span class="built_in">max</span>(hl, hr) + <span class="number">1</span>;	<span class="comment">//树高为左右子树更高的那个 + 1</span></span><br><span class="line">		<span class="keyword">return</span> maxH;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JudgeBalance</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//空树为平衡二叉树</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> hl = <span class="built_in">Get_Height</span>(T-&gt;lchild);	<span class="comment">//左子树高度</span></span><br><span class="line">		<span class="type">int</span> hr = <span class="built_in">Get_Height</span>(T-&gt;rchild);	<span class="comment">//右子树高度</span></span><br><span class="line">		<span class="comment">//当前结点的左右平衡因子小于等于1，递归判断其左右子树是否满足平衡二叉树</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(hl - hr) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JudgeBalance</span>(T-&gt;lchild) &amp;&amp; <span class="built_in">JudgeBalance</span>(T-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前节点左右平衡因子大于1，则已不满足平衡二叉树，无需判断左右子树，返回false</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-10-完全二叉树的判定"><a href="#5-4-10-完全二叉树的判定" class="headerlink" title="5.4.10.完全二叉树的判定"></a>5.4.10.完全二叉树的判定</h5><p>①采用层次遍历的思想，与一般层次遍历的区别是空结点也能入队</p>
<p>②当出队元素为空时（设该结点为P），进入内层循环（即③），逐一出队并检查该结点是否为空。</p>
<p>③若队中剩余元素有不为空的结点，则说明P之后还有结点（这个结点可能是与P同层，或是P的下一层）即不满足完全二叉树的定义；若队中剩余元素皆为空结点，说明P是该树的最后一个结点（最底层的最右结点），满足完全二叉树的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JudgeComplete</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	BiTNode* data[MAXSIZE];	<span class="comment">//足够大的队列</span></span><br><span class="line">	<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;	<span class="comment">//头尾指针</span></span><br><span class="line">	BiTNode* p = T;	</span><br><span class="line">	data[rear++] = T;	<span class="comment">//根节点入队</span></span><br><span class="line">	<span class="keyword">while</span> (front &lt; rear) &#123;	<span class="comment">//循环直到队空</span></span><br><span class="line">		p = data[front++];	<span class="comment">//出队队首元素</span></span><br><span class="line">		<span class="keyword">if</span> (p) &#123;	<span class="comment">//p结点存在，入队左右孩子</span></span><br><span class="line">			data[rear++] = p-&gt;lchild;</span><br><span class="line">			data[rear++] = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//p结点不存在，出队剩余元素</span></span><br><span class="line">			<span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">				p = data[front++];</span><br><span class="line">				<span class="keyword">if</span> (p) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//当前元素为非空，则为非完全二叉树</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-11-真题"><a href="#5-4-11-真题" class="headerlink" title="5.4.11.真题"></a>5.4.11.真题</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/6f2f5d0118df435db4b92a0872d5d5ce.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WPL = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T, <span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!T-&gt;left &amp;&amp; !T-&gt;right) &#123;    <span class="comment">//叶子结点</span></span><br><span class="line">            WPL = WPL + T.weight * deep;    <span class="comment">//更新WPL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;left) <span class="built_in">InOrder</span>(T-&gt;left, deep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;right) <span class="built_in">InOrder</span>(T-&gt;right, deep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InOrder</span>(T, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> WPL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_WPL</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">	BiTNode* data[MAXSIZE];	<span class="comment">//足够大的非循环数组</span></span><br><span class="line">	BiTNode* p = root;</span><br><span class="line">	<span class="type">int</span> f = <span class="number">0</span>, r = <span class="number">0</span>, level = <span class="number">0</span>, WPL = <span class="number">0</span>, last = <span class="number">0</span>;	</span><br><span class="line">	data[r++] = p;	<span class="comment">//根节点入队</span></span><br><span class="line">	last = r;	<span class="comment">//last标记本层的最后一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (f &lt; r) &#123;</span><br><span class="line">		p = data[f++];	<span class="comment">//队首元素出队</span></span><br><span class="line">        <span class="comment">//该结点为叶子结点，计算WPL</span></span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) WPL = WPL + level * p-&gt;weight;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild) data[r++] = p-&gt;left;	<span class="comment">//左右孩子入队</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild) data[r++] = p-&gt;right;</span><br><span class="line">		<span class="keyword">if</span> (last == f) &#123;	<span class="comment">//该结点为本层的最后一个结点</span></span><br><span class="line">			last = r;	<span class="comment">//更新last和level</span></span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> WPL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/f184da9060ed4f348f5a5207d442c7f6.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T, <span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">1</span> &amp;&amp; (T-&gt;lchild || T-&gt;rchild)) cout &lt;&lt; <span class="string">&#x27;(&#x27;</span>;    <span class="comment">//分支节点打印左括号</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild) <span class="built_in">InOrder</span>(T-&gt;lchild, deep + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; T-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;rchild) <span class="built_in">InOrder</span>(T-&gt;rchild, deep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">1</span> &amp;&amp; (T-&gt;lchild || T-&gt;rchild)) cout &lt;&lt; <span class="string">&#x27;)&#x27;</span>;    <span class="comment">//分支节点打印右括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InOrder</span>(T, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-图"><a href="#6-图" class="headerlink" title="6.图"></a>6.图</h3><h4 id="6-1-图的数据结构定义"><a href="#6-1-图的数据结构定义" class="headerlink" title="6.1.图的数据结构定义"></a>6.1.图的数据结构定义</h4><h5 id="6-1-1-邻接矩阵"><a href="#6-1-1-邻接矩阵" class="headerlink" title="6.1.1.邻接矩阵"></a>6.1.1.邻接矩阵</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MAXVEX];    <span class="comment">//一维数组，存放顶点数据</span></span><br><span class="line">    <span class="type">int</span> edge[MAXVEX][MAXVEX];    <span class="comment">//二维数组，存放边数据（权值）</span></span><br><span class="line">    <span class="type">int</span> vexNum, edgeNum;    <span class="comment">//顶点总数和边总数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-2-邻接表"><a href="#6-1-2-邻接表" class="headerlink" title="6.1.2.邻接表"></a>6.1.2.邻接表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">edgeNode</span> &#123;    <span class="comment">//边</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edgeNode</span> *next;    <span class="comment">//指向下一条邻接边的指针</span></span><br><span class="line">    <span class="type">int</span> weight;    <span class="comment">//该邻接边权值</span></span><br><span class="line">    <span class="type">int</span> adjVex;    <span class="comment">//该邻接边指向的顶点编号</span></span><br><span class="line">&#125;edgeNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vexNode</span> &#123;    <span class="comment">//顶点</span></span><br><span class="line">    edgeNode *firstEdge;    <span class="comment">///指向该顶点的第一条邻接边</span></span><br><span class="line">    <span class="type">int</span> vexData;    <span class="comment">//该顶点数据</span></span><br><span class="line">&#125;vexNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;    <span class="comment">//图</span></span><br><span class="line">    <span class="type">int</span> vexNum, edgeNum;    <span class="comment">//顶点数，边数</span></span><br><span class="line">    vexNode vex[MAXVEX];    <span class="comment">//vexNode类型的一维数组vex</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-图的遍历"><a href="#6-2-图的遍历" class="headerlink" title="6.2.图的遍历"></a>6.2.图的遍历</h4><h5 id="6-2-1-深度优先遍历"><a href="#6-2-1-深度优先遍历" class="headerlink" title="6.2.1.深度优先遍历"></a>6.2.1.深度优先遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"><span class="type">bool</span> visited[MAXVEX];    <span class="comment">//visited数组记录该顶点是否被访问过</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span> <span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexNum; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;    <span class="comment">//初始化visited数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) <span class="built_in">DFS</span> (G, i);    <span class="comment">//当前顶点未被访问过，则访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span> <span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span> (v);    <span class="comment">//访问顶点v（具体操作）</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;    <span class="comment">//更新visited数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span> (G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span> (G, v, w))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) <span class="built_in">DFS</span>(G, w);    <span class="comment">//递归调用DFS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-广度优先遍历"><a href="#6-2-2-广度优先遍历" class="headerlink" title="6.2.2.广度优先遍历"></a>6.2.2.广度优先遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line">Queue Q;</span><br><span class="line"><span class="type">bool</span> visited[MAXVEX];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span> <span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexNum; i++) &#123;    <span class="comment">//初始化visited数组</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue Q;    <span class="comment">//初始化队列Q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexNum; i++) &#123;    <span class="comment">//遍历图</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) <span class="built_in">BFS</span>(G, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span> <span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);    <span class="comment">//访问该顶点（具体操作）</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;    <span class="comment">//更新visited数组</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);    <span class="comment">//将v结点入队</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);    <span class="comment">//队首元素出队</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;    <span class="comment">//顶点未被访问过</span></span><br><span class="line">                <span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-单源最短路径"><a href="#6-3-单源最短路径" class="headerlink" title="6.3.单源最短路径"></a>6.3.单源最短路径</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100</span></span><br><span class="line"><span class="type">bool</span> visited[MAXVEX];</span><br><span class="line"><span class="type">int</span> dis[MAXVEX];</span><br><span class="line">Queue Q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min_Dis</span> <span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexNum; i++) &#123;    <span class="comment">//初始化visited数组和dis数组</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">        dis[i] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    dis[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FisrtNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                dis[w] = dis[v] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-真题"><a href="#6-4-真题" class="headerlink" title="6.4.真题"></a>6.4.真题</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/fa4a011572674952bb92acaee9c519c5.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsExistEL</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">//记录该图中度为奇数的顶点个数</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertices; i++)&#123;    <span class="comment">//行遍历邻接矩阵</span></span><br><span class="line">        <span class="type">int</span> degree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.numVertices; j++)&#123;    <span class="comment">//列遍历当前行</span></span><br><span class="line">            <span class="keyword">if</span> (Edge[i][j] &gt; <span class="number">0</span>) degree++;    <span class="comment">//当前数组元素不为0，则度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (degree % <span class="number">2</span>) count++;    <span class="comment">//当前顶点的度为奇数，count++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || count == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//奇数顶点个数为0或者2，有EL路径</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//奇数顶点个数不为0或者2，没有EL路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(<span class="type">int</span> A[], L, R)</span> </span>&#123;    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;    <span class="comment">//当前数组长度 &lt;= 1，返回</span></span><br><span class="line">    随机选择数组中一元素和A[L]互换    <span class="comment">//快排优化，使得基准元素的选取随机</span></span><br><span class="line">    <span class="type">int</span> key = A[L], i = L, j = R;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt; A[j]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[i] &lt;= key) i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span> (A[i], A[j]);    <span class="comment">//交换A[i]和A[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span> (A[i], A[L]);</span><br><span class="line">    <span class="built_in">Qsort</span> (A, L, i - <span class="number">1</span>);    <span class="comment">//递归处理左区间</span></span><br><span class="line">    <span class="built_in">Qsort</span> (A, i + <span class="number">1</span>, R);    <span class="comment">//递归处理右区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-折半查找"><a href="#8-折半查找" class="headerlink" title="8.折半查找"></a>8.折半查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span> <span class="params">(<span class="type">int</span> A, L, R, key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;    <span class="comment">//L &gt;= R时，范围错误</span></span><br><span class="line">        mid = (L + R) / <span class="number">2</span>;    <span class="comment">//选择中间数，向下取整</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt;= A[mid]) R = mid;    <span class="comment">//更新范围</span></span><br><span class="line">        <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[mid] == key) <span class="keyword">return</span> mid;    <span class="comment">//查找成功，返回数组下标</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2023/11/12/Data%20Structure%20Algorithm/">https://centlabs.github.io/2023/11/12/Data%20Structure%20Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Data Structure - 王道</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/12/Data%20Structure/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Data Structure</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-14</div><div class="title">Data Structure - 题库</div></div></a></div><div><a href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Data Structure - 王道</div></div></a></div><div><a href="/2023/11/12/Data%20Structure/" title="Data Structure"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Data Structure</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数据结构算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%89%8D%E5%90%8E%E7%BF%BB%E8%BD%AC"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.将一个数组前后翻转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%80%BC%E4%B8%BAx%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2.删除数组中值为x的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3.将两个有序数组合并成一个有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E7%9C%9F%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4.真题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1.链表的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1.单链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2.双链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.链表的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-%E5%A4%B4%E6%8F%92%E6%B3%95%EF%BC%88%E6%8F%92%E5%85%A5%E5%88%B0%E9%93%BE%E8%A1%A8%E5%A4%B4%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1.头插法（插入到链表头）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-%E5%B0%BE%E6%8F%92%E6%B3%95%EF%BC%88%E6%8F%92%E5%85%A5%E5%88%B0%E9%93%BE%E8%A1%A8%E5%B0%BE%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2.尾插法（插入到链表尾）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE%EF%BC%88%E5%A4%B4%E6%8F%92%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3.链表逆置（头插法实现）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4.链表的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.2.5.链表的删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3.链表算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-%E5%88%A0%E9%99%A4%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1.删除值为x的结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%B1%E5%9C%B0%E9%80%86%E7%BD%AE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2.单链表就地逆置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-%E5%B0%86%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3.将链表排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-%E6%8B%86%E5%88%86%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4.拆分链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5.删除链表中的重复元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-%E5%B0%86%E4%B8%A4%E4%B8%AA%E9%80%92%E5%A2%9E%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E9%80%92%E5%87%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">2.3.6.将两个递增链表合并成一个递减链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-7-%E5%B0%86%E4%B8%A4%E4%B8%AA%E9%80%92%E5%A2%9E%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%80%92%E5%A2%9E%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">2.3.7.将两个递增链表合并为一个递增链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-8-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">2.3.8.判断链表是否对称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-9-%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%BB%93%E7%82%B9%E5%80%BC%E6%9C%80%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.3.9.</span> <span class="toc-text">2.3.9.依次输出链表中结点值最小的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-10-%E7%9C%9F%E9%A2%98"><span class="toc-number">1.2.3.10.</span> <span class="toc-text">2.3.10.真题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">3.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1.栈的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1.顺序栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-%E9%93%BE%E6%A0%88"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2.链栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2.顺序栈的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1.栈的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E5%85%A5%E6%A0%88"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2.入栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E5%87%BA%E6%A0%88"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3.出栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4.判断栈空</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E9%93%BE%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3.链栈的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E5%85%A5%E6%A0%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2.入栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-%E5%87%BA%E6%A0%88"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3.出栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-4-%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.3.4.判断栈空</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">4.队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1.队列的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1.顺序队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2.链式队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2.顺序队列的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-%E5%85%A5%E9%98%9F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2.入队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E5%87%BA%E9%98%9F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3.出队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.2.4.判断队空</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3.链式队列的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1.初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E5%85%A5%E9%98%9F"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2.入队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E5%87%BA%E9%98%9F"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3.出队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4.判断队空</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">5.树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1.树的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1.二叉树的链式存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2.二叉树的顺序存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-3-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">5.1.3.双亲表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-4-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">5.1.4.孩子表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-5-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">5.1.5.孩子兄弟表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-6-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">5.1.6.线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2.二叉树的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1.先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2.中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3.后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">5.2.4.层次遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3.并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1.并查集的定义和初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-FIND%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2.FIND操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-3-UNION%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">5.3.3.UNION操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-FIND%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">5.3.4.FIND优化——压缩路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-UNION%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%B0%8F%E6%A0%91%E5%90%88%E5%B9%B6%E5%A4%A7%E6%A0%91"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">5.3.5.UNION优化——小树合并大树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4.二叉树算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1.计算二叉树中双分支结点的个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E4%BA%A4%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2.交换二叉树中所有左右子树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3.求先序遍历第k个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-%E5%88%A0%E5%8E%BB%E5%80%BC%E4%B8%BAx%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">5.4.4.删去值为x的子树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-5-%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%BB%93%E7%82%B9"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">5.4.5.查找二叉树中两个结点的公共祖先结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-6-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6"><span class="toc-number">1.5.4.6.</span> <span class="toc-text">5.4.6.求二叉树的宽度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-7-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-number">1.5.4.7.</span> <span class="toc-text">5.4.7.求二叉树的高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-8-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.4.8.</span> <span class="toc-text">5.4.8.排序二叉树的判定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-9-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.4.9.</span> <span class="toc-text">5.4.9.平衡二叉树的判定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-10-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.4.10.</span> <span class="toc-text">5.4.10.完全二叉树的判定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-11-%E7%9C%9F%E9%A2%98"><span class="toc-number">1.5.4.11.</span> <span class="toc-text">5.4.11.真题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">6.图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1.图的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">6.1.1.邻接矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">6.1.2.邻接表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2.图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1.深度优先遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2.广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3.单源最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E7%9C%9F%E9%A2%98"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4.真题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">7.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.</span> <span class="toc-text">8.折半查找</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 题库"/></a><div class="content"><a class="title" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库">Data Structure - 题库</a><time datetime="2023-11-14T13:59:04.475Z" title="Created 2023-11-14 21:59:04">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 王道"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道">Data Structure - 王道</a><time datetime="2023-11-12T15:05:01.134Z" title="Created 2023-11-12 23:05:01">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure Algorithm"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm">Data Structure Algorithm</a><time datetime="2023-11-12T13:02:28.408Z" title="Created 2023-11-12 21:02:28">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure/" title="Data Structure"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure/" title="Data Structure">Data Structure</a><time datetime="2023-11-12T09:47:27.180Z" title="Created 2023-11-12 17:47:27">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CTF竞赛介绍以及刷题网址"/></a><div class="content"><a class="title" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址">CTF竞赛介绍以及刷题网址</a><time datetime="2023-03-11T03:46:03.959Z" title="Created 2023-03-11 11:46:03">2023-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>