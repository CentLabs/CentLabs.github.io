<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机组成原理 | CentLabs</title><meta name="keywords" content="408"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、计算机系统概述【复习提示】本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。本章中读者要重点掌握各个性能指标的计算，这部分内容在历年真题中出现的频率很高。 1.1 计算机发展历程1.1.1 计算机硬件的发展">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="https://centlabs.github.io/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="一、计算机系统概述【复习提示】本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。本章中读者要重点掌握各个性能指标的计算，这部分内容在历年真题中出现的频率很高。 1.1 计算机发展历程1.1.1 计算机硬件的发展">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-11-20T15:53:48.956Z">
<meta property="article:modified_time" content="2023-12-07T13:00:07.524Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机组成原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-07 21:00:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机组成原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-20T15:53:48.956Z" title="Created 2023-11-20 23:53:48">2023-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-07T13:00:07.524Z" title="Updated 2023-12-07 21:00:07">2023-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">计算机学科专业基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机组成原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h3><p>【复习提示】<br>本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。本章中读者要重点掌握各个性能指标的计算，这部分内容在历年真题中出现的频率很高。</p>
<h4 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h4><h5 id="1-1-1-计算机硬件的发展"><a href="#1-1-1-计算机硬件的发展" class="headerlink" title="1.1.1 计算机硬件的发展"></a>1.1.1 计算机硬件的发展</h5><p>计算机系统 &#x3D; 硬件 + 软件</p>
<p>计算机硬件的发展：</p>
<ul>
<li>第一代计算机：(使用电子管)，</li>
<li>第二代计算机：(使用晶体管)，</li>
<li>第三代计算机：(使用较小规模的集成)，</li>
<li>第四代计算机：(使用较大规模的集成)，</li>
</ul>
<p>已经经历了4代，计算机的速度越来越快，并且体积变得越来越小。</p>
<p>发展趋势：更微型、多用途；更巨型、超高速</p>
<blockquote>
<p>晶体管之父：肖克利（1956年诺贝尔物理学奖得主）</p>
<p>1957年，”八叛徒”创立了仙童半导体<br>1959年，仙童半导体发明了“集成电路”<br>1968年，摩尔离开仙童，创立intel<br>1969年，仙童销售部负责人桑德斯离开仙童，创立AMD</p>
</blockquote>
<p><span style="color:red">摩尔定律：集成电路上的晶体管数量每18月就会翻一翻，所以每18月计算机的处理效率就会提高一倍。</span></p>
<h5 id="1-1-2-计算机软件的发展"><a href="#1-1-2-计算机软件的发展" class="headerlink" title="1.1.2 计算机软件的发展"></a>1.1.2 计算机软件的发展</h5><p>计算机软件技术的发展，促进计算机系统的发展。</p>
<p>计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从<strong>科学计算和工程计算的 FORTRAN</strong>、<strong>结构化程序设计的 PASCAL</strong>到<strong>面向对象的C++<strong>和</strong>适应网络环境的Java</strong>。</p>
<p>同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、 Linux等。</p>
<h5 id="1-1-3-计算机的分类与发展方向"><a href="#1-1-3-计算机的分类与发展方向" class="headerlink" title="1.1.3 计算机的分类与发展方向"></a>1.1.3 计算机的分类与发展方向</h5><p>可以分为：</p>
<ul>
<li>电子模拟计算机和电子数字计算机。</li>
</ul>
<p>数字计算机又可以按照用途分为：</p>
<ul>
<li>专用计算机和通用计算机</li>
<li>通用计算机又分为：巨型机、大型机、中型机、小型机、微型机和单片机6类。</li>
</ul>
<p>按照指令和数据流可以分为：</p>
<ul>
<li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构。</li>
<li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。</li>
<li>多指令流和单数据流系统（MISD），这种计算机实际上不存在。</li>
<li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。</li>
</ul>
<h4 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h4><h5 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h5><p>计算机系统由硬件系统和软件系统共同构建起来</p>
<h5 id="1-2-2-计算机硬件的基本组成"><a href="#1-2-2-计算机硬件的基本组成" class="headerlink" title="1.2.2 计算机硬件的基本组成"></a>1.2.2 计算机硬件的基本组成</h5><p>1、早期的冯·诺依曼机</p>
<blockquote>
<p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p>
</blockquote>
<blockquote>
<p>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</p>
<p>“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即按地址访问并顺序执行指令</p>
</blockquote>
<p>计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</p>
<p>冯诺曼体系结构特点: </p>
<ul>
<li>计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)</li>
<li><strong>指令和数据以同等地位存于存储器，可按地址寻访</strong></li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li>以运算器为中心</li>
</ul>
<blockquote>
<p>早期的冯·诺依曼机以<strong>运算器</strong>为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是<strong>控制流驱动方式</strong>！</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/0d742dfebdb1ecb04e4064161f067207.png" alt="image-20220124155439445"></p>
<p>2、现代计算机的组织结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d09d3489652ef1429feae311861ccf9e.png" alt="image-20220124155514424"></p>
<p>3、计算机的功能部件<br>主机：主存、运算器、控制器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011714554763.png" alt="在这里插入图片描述"></p>
<p>五大部分：</p>
<p>&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p>
<p>&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。</p>
<p>&lt;3&gt; 存储器，存储器分为 <strong>主存储器(内存储器，CPU能直接访问)</strong> 和<strong>辅助存储器</strong>(<strong>外存储器</strong>，协助主存储器记忆更多的信息，<span style="color:red">辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)</span>。</p>
<ul>
<li><p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(相联存储器既可以既可以按照地址寻址，又可以按照内容寻址，为了与传统存储器区别，又称为内容寻址的存储器！)</p>
</li>
<li><p>主存储器是由**地址寄存器(MAR)<strong>，</strong>数据寄存器(MDR)**，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117142540792.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><span style="color:red">地址寄存器（MAR）</span>：存放访存地址，经过地址译码后找到所选的存储单元。</p>
<p>MAR用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10^&#x3D;1024个存储单元，记为1K。<strong>MAR的长度&#x3D;PC的长度</strong>。</p>
</li>
<li><p><span style="color:red">数据寄存器（MDR）</span>：用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。</p>
<p><strong>MDR的位数&#x3D;存储字长</strong>，一般为字节的2次幂的整数倍。</p>
</li>
</ul>
<blockquote>
<p>注意：MAR与MDR虽然是存储器的一部分，但在现代计算机中却是存在于CPU中的；另外，后文提到的高速缓存（Cache），也存在于CPU中。</p>
</blockquote>
</li>
</ul>
<p>&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算</p>
<ul>
<li><strong>运算器的核心单元是算术逻辑单元(ALU：Arithmetic and Logical Unit)</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117142756847.png" alt="在这里插入图片描述"></p>
<ul>
<li>运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（X）、基址寄存器（BR）等，其中前3个寄存器是必须具备的。</li>
<li>运算器内还有程序状态寄存器（PSW），也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。</li>
</ul>
<p>&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为<strong>中央处理器，简称CPU</strong>。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117143001482.png" alt="在这里插入图片描述"></p>
<ul>
<li>PC用来存放当前欲执行指令的地址，具体自动加1的功能（这里的“1”指一条指令的长度），即可自动形成下一条指令的地址，它与主存的MAR之间有一条直接通路。</li>
<li>IR用来存放当前的指令，其内容来自主存的MDR。指令中的操作码OP（IR）送至CU，用以分析指令并发出各种微操作命令序列：而地址码Ad（IR）送往MAR，用以取操作数。</li>
</ul>
<blockquote>
<p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。<strong>CPU和主存储器共同构成主机，而除主机外的其他硬件装置(外存、I&#x2F;O设备等)统称为外部设备，简称外设。</strong></p>
</blockquote>
<p>图1.4所示为冯・诺依曼结构的模型机。CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改PC以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存是进行读操作还是写操作(读&#x2F;写控制信号)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210121090349881.png" alt="在这里插入图片描述"></p>
<p>CPU和主存之间通过一组总线相连，<strong>总线中有地址、控制和数据3组信号线</strong>。MAR中的地址信息会直接送到地址线上，用于指向读&#x2F;写操作的主存存储单元；控制线中有读&#x2F;写信号线，指出数据是从CPU写入主存还是从主存读出到CPU,根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。</p>
<h5 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h5><p>1、系统软件和应用软件<br>计算机软件，一般分为系统软件和应用软件：</p>
<ul>
<li><p>系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。</p>
<p>如操作系统（OS），数据库管理系统（DBMS），语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统(比如连接程序)。</p>
</li>
<li><p>应用软件：指用户为解决某个应用领域中的各类问题而编制的程序。</p>
<p>如各种科学计算类程序，工程设计类程序，数据统计与处理程序。</p>
</li>
</ul>
<p>注意：数据库管理系统和数据库系统是有区别的。<strong>数据库管理系统是系统软件</strong>。而<strong>数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成</strong>。所以只能说它里面有系统软件，但并不能说它为系统软件。</p>
<p>2、三个级别的语言</p>
<ul>
<li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。<span style="color:red"><strong>机器语言是计算机唯一可以直接识别和执行的语言。</strong></span></li>
<li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li>
<li>高级语言。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。<strong>通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</strong></li>
</ul>
<p><span style="color:red"><strong>由高级语言转换到汇编语言的过程叫做编译，由汇编语言转换到机器语言的过程叫做汇编，边翻译边执行的叫做解析</strong>。</span></p>
<p>计算机无法直接理解和执行高级语言程序，需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：</p>
<ul>
<li>汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。</li>
<li>解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。</li>
<li>编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。</li>
</ul>
<p><strong>机器语言是唯一可以控制cpu的语言</strong>，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在编译器中高级语言先转换为汇编再转换为机器语言，也有直接转换为机器语言的情况。</p>
<blockquote>
<p>机器语言是计算机唯一可以直接执行的语言，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</p>
<p><strong>解释程序的特点是翻译一句执行一句，边翻译边执行；由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编。</strong></p>
</blockquote>
<p>3、软件和硬件的逻辑功能等价性</p>
<ul>
<li>硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。</li>
<li><strong>软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。</strong></li>
<li>软件和硬件逻辑功能的等价性是计算机系统设计的重要依据，软件和硬件的功能分配及其界面的确定是计算机系统结构研究的重要内容。</li>
</ul>
<h5 id="1-2-4-计算机的工作过程"><a href="#1-2-4-计算机的工作过程" class="headerlink" title="1.2.4 计算机的工作过程"></a>1.2.4 计算机的工作过程</h5><p>程序被编译成二进制存储在主存中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231121203349597.png" alt="image-20231121203349597"></p>
<p>指令执行过程的描述：</p>
<blockquote>
<p>(MAR)：表示MAR里边的值为0</p>
<p>M(MAR) ：主存储器所指向的存储单元里边的值</p>
<p>OP（IR）：取操作码</p>
<p>Ad（IR）：取地址码</p>
</blockquote>
<ul>
<li>1）取数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117172058667.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）乘法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117172600539.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）加法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117172909779.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）存数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117173204649.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）停机</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117173316604.png" alt="在这里插入图片描述"></p>
<p>对于“取数”指令的执行过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117173446275.png" alt="在这里插入图片描述"></p>
<p>上图是计算机的工作流程，首先PC将指令地址发送给MAR，MAR根据地址在存储体中找到指令数据存放在MDR中，之后MDR将指令存放在IR中，取指令结束，之后指令中的操作码进入CU中，地址码重复上述取指令步骤，将数据发送到ACC中，执行指令结束。<strong>注意区分指令和数据的依据:指令周期的不同阶段。</strong></p>
<ul>
<li>IR存放当下欲执行的指令；</li>
<li>PC存放下一条指令的地址；</li>
<li>MAR存放欲访问的存储单元地址；</li>
<li>MDR存放从存储单元取来的数据！</li>
</ul>
<p><strong>地址译码器是主存的构成部分，不属于CPU</strong>；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器！</p>
<p>关于CPU存取速度的比较：<span style="color:red"><strong>寄存器（CPU内部）&gt; Cache(高速的SRAM) &gt; 内存 (SDRAM)</strong></span></p>
<h5 id="1-2-5-计算机系统的工作原理"><a href="#1-2-5-计算机系统的工作原理" class="headerlink" title="1.2.5 计算机系统的工作原理"></a>1.2.5 计算机系统的工作原理</h5><p>1）“存储程序”工作方式</p>
<p>一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括：从主存取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/587183fe978676474022cde344cc666b.png" alt="image-20230822174424558"></p>
<ul>
<li>程序执行前，先将程序<strong>第一条指令的地址</strong>存放到PC中</li>
<li>取指令时，将PC的内容作为地址访问主存</li>
<li>在每条指令执行过程中，都需要计算下条将执行指令的地址，并送至PC<ul>
<li>若当前指令为顺序型指令，则下条指令地址为PC的内容加上当前指令的长度</li>
<li>若当前指令为转跳型指令，则下条指令地址为指令中指定的目标地址</li>
</ul>
</li>
<li>当前指令执行完后，根据PC的值到主存中取出的是下条将要执行的指令</li>
</ul>
<p>2）从源程序到可执行文件</p>
<p>在计算机中编写的C语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/0f112d10949bdefdd513060adb4a254c.png" alt="image-20230822174744164"></p>
<ul>
<li><p>预处理阶段：<strong>预处理器（cpp）</strong>对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以 .i 为扩展名的源文件hello.i。</p>
</li>
<li><p>编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。</p>
<p>汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</p>
</li>
<li><p>汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。</p>
</li>
<li><p>链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。</p>
</li>
</ul>
<p>3）指令执行过程的描述</p>
<p>可执行文件代码段是由一条一条机器指令构成的，指令是用0和1表示的一串0&#x2F;1序列，用来指示CPU完成一个特定的原子操作。下图为冯·诺依曼结构的简单模型机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/b92acdcb21a88b287739166e5733b74a.png" alt="image-20230823085017290"></p>
<p> 下面以取数指令（送至运算器的ACC中）为例来说明，其信息流程如下：</p>
<ul>
<li><p>取指令：PC→MAR→M→MDR→IR</p>
<p>根据PC取指令到IR。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读信号送读&#x2F;写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。</p>
</li>
<li><p>分析指令：OP（IR）→CU</p>
<p>指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR中是取数指令，因此读控制信号被送到总线的控制线上。</p>
</li>
<li><p>执行指令：Ad（IR）→MAR→M→MDR→ACC</p>
<p>取数操作。将IR中指令的地址码送MAR，MAR中的内容送地址线，同时控制器将读信号送读&#x2F;写信号线，从主存中读出操作数，并通过数据线送至MDR，再传送到ACC中。</p>
<p>每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即（PC）+1→PC。</p>
</li>
</ul>
<h5 id="1-2-6-计算机系统的层次结构"><a href="#1-2-6-计算机系统的层次结构" class="headerlink" title="1.2.6 计算机系统的层次结构"></a>1.2.6 计算机系统的层次结构</h5><p>下层是上层的基础，上层是下层的扩展。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/c05bd84fd952372bdbadceb6c90742ed.png" alt="image-20220124164821189"></p>
<ul>
<li><p>M4：高级语言机器（执行高级语言）它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。</p>
<p>在高级语言层之上，还可以有应用程序层，它由解决实际问题的处理程序组成，如文字处理软件、多媒体处理软件和办公自动软件等。</p>
</li>
<li><p>M3：汇编语言机器（执行汇编语言）：它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。</p>
</li>
<li><p>M2：操作系统机器（向上提供广义指令）：它由操作系统程序实现。</p>
<p>操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。</p>
</li>
<li><p>M1：传统机器（执行机器语言指令）：它也是一个实际的机器层，由微程序解释机器指令系统。</p>
</li>
<li><p>M0：微程序机器（执行微指令）：这是一个实在的硬件层，它由机器硬件直接执行微指令。</p>
</li>
</ul>
<blockquote>
<p>没有配备软件的纯硬件系统称为<strong>裸机</strong>。</p>
<p>M2~M4层称为虚拟机，简单来说就是软件实现的机器。虚拟机器只对该层的观察者存在，对于某层的观察者来说，只能通过该层的语言来了解和使用计算机，而不必关心下层是如何工作的。</p>
</blockquote>
<p>软件和硬件之间的界面就是<strong>指令集体系结构</strong>（ISA），ISA定义了一台计算机<strong>可以执行的所有指令的集合</strong>，每条指令规定了<strong>计算机执行什么操作</strong>，以及所处理的<strong>操作数存放的地址空间和操作数类型</strong>。可以看出，ISA是指软件能感知到的部分，也称软件可见部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/db91312669c9c643d5793cbb6c39ad96.png" alt="image-20220124164939418"></p>
<ul>
<li>编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)</li>
<li>解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)</li>
</ul>
<h4 id="1-3-计算机性能指标"><a href="#1-3-计算机性能指标" class="headerlink" title="1.3 计算机性能指标"></a>1.3 计算机性能指标</h4><ul>
<li>1）存储器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2e48d9ad8d1e09f14110519e9b98bbf8.png" alt="image-20220124165253241"></p>
<ul>
<li>2）CPU</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/5a609bde1d19810e6f9a1a1b3c301d57.png" alt="image-20220124170634769"></p>
<ul>
<li>3）系统整体的性能指标</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/f9c41c015f846bc3a03799885986f825.png" alt="image-20220124170834659"></p>
<ul>
<li>4）知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117153043725.png" alt="在这里插入图片描述"></p>
<h5 id="1、机器字长"><a href="#1、机器字长" class="headerlink" title="1、机器字长"></a>1、机器字长</h5><p><strong>计算机的位数（机器字长），表示计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数。</strong>计算机字长通常选定为字节(8位)的整数倍，通常是2、4、8倍。不同的计算机，字节可能不同。</p>
<blockquote>
<p>机器字长、指令字长、存储字长的区别和联系是什么？</p>
</blockquote>
<ul>
<li>机器字长：计算机能直接处理的二进制数据的位数，<strong>机器字长一般等于内部寄存器的大小</strong>，它决定了计算机的运算精度。</li>
<li>指令字长：一个指令字中包含的二进制代码的位数。</li>
<li>存储字长：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>， 它们都必须是字节的整数倍。</li>
<li>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</li>
</ul>
<p><span style="color:red">指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</span></p>
<p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p>
<p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。<strong>而32位处理器是无法使用64位操作系统的。</strong></p>
<h5 id="2、数据通路带宽"><a href="#2、数据通路带宽" class="headerlink" title="2、数据通路带宽"></a>2、数据通路带宽</h5><ul>
<li><p>数据通路带宽是指数据总线<strong>一次所能并行传送信息的位数</strong>。</p>
</li>
<li><p>这里所说的数据通路宽度是指<strong>外部数据总线</strong>的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。</p>
</li>
</ul>
<h5 id="3、主存容量"><a href="#3、主存容量" class="headerlink" title="3、主存容量"></a>3、主存容量</h5><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长（如 512K×16位）来表示存储容量。其中，<strong>MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长</strong>。</p>
<p>例如，MAR为16位，表示2^16^ &#x3D; 64K&#x3D;65536，即此存储体内有65536个存储单元（可称为64K内存，1K&#x3D;1024），若MDR为32位，表示存储容量为2^16^x32 &#x3D; 64K×32。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231118211808422.png" alt="image-20231118211808422"></p>
<h5 id="4、运算速度"><a href="#4、运算速度" class="headerlink" title="4、运算速度"></a>4、运算速度</h5><ul>
<li><p>吞吐量：指系统在单位时间内处理请求的数量 ；从用户观点看，它是评价计算机系统性能的综合参数！</p>
<p>它取决于信息能<strong>多快地输入内存</strong>，CPU能<strong>多快地取指令</strong>，数据能<strong>多快地从内存取出或存入</strong>，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要<strong>取决于主存的存取周期</strong>。</p>
</li>
<li><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。</p>
<p>通常包括<strong>CPU时间</strong>（运行一个程序所花费的时间）与 <strong>等待时间</strong>（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等的时间）。</p>
</li>
<li><p>CPU时钟周期：通常为节拍脉冲或T周期，即主频的倒数，它是<strong>CPU中最小的时间单位</strong>，每个动作至少需要1个时钟周期。</p>
</li>
<li><p><strong>主频(CPU时钟频率)<strong>：机器内部主时钟的频率，是衡量机器速度的重要参数。对于同个型号的计算机，其</strong>主频越高</strong>，完成指令的一个执行步骤所用的时间越短，执行指令的<strong>速度越快</strong>。例如，常用CPU的主频有1.8GHz、2.4GHz、2.8GHz等。</p>
<ul>
<li><p>CPU时钟周期&#x3D;1&#x2F;主频，主频通常以Hz（赫兹）为单位，<strong>1Hz表示每秒1次</strong>。</p>
</li>
<li><p><strong>CPU周期又称为机器周期，由多个时钟周期组成</strong>！</p>
</li>
<li><p>指令周期 &gt; CPU周期 &gt; 时钟周期</p>
</li>
</ul>
</li>
<li><p><strong>CPI（Clock cycle Per Instruction）：即执行一条指令所需的时钟周期数。</strong></p>
<p>不同指令的<strong>时钟周期数可能不同</strong>，因此对于一个程序或一台机器来说，其CPI指该程序或该机器指令集中的所有指令执行所需的<strong>平均时钟周期数</strong>，此时CPI是一个<strong>平均值</strong>。</p>
</li>
<li><p>CPU执行时间，指运行一个程序所花费的时间。</p>
<ul>
<li><span style="color:red"><strong>CPU执行时间 &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数xCPI)&#x2F;主频</strong></span></li>
<li>CPU的性能（CPU执行时间）取决于三个要素:主频（时钟频率）、CPI 、指令条数</li>
</ul>
</li>
<li><p><strong><span style="color:red">IPS</span>(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</strong></p>
</li>
<li><p><span style="color:red">MIPS</span>(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令</p>
<ul>
<li>M<strong>I</strong>PS&#x3D; 指令条数 &#x2F;（执行时间×10^6^）&#x3D; 主频 &#x2F;（CPI × 10^6^）</li>
<li>MIPS对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就 不同，比如在机器M1上某条指令的功能也许在机器M2上要用多条指令来完成；不同机器的CPI 和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:red">MFLOPS</span>(Mega Floating-point Operations Per Second)，即每秒执行多少百万次浮点运算。</p>
<p>MFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间×10^6^）</p>
<p><span style="color:red">GFLOPS</span>(Giga Floating-point Operations Per Second)，即每秒执行多少十亿次浮点运算。</p>
<p>GFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间×10^9^）</p>
<p><span style="color:red">TFLOPS</span>(Tera Floating-point Operations Per Second)，即每秒执行多少万亿次浮点运算。</p>
<p>TFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间×10^12^）</p>
<p>此外，还有</p>
<p>PFLOPS&#x3D; 浮点操作次数  &#x2F;（执行时间×10^15^）;</p>
<p>EFLOPS&#x3D;浮点操作次数  &#x2F;（执行时间×10^18^）;</p>
<p>ZFLOPS&#x3D;浮点操作次数  &#x2F;（执行时间×10^21^）</p>
</blockquote>
<h5 id="5、常用数量单位"><a href="#5、常用数量单位" class="headerlink" title="5、常用数量单位"></a>5、常用数量单位</h5><ul>
<li>描述存储容量、文件大小时：K&#x3D;2^10^，M&#x3D;2^20^，G&#x3D;2^30^，T&#x3D;2^40^</li>
<li>描述频率、速率时：K&#x3D;10^3^，M&#x3D;10^6^，G&#x3D;10^9^，T&#x3D;10^12^</li>
</ul>
<h5 id="6、基准程序"><a href="#6、基准程序" class="headerlink" title="6、基准程序"></a>6、基准程序</h5><p><strong>基准程序</strong>（Benchmarks）是专门用来进行性能评价的一组程序，能够很好地反映<strong>机器在运行实际负载时的性能</strong>，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而<strong>评测其性能</strong>。</p>
<h5 id="7、几个专业术语"><a href="#7、几个专业术语" class="headerlink" title="7、几个专业术语"></a>7、几个专业术语</h5><ul>
<li><strong>系列机</strong>。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</li>
<li><strong>兼容</strong>。指软件或硬件的通用性，即运行在某个型号的计算机系统中的硬件&#x2F;软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。</li>
<li><strong>软件可移植性</strong>。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。</li>
<li><strong>固件</strong>。将程序固化在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软&#x2F;硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软&#x2F;硬件结合的产物例如，目前操作系统已实现了部分固化（把软件永恒地存储于ROM中）。</li>
</ul>
<h4 id="1-4-本章提出的问题与回答"><a href="#1-4-本章提出的问题与回答" class="headerlink" title="1.4 本章提出的问题与回答"></a>1.4 本章提出的问题与回答</h4><h5 id="1、计算机由哪几部分组成？以哪部分为中心？"><a href="#1、计算机由哪几部分组成？以哪部分为中心？" class="headerlink" title="1、计算机由哪几部分组成？以哪部分为中心？"></a>1、计算机由哪几部分组成？以哪部分为中心？</h5><ul>
<li><strong>计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成</strong>，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。</li>
<li>而在微处理器面世之前<span style="color:red">(早期的冯·诺依曼机)</span>，运算器和控制器分离，而且存储器的容量很小，因此设计成<span style="color:red">以运算器为中心</span>的结构，其他部件都通过运算器完成信息的传递。</li>
<li>随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量IO设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。<span style="color:red">现代计算机已经发展为以存储器为中心</span>，使IO操作尽可能地绕过CPU,直接在IO设备和存储器之间完成，以提高系统的整体运行效率。</li>
</ul>
<h5 id="2、主频高的CPU一定比主频低的CPU快吗？为什么？"><a href="#2、主频高的CPU一定比主频低的CPU快吗？为什么？" class="headerlink" title="2、主频高的CPU一定比主频低的CPU快吗？为什么？"></a>2、主频高的CPU一定比主频低的CPU快吗？为什么？</h5><p>衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频，即CPU内核工作的时钟频率。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为<span style="color:red">CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、 Cache大小等）</span>。由于主频并不直接代表运算速度，因此<strong>在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。</strong></p>
<blockquote>
<p>来看看这个电脑的配置，感受一下，以后计算机组成原理中的Cache和主频等<img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210121093352285.png" alt="在这里插入图片描述"></p>
</blockquote>
<h5 id="3、翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？"><a href="#3、翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？" class="headerlink" title="3、翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？"></a>3、翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</h5><ul>
<li>翻译程序是指把高级语言源程序翻译成机器语言程序（目标代码）的软件。</li>
<li>翻译程序有两种：一种是<strong>编译程序</strong>，<strong>它将高级语言源程序一次全部翻译成目标程序</strong>，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无须重新翻译，请注意同一种高级语言在不同体系结构下，编译成目标程序是不一样的，目标程序与体系结构相关，但仍不是计算机硬件能够直接执行的程序。另一种是<strong>解释程序</strong>，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以<strong>解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序</strong>。</li>
<li>汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。<span style="color:red">汇编语言是面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。</span></li>
<li>编译程序与汇编程序的区別：若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</li>
</ul>
<h5 id="4、不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"><a href="#4、不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？" class="headerlink" title="4、不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"></a>4、不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</h5><ul>
<li>机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。</li>
<li>其中机器语言可以被硬件直接执行。</li>
</ul>
<h4 id="1-5-常见问题和易混淆知识点"><a href="#1-5-常见问题和易混淆知识点" class="headerlink" title="1.5 常见问题和易混淆知识点"></a>1.5 常见问题和易混淆知识点</h4><h5 id="1、同一个功能既可以由软件实现又可以由硬件实现吗？"><a href="#1、同一个功能既可以由软件实现又可以由硬件实现吗？" class="headerlink" title="1、同一个功能既可以由软件实现又可以由硬件实现吗？"></a>1、同一个功能既可以由软件实现又可以由硬件实现吗？</h5><ul>
<li>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础；软件是一种信息，看不见、摸不到。<span style="color:red"><strong>但在逻辑功能上，软件和硬件是等效的。</strong></span>因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。</li>
<li>一个最大的区别就是，<strong>硬件实现比软件实现的速度快很多，但是成本也高</strong>！所以，芯片在流片之后，如果发现bug可以用软件修复就用软件修复！  </li>
<li>例如，乘法运算既可用专门的乘法器（主要由加法器和移位器组成）实现，也可用乘法子程序（主要由加法指令和移位指令等组成）来实现。</li>
</ul>
<h5 id="2、什么是透明性？透明是指什么都能看见吗？"><a href="#2、什么是透明性？透明是指什么都能看见吗？" class="headerlink" title="2、什么是透明性？透明是指什么都能看见吗？"></a>2、什么是透明性？透明是指什么都能看见吗？</h5><ul>
<li>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即<span style="color:red"><strong>“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”</strong></span>。这与日常生活中的“透明”概念(公开、看得见)正好相反。</li>
<li>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</li>
<li><strong>在CPU中，IR、MAR和MDR对各类程序员都是透明的</strong>。</li>
</ul>
<h5 id="3、机器字长、指令字长、存储字长的区别和联系是什么？"><a href="#3、机器字长、指令字长、存储字长的区别和联系是什么？" class="headerlink" title="3、机器字长、指令字长、存储字长的区别和联系是什么？"></a>3、机器字长、指令字长、存储字长的区别和联系是什么？</h5><ul>
<li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</li>
<li>指令字长：一个指令字中包含的二进制代码的位数。</li>
<li>存储字长：一个存储单元存储的二进制代码的长度。等于MDR的位数， 它们都必须是字节的整数倍。</li>
<li>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</li>
</ul>
<p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p>
<p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p>
<p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p>
<h5 id="4、计算机体系结构和计算机组成的区别和联系是什么？"><a href="#4、计算机体系结构和计算机组成的区别和联系是什么？" class="headerlink" title="4、计算机体系结构和计算机组成的区别和联系是什么？"></a>4、计算机体系结构和计算机组成的区别和联系是什么？</h5><ul>
<li><span style="color:red">计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性</span>，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。</li>
<li><span style="color:red">计算机组成是指如何实现计算机体系结构所体现的属性</span>，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。（简言之，看有没有这个属性，就是结构问题；看怎么实现，就是组成问题）</li>
<li>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如， IBM System&#x2F;370结构就包含了多种价位和性能的机型。</li>
</ul>
<h5 id="5、基准程序执行得越快说明杺器的性能越好吗？"><a href="#5、基准程序执行得越快说明杺器的性能越好吗？" class="headerlink" title="5、基准程序执行得越快说明杺器的性能越好吗？"></a>5、基准程序执行得越快说明杺器的性能越好吗？</h5><p>一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p>
<h3 id="二、数据的表示与运算"><a href="#二、数据的表示与运算" class="headerlink" title="二、数据的表示与运算"></a>二、数据的表示与运算</h3><p>【复习提示】<br>本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和运算方法不同，因此理解也较为困难。纵观近几年的真题，不难发现 unsigned、shot、int、long、foat、 double等在C语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE754浮点数的表示，以及浮点数的运算，都是考研考查的重点，需要牢固掌握。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118085022452.png" alt="在这里插入图片描述"></p>
<h4 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h4><h5 id="2-1-1-进位计数制及其相互转化"><a href="#2-1-1-进位计数制及其相互转化" class="headerlink" title="2.1.1 进位计数制及其相互转化"></a>2.1.1 进位计数制及其相互转化</h5><p>进位计数法</p>
<p>在进位计数法中，每个数位所用到的不同数码的个数称为<strong>基数</strong>。十进制的基数为10，逢十进一。</p>
<ul>
<li>十进制：基数为10，计数“逢十进一”<ul>
<li>数符：0~9</li>
<li>表示：(1652)<del>10</del> 或 1652D</li>
</ul>
</li>
<li>二进制：基数为2的计数制；计数“逢二进一”。<ul>
<li>数符：0、1</li>
<li>表示：(1010001010010)<del>2</del> 或 1010001010010B</li>
</ul>
</li>
<li>八进制。基数为8，计数“逢八进一”。<ul>
<li>数符：0~7</li>
<li>表示：(1652)<del>8</del></li>
</ul>
</li>
<li>十六进制：基数为16，“逢十六进一”。<ul>
<li>数制：0 ~ 9、A、B、C、D、E、F，其中A、B、C、D、E、F分别表示10 ~ 15。</li>
<li>表示：(1652)<del>16</del> 或 1652H 或 0x1652</li>
</ul>
</li>
</ul>
<p>进位计数制总览</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117183943164.png" alt="在这里插入图片描述"></p>
<p>1、任意进制转为十进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117185238778.png" alt="在这里插入图片描述"></p>
<ul>
<li>将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。</li>
</ul>
<p>2、二进制与八进制和十六进制互转 (注意：小数部分也是从右往左算)</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117185618834.png" alt="在这里插入图片描述"></p>
<ul>
<li>二进制转换为八进制：每3个二进制位对应一个八进制位。</li>
<li>二进制转换为十六进制：每4个二进制位对应一个十六进制位。</li>
<li><strong>在转换时以小数点为界，整数部分从右往左数分组，左加零补齐；小数部分从左往右数分组，右加零补齐。</strong></li>
</ul>
<blockquote>
<p>注意：八进制与十六进制转换，需要先转成二进制再转换。</p>
</blockquote>
<p>3、各种进制的常见书写方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117185725631.png" alt="在这里插入图片描述"></p>
<p>4、十进制转为任意进制</p>
<p>基数乘除法：这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对<span style="color:red">整数部分</span>用<strong>除基取余法</strong>，对<span style="color:red">小数部分</span>用<strong>乘基取整法</strong>，<span style="color:red">最后将整数部分与小数部分的转换结果拼接起来</span>。</p>
<ul>
<li>整数部分（<strong>除基取余法</strong>）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（<span style="color:red">即除基取余，先余为低，后余为高</span>），商为0时结束。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117190345649.png" alt="在这里插入图片描述"></p>
<ul>
<li>小数部分（<strong>乘基取整法</strong>）：小数部分乘基取整，<strong>最先取得的整数</strong>为数的<strong>最高位</strong>，最后取得的整数为数的<strong>最低位</strong>（<span style="color:red">即乘基取整，先整为高，后整为低</span>），乘积为1.0（或满足精度要求）时结束。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231118225503771.png" alt="image-20231118225503771"></p>
<blockquote>
<p>注意：在计算机中，小数和整数不一样，整数可以连续表示，但<strong>小数是离散</strong>的，所以并不是每个十进制小数都可以准确地用二进制表示。例如0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个<strong>二进制小数都可以用十进制小数表示</strong>。</p>
</blockquote>
<p>5、十进制转为二进制（拼凑法）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117191021486.png" alt="在这里插入图片描述"></p>
<p>6、真值和机器数</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231121205545783.png" alt="image-20231121205545783"></p>
<ul>
<li><strong>真值</strong>：指用正号、负号来分别表示正数（正号可省略）和负数，是机器数所代表的实际值。</li>
<li><strong>机器数</strong>：<span style="color:red">用“0”表示“正”，用“1”表示“负”</span>；这种把符号“数字化”的数称为机器数。常用的有原码、补码和反码表示法。如0，101（这里的逗号“，”仅为区分符号位与数值位）表示+5。</li>
</ul>
<p><strong>知识回顾与重点考点</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117191955803.png" alt="在这里插入图片描述"></p>
<h5 id="2-1-2-BCD码（Binary-Code-Decimal码）"><a href="#2-1-2-BCD码（Binary-Code-Decimal码）" class="headerlink" title="2.1.2 BCD码（Binary-Code Decimal码）"></a>2.1.2 BCD码（Binary-Code Decimal码）</h5><p><strong>二进制编码的十进制数</strong>（Binary-Coded Decimal，BCD）通常采<strong>用4位二进制数来表示一位十进制数中的0~9这10个数码</strong>。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但4位二进制数可以组合出16种代码，因此必有6种状态为冗余状态。（从1010到1111这6个为无效码）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117193109970.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117193518270.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>余3码：这是一种无权码，是在8421码的基础上加(0011)2形成的，因每个数都多余“3”，因此称为余3码。</p>
<p>如8→1011；9→1100。</p>
</li>
<li><p>2421码：这也是一种有权码，权值由高到低分别为2，4，2，1，特点是大于或等于5的4位二进制数中最高位为1，小于5的最高位为0。</p>
<p>如5→1011而非0101。</p>
</li>
</ul>
<p>知识回顾与重要考点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117193657777.png" alt="在这里插入图片描述"></p>
<h5 id="2-1-3-字符与字符串"><a href="#2-1-3-字符与字符串" class="headerlink" title="2.1.3 字符与字符串"></a>2.1.3 字符与字符串</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231118230328128.png" alt="image-20231118230328128"></p>
<p>1、字符编码ASCII码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117194317905.png" alt="在这里插入图片描述"></p>
<ul>
<li>案例：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117194843132.png" alt="在这里插入图片描述"></p>
<ul>
<li>汉字的表示和编码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117200407446.png" alt="在这里插入图片描述"></p>
<p>2、字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231118230649147.png" alt="image-20231118230649147"></p>
<ul>
<li>大端模式和小端模式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117195936696.png" alt="在这里插入图片描述"></p>
<p>3、知识回顾与重要考点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117200115324.png" alt="在这里插入图片描述"></p>
<h5 id="2-1-4-校验码"><a href="#2-1-4-校验码" class="headerlink" title="2.1.4 校验码"></a>2.1.4 校验码</h5><p><strong>任意两个码字之间最少变化的二进制位数称为码距</strong>，<strong>码距大于等于2的数据校验码开始具有检错的能力</strong>。<span style="color:red">码距越大，检错、纠错能力越强</span>。<strong>奇偶校验码的码距等于2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误</strong>；<span style="color:red">海明码的码距大于2，因此不仅可以发现错误，还能指出错误的位置</span>。仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距。</p>
<blockquote>
<p>具有检、纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117201426544.png" alt="在这里插入图片描述"></p>
<p>1、奇偶校验码<br>原编码上加一个校验位，码距等于2！</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231118231234304.png" alt="image-20231118231234304"></p>
<ul>
<li>案例：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117202320100.png" alt="在这里插入图片描述"></p>
<ul>
<li>知识回顾与重要考点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210117202609126.png" alt="在这里插入图片描述"></p>
<p>2、海明（汉明）校验码</p>
<ul>
<li>思路简介</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118080256138.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118080501589.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>求解步骤</p>
<ul>
<li>步骤一</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118081711303.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤二</li>
</ul>
<p>	</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118081852709.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤三</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118081938619.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤四</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011808201964.png" alt="在这里插入图片描述"></p>
</li>
<li><p>知识回顾与重要考点</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118082050560.png" alt="在这里插入图片描述"></p>
<p>3、循环冗余校验（CRC）码</p>
<ul>
<li>基本思想</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011808234085.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>求解步骤</p>
<ul>
<li>步骤一</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118084534498.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤二</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118082908894.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤三</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118083019225.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤四</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118083336843.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>步骤五</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118083714247.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>CRC校验码是可以纠错的，前面这个是因为信息位太长</strong></li>
</ul>
</li>
<li><p>步骤六</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118084033953.png" alt="在这里插入图片描述"></p>
</li>
<li><p>知识回顾与重要考点</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118084104650.png" alt="在这里插入图片描述"></p>
<h4 id="2-2-定点数的表示和运算"><a href="#2-2-定点数的表示和运算" class="headerlink" title="2.2 定点数的表示和运算"></a>2.2 定点数的表示和运算</h4><h5 id="1、定点数和浮点数的概念"><a href="#1、定点数和浮点数的概念" class="headerlink" title="1、定点数和浮点数的概念"></a>1、定点数和浮点数的概念</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231121210208752.png" alt="image-20231121210208752"></p>
<p>机器数的定点表示：</p>
<p>定点表示法用来表示定点小数和定点整数。<strong>符号位为0表示正数，符号位为1表示负数。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/f8e590c701f2e28fed3a4486a9d88e68.png" alt="image-20230823145229922"></p>
<ul>
<li>定点小数：小数点在符号位之后，有效数值部分最高位之前。<ul>
<li>当x<del>0</del> &#x3D; 0，x<del>1</del> ~ x<del>n</del>，均为1时，X为其所能表示的最大正数，真值等于 1-2^-n^；</li>
<li>当x<del>0</del> &#x3D; 1，x<del>1</del> ~ x<del>n</del>，均为1时，X为其（原码）所能表示的最小负数，真值等于-(1-2^-n^)</li>
</ul>
</li>
<li>定点整数：小数点在有效数值部分最低位之后。<ul>
<li>当x<del>0</del> &#x3D; 0，x<del>1</del> ~ x<del>n</del>，均为1时，X为其所能表示的最大正数，真值等于2^n^-1；</li>
<li>当x<del>0</del> &#x3D; 1，x<del>1</del> ~ x<del>n</del>，均为1时，X为其（原码）所能表示的最小负数，真值等于-(2^n^-1)</li>
</ul>
</li>
</ul>
<h5 id="2、无符号数"><a href="#2、无符号数" class="headerlink" title="2、无符号数"></a>2、无符号数</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/73817f209a92e820eef643db4c867011.png" alt="image-20220127144714178"></p>
<ul>
<li><p>无符号整数的表示</p>
<p>整个机器字长全部二进制位均为数值位，机器字长n位数的表示范围0 ~ 2^n^-1。</p>
</li>
<li><p>带符号整数的表示</p>
<p>最高位为符号位，0正1负。计算机中带符号数用补码表示，n位带符号数取值范围是-2^n-1^ ~ 2^n-1^-1。</p>
</li>
</ul>
<h5 id="3、原码"><a href="#3、原码" class="headerlink" title="3、原码"></a>3、原码</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/59fb3a03fc275ce5e5333a30d769fa0c.png" alt="image-20220127145309171"></p>
<p>用机器数的最高位表示数的符号，其余各位表示数的绝对值。</p>
<ul>
<li><strong>纯整数的原码定义</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e6ad9bfa3d59f0007ab6fa6b47616ddf.png" alt="image-20230823150309144"></p>
<p>​	若字长为n+1，则原码整数的表示范围为-(2^n^-1)≤x≤2^n^-1（关于原点对称）</p>
<blockquote>
<p>例如，若x1&#x3D;+1110，x2&#x3D;-1110，字长为8位，则其原码表示为[x1]<del>原</del>&#x3D;0,0001110，[x2]<del>原</del>&#x3D;2^7^+1110&#x3D;1,0001110，其中最高位是符号位。</p>
</blockquote>
<ul>
<li><strong>纯小数的原码定义</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/39df7595ed04efcb519760a05f0cb0e4.png" alt="image-20230823150505289"></p>
<p>​	若字长为n+1，则原码小数的表示范围为-(1-2^-n^)≤x≤1-2^-n^（关于原点对称）</p>
<blockquote>
<p>例如，若x1&#x3D;+0.1101，x2&#x3D;-0.1101，字长为8位，则其原码表示为[x1]<del>原</del>&#x3D;0.1101000，[x2]<del>原</del>&#x3D;1-(-0.1101)&#x3D;1.1101000，其中最高位是符号位。</p>
</blockquote>
<p>原码表示的<strong>优点</strong>是与真值的对应关系简单、直观，与真值的转换简单，并且用原码实现乘除运算比较简便。<strong>缺点</strong>是，<strong>0的表示不唯一</strong>，更重要的是原码<strong>加减运算比较复杂</strong>。</p>
<h5 id="4、反码"><a href="#4、反码" class="headerlink" title="4、反码"></a>4、反码</h5><p>正数与原码相同；负数与原码相比，符号位不变，数值位按位取反。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/77c9db0581910657f44d1964ed07c331.png" alt="image-20220127145448551"></p>
<p>反码表示存在以下几个方面的不足：<strong>0的表示不唯一（即存在正负0）</strong>；表示范围比补码少个最小负数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。</p>
<h5 id="5、补码"><a href="#5、补码" class="headerlink" title="5、补码"></a>5、补码</h5><p>正数与原码相同；<strong>负数</strong>与原码相比，符号位不变，<strong>数值位按位取反再加1</strong>。</p>
<p>&#x3D;&#x3D;负数手算：从右往左找到第一个1，这个1左边的所有“数值位”按位取反。&#x3D;&#x3D;</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/5daed5d8076559abc4a911fd285b9277.png" alt="image-20220127150050213"></p>
<ul>
<li><p>补码定义</p>
<ul>
<li>纯整数的补码定义：若字长为n+1，则补码的表示范围为-2^n^≤x≤2^n^-1（比原码多表示-2^n^）。</li>
</ul>
<blockquote>
<p>例如，若x1&#x3D;+1010，x2&#x3D;-1101，字长为8位，则其补码表示为[x1]<del>补</del>&#x3D;0,0001010，[x2]<del>补</del>&#x3D;2^8^-0,0001101&#x3D;1,1110011。</p>
<p>8位字长，<strong>原码取值范围是-127 ~ +127（1111 1111 ~ 0111 1111）</strong>；</p>
<p><strong>补码取值范围是-128 ~ +127（1000 0000 ~ 0111 1111）</strong>，(-128)<del>10</del>&#x3D;(1000 0000)<del>2</del></p>
</blockquote>
<ul>
<li>纯小数的补码定义：若字长为n+1，则补码的表示范围为-1≤x≤1-2^-n^（比原码多表示-1）。</li>
</ul>
<blockquote>
<p>例如，若x1&#x3D;+0.1001，x2&#x3D;-0.0110，字长为8位，则其补码表示为[x1]<del>补</del>&#x3D;0.1001000，[x2]<del>补</del>&#x3D;2-0.0110&#x3D;1.1010000。</p>
<p>其中(-1)<del>10</del>&#x3D;(1000 0000)<del>2</del></p>
</blockquote>
<p>注意：<strong>零的补码表示是唯一的</strong>，即[+0]&#x3D;[-0]&#x3D;0.0000。由定义[-1]&#x3D;1.0000，可见，小数补码比原码多表示一个”-1”；整数补码比原码多表示一个”-2^n^”。</p>
</li>
<li><p>技巧</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/77565155a6ba1ab85593bb2ce70c38e0.png" alt="image-20220127150633042"></p>
<ul>
<li>补码的作用 （注意：执行加法运算时，符号位一起参加运算）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/56d1878a71fe4999ffbdb3349235e41f.png" alt="image-20220127152758634"></p>
<ul>
<li><p>变形补码</p>
<ul>
<li>变形补码，又称模4补码，<strong>双符号位</strong>的<strong>补码小数</strong>，其定义为</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e944ce17e114fe973c12866d7f7af4d1.png" alt="image-20230823155444066"></p>
<p>模4补码双符号位<strong>00表示正</strong>，<strong>11表示负</strong>，用在完成算术运算的ALU部件中。</p>
<p>将[x]<del>补</del>的<strong>符号位与数值位一起右移</strong>并保持原符号位的值不变，可实现除法功能。</p>
<blockquote>
<p>模4补码的优点是可以在运算结果的符号位上直接判断<strong>是否发生溢出</strong>。</p>
<p>1）如果两个正数相加之和大于等于1，则符号位为01，表示正数上溢；</p>
<p>2）如果两个负数相加，而其和小于-1，则符号位为10，表示负数下溢。</p>
</blockquote>
<ul>
<li><p>补码与真值之间的转换</p>
<p>对补码而言，正数和负数的转换不同。正数补码的转换方式与原码的相同。</p>
<ul>
<li><strong>真值转换为补码：对于正数，与原码的方式一样。对于负数，符号位取1，其余各位由真值“各位取反，末位加1”得到。</strong></li>
<li><strong>补码转换为真值：若符号位为0，与原码的方式一样。若符号位为1，真值的符号为负，数值部分各位由补码“各位取反，末位加1”得到。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6、移码"><a href="#6、移码" class="headerlink" title="6、移码"></a>6、移码</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/a59cc0ea2e5bdb5b7eefbabf10825f1d.png" alt="image-20220127150230867"></p>
<p>移码常用来表示浮点数的阶码。它<strong>只能表示整数</strong>。</p>
<p>移码就是在真值X上加上一个<strong>偏置值</strong>，通常这个常数取2^n^，相当于X在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。移码定义为：[<em>x</em>]<del>移</del>&#x3D;2^n^+x（−2^n^≤x&lt;2^n^，其中机器字长为n+1）</p>
<blockquote>
<p>例如，若正数x1&#x3D;+10101，x2&#x3D;-10101，字长为8位，则其移码表示为[x1]<del>移</del>&#x3D;2^7^+10101&#x3D;1,0010101；[x2]<del>移</del>&#x3D;2^7^+（-10101）&#x3D;0,1101011。</p>
</blockquote>
<p><strong>移码特点</strong>：</p>
<ul>
<li>移码中零的表示唯一，[+0]&#x3D;[-0]&#x3D;2^n^&#x3D;1000 0000</li>
<li>一个真值的移码和补码仅差一个符号位；即补码符号位取反得到移码。</li>
<li>移码全0时，对应真值的最小值-2^n^；移码全1时，对应真值的最大值2^n^-1。</li>
<li>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。</li>
</ul>
<h5 id="7、原码、补码、反码和移码这4种编码表示的总结"><a href="#7、原码、补码、反码和移码这4种编码表示的总结" class="headerlink" title="7、原码、补码、反码和移码这4种编码表示的总结"></a>7、原码、补码、反码和移码这4种编码表示的总结</h5><ul>
<li><p>原码、补码、反码的符号位相同，正数的机器码相同。</p>
</li>
<li><p>原码、反码的表示在数轴上对称，二者都存在+0和-0两个零。</p>
</li>
<li><p>补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。</p>
</li>
<li><p>整数的补码、移码的符号位相反，数值位相同。</p>
</li>
<li><p>负数的反码、补码末位相差1。</p>
</li>
<li><p>原码很容易判断大小。而负数的反码、补码很难直接判断大小，</p>
<p>可采用如下规则快速判断：对于负数，数值部分越大，绝对值越小，真值越大（更靠近0）。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231122223929138.png" alt="image-20231122223929138"></p>
<h5 id="8、定点数的移位运算"><a href="#8、定点数的移位运算" class="headerlink" title="8、定点数的移位运算"></a>8、定点数的移位运算</h5><ul>
<li>原码的算数移位</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/feba8c10befb09b3bcc1f255901a2852.png" alt="image-20220127153359639"></p>
<ul>
<li>反码的算数移位</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/029151dcfd30f6b1a83d6e136ec7fae9.png" alt="image-20220127153607298"></p>
<ul>
<li>补码的算数移位</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/b0dfd4611c62cb16cc8fcbb317cc0870.png" alt="image-20220127153830245"></p>
<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/ce062992ae7eb7f207f1da23725ed586.png" alt="image-20220127153942017"></p>
<ul>
<li>逻辑移位</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e46c366d0e8fa27d54b932da55f96f34.png" alt="image-20220127154131912"></p>
<ul>
<li>循环移位</li>
</ul>
<p>循环移位分为带进位标志位CF的循环移位（<strong>大循环</strong>）和不带进位标志位的循环移位（<strong>小循环</strong>）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/9e76c47e534140780cad175c4860420e.png" alt="image-20230823173023119"></p>
<p>循环移位操作特别适合将数据的低字节数据和高字节数据互换。</p>
<h5 id="9、溢出判断"><a href="#9、溢出判断" class="headerlink" title="9、溢出判断"></a>9、溢出判断</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d0bc7fc767a3def6f90c47c48e51e4ef.png" alt="image-20220127161103371"></p>
<p>仅当两个<strong>符号相同的数相加</strong>或两个<strong>符号相异的数相减</strong>才可能产生溢出，如两个正数相加，而结果的符号位却为1（结果为负）；一个负数减去一个正数，结果的符号位却为0（结果为正）。</p>
<ul>
<li><p>采用一位符号位</p>
<ul>
<li>只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。</li>
<li>采用一位符号位，根据数据位进位情况判断溢出。</li>
<li>若符号位的进位C<del>s</del>与最高数位的进位C<del>1</del>相同，则说明没有溢出，否则表示发生溢出。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/8113d81b1eedfd6b32f7cec0ade6994b.png" alt="image-20230823174726840"></p>
</li>
<li><p>采用双符号位（模4补码）</p>
<ul>
<li>运算结果的两个符号位S<del>s1</del>S<del>s2</del>相同，表示未溢出；运算结果的两个符号位S<del>s1</del>S<del>s2</del>不同，表示溢出，此时最高位符号位代表真正的符号。</li>
</ul>
</li>
</ul>
<h5 id="10、符号扩展"><a href="#10、符号扩展" class="headerlink" title="10、符号扩展"></a>10、符号扩展</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/243c3922ffd4f1eb2ced2c14d12a31fd.png" alt="image-20220127161325545"></p>
<p>定点数表示的数转换成具有不同位数的某种表示形式。其根本目的是：表示的数值保持不变。</p>
<ul>
<li>对于正数：新表示形式的所有附加位都用0进行填充。</li>
<li>对于负数：<ul>
<li>符号位保持不变，原码的所有附加位都用0进行填充；</li>
<li>符号位保持不变，反码的所有附加位都用1进行填充；</li>
<li>符号位保持不变，补码的所有附加位都用1（对于整数）或0（对于小数）进行填充。</li>
</ul>
</li>
</ul>
<h4 id="2-3-浮点数的表示与运算"><a href="#2-3-浮点数的表示与运算" class="headerlink" title="2.3 浮点数的表示与运算"></a>2.3 浮点数的表示与运算</h4><h5 id="1、浮点数的表示"><a href="#1、浮点数的表示" class="headerlink" title="1、浮点数的表示"></a>1、浮点数的表示</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/3f004271ffb074d29a89097f7f692c19.png" alt="image-20220128144507292"></p>
<h5 id="2、尾数的规格化"><a href="#2、尾数的规格化" class="headerlink" title="2、尾数的规格化"></a>2、尾数的规格化</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/beda3a665f18598df6efd691863b7123.png" alt="image-20220128144600960"></p>
<ul>
<li>特点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231121212229568.png" alt="image-20231121212229568"></p>
<h5 id="3、IEEE-754-浮点数标准"><a href="#3、IEEE-754-浮点数标准" class="headerlink" title="3、IEEE 754 浮点数标准"></a>3、IEEE 754 浮点数标准</h5><ul>
<li>标准</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d7dab764cc8be22585efb3eea2b3d638.png" alt="image-20220128145831536"></p>
<ul>
<li>示例（十进制转换为浮点数）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e5715df560c9d84606aec8d7d16c3a50.png" alt="image-20220128150220191"></p>
<ul>
<li>示例（浮点数转换为十进制数）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/1571af1358f0063996617047dc45e43b.png" alt="image-20220128150436743"></p>
<ul>
<li>单精度浮点数表示的最大值，最小值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/99a90a5c0aeb7cfae67effd64b7185b1.png" alt="image-20220128150646292"></p>
<ul>
<li>特殊数值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/83c20f87d1edcf4162cc3b9c04575c53.png" alt="image-20220128151026706"></p>
<h5 id="4、浮点数的表示与运算"><a href="#4、浮点数的表示与运算" class="headerlink" title="4、浮点数的表示与运算"></a>4、浮点数的表示与运算</h5><p>1、浮点数的表示格式：<strong>N &#x3D; (−1)<em>^S^</em> × M × R^E^</strong></p>
<ul>
<li><strong>数符S</strong>取值0或1，用来决定浮点数的符号</li>
<li><strong>尾数M</strong>是一个二进制定点小数，一般用定点原码小数表示</li>
<li><strong>阶数E</strong>是一个二进制定点整数，又称指数，用移码表示</li>
<li><strong>基数R</strong>是隐含的，可以约定为2、4、8、16等</li>
<li>例如：32位浮点数格式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/281eb501e61e26e5a4df3530c54b3f6d.png" alt="image-20230824131917879"></p>
<blockquote>
<p>其中，第0位为<strong>数符S</strong>；第1 ~ 7位为移码表示的<strong>阶码E</strong>（偏置值为64）；第8 ~ 31位为24位二进制原码小数表示的<strong>尾数M</strong>；<strong>基数R</strong>为2。</p>
</blockquote>
<ul>
<li><strong>阶码的值</strong>反映浮点数的<strong>小数点</strong>的实际位置;</li>
<li><strong>阶码的位数</strong>反映<strong>浮点数的表示范围</strong>;</li>
<li><strong>尾数</strong>的位数反映<strong>浮点数的精度</strong>。</li>
</ul>
<p>2、浮点数的表示范围</p>
<p>原码是关于原点对称的，故浮点数的范围也是关于原点对称的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/a611767016ec4886963acd85522edbce.png" alt="image-20230824133908992"></p>
<ul>
<li>上溢：运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。</li>
<li>下溢：当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机仅将其当作机器零处理。</li>
</ul>
<p>3、浮点数的规格化</p>
<p>尾数的位数决定浮点数的有效数位，有效数位越多，数据的精度越高。</p>
<p><strong>规格化操作</strong>：是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的<strong>最高数位上保证是一个有效值</strong>。</p>
<ul>
<li>左规：当运算结果的尾数的最高数位不是有效位，即出现<code>±0.0…0×…×</code>的形式时，需要进行左规。<strong>左规时，尾数每左移一位、阶码减1（基数为2时）</strong>。左规可能要进行多次。</li>
<li>右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规。<strong>将尾数右移一位、阶码加1（基数为2时）</strong>。需要右规时，只需进行一次。</li>
</ul>
<p>规格化浮点数的尾数M的绝对值应满足<code>1/R ≤ ∣M∣＜1</code>。若R&#x3D;2，则有<code>1/2 ≤ ∣M∣＜1</code>。</p>
<p>原码表示的规格化尾数的形式如下：</p>
<ul>
<li>正数最大值为0.11…1，最小值为0.10…0。尾数表示范围为 **1&#x2F;2 ≤ |M|≤ (1-2^-n^)**。</li>
<li>负数最大值为1.10…0，最小值为1.11…1。尾数表示范围为 <strong>-(1-2^-n^) ≤ M ≤ -1&#x2F;2</strong> 。</li>
</ul>
<p>补码表示的尾数规格化：尾数最高数值位必须和尾数符号位相反。</p>
<p>4、IEEE754标准</p>
<ul>
<li>按照IEEE754标准，常用的浮点数的格式如图所示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/c44d294f324451d42a29cf63121fc839.png" alt="image-20230824135859718"></p>
<ul>
<li>IEEE754偏置值，如下表所示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/0a67d2b02d879d4cb7b41b35ea151577.png" alt="image-20230824140917708"></p>
<p>偏置值指阶码部分，以移码表示时的偏置值，也就是表示为0的值。<strong>阶码值&#x3D;阶码的原码值-偏置值</strong>。</p>
<p>尾数默认规格化二进制浮点数，隐藏最高位为1，称为<strong>隐藏位</strong>。</p>
<blockquote>
<p>例如，(12)<del>10</del>&#x3D;(1100)<del>2</del>，将它规格化后结果位1.1×2^3^，其中整数部分的1将不存储与尾数。</p>
<p>因此，用IEEE754方式表示12，阶码&#x3D;3，用移码表示为127+3&#x3D;130&#x3D;(1000 0010)<del>2</del>；尾数为.1。</p>
<p>用IEEE754表示为0<u>100 0001 0</u>100 0000 … 0000即41 40 00 00 H 。</p>
</blockquote>
<ul>
<li>IEEE754标准中，规格化的<ul>
<li><strong>短浮点数的真值</strong>为 <strong>(−1)^S^ × 1.M × 2^E−127^</strong></li>
<li><strong>长浮点数的真值</strong>为 <strong>(−1)^S^ × 1.M × 2^E−1023^</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>式中：</p>
<p>短浮点数E的取值为1 ~ 254（8位表示），M为23位，共32位；</p>
<p>长浮点数E的取值为1 ~ 2046（11位表示），M为52位，共64位。</p>
</blockquote>
<p>5、<strong>IEEE754浮点数范围</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231123204809412.png" alt="image-20231123204809412"></p>
<p>​	对于IEEE 754格式的浮点数，阶码全0或全1时，有其特别的解释</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/50518e330b41f483c0d82dafc273a54a.png" alt="image-20230824144249486"></p>
<ul>
<li>全0阶码全0尾数：+0&#x2F;-0。零的符号取决于数符S，一般情况下+0和-0是等效的。</li>
<li>全1阶码全0尾数：+∞&#x2F;-∞。+∞在数值上大于所有有限数，-∞则小于所有有限数。</li>
<li>全0阶码不全0尾数，表示非规格化小数。</li>
<li>全1阶码不全0尾数，表示非数值NaN（Not a Number）。</li>
</ul>
<p>例题：1）IEEE754格式转换为十进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/4b076f9e751d8e3746b917ac1f9a7f81.png" alt="image-20230824145032472"></p>
<p>例题：2）十进制转换为IEEE754格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/98e5bef34d400475438c5ce66ad1d923.png" alt="image-20230824145135545"></p>
<p>6、定点、浮点表示的区别</p>
<ul>
<li><p>1）数值的表示范围</p>
<p><strong>若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法。</strong></p>
</li>
<li><p>2）精度</p>
<p>对于字长相同的定点数和浮点数来说，<strong>浮点数虽然扩大了数的表示范围，但精度降低了。</strong></p>
</li>
<li><p>3）数的运算</p>
<p>浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，面且运算结果要求规格化，所以浮点运算比定点运算复杂。</p>
</li>
<li><p>4）溢出问题</p>
<p>在定点运算中，当运算结果超出数的表示范围时，发生溢出：<strong>浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出</strong>。</p>
</li>
</ul>
<p>7、浮点数的加减运算</p>
<p>浮点数运算的特点是阶码运算和尾数运算分开进行。</p>
<p>1）浮点数加减运算步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/1cbece81e03f93d69e2b7b0643192608.png" alt="image-20220128152136960"></p>
<ul>
<li><p>1）对阶</p>
<ul>
<li>对阶的目的是<strong>使两个操作数的小数点位置对齐</strong>，即使得<strong>两个数的阶码相等</strong>。</li>
<li>为此，先求阶差然后以<strong>小阶向大阶看齐</strong>的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的<strong>阶码相等</strong>为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。</li>
</ul>
</li>
<li><p>2）尾数求和</p>
<ul>
<li>将对阶后的尾数按定点数加（减）运算规则运算。运算后的<strong>尾数不一定是规格化</strong>的，因此，浮点数的加减运算需要进一步<strong>进行规格化处理</strong>。</li>
</ul>
</li>
<li><p>3）规格化</p>
<p>   IEEE754规格化尾数的形式为<code>±1.×…×</code>。尾数相加减后会得到各种可能结果，例如：</p>
<ul>
<li>1.×…× + 1.×…× &#x3D; ±1×.×…× 			 ①</li>
<li>1.×…× − 1.×…× &#x3D; ±0.0…01×…×       ②</li>
<li>右归：当结果如①时，进行右归。尾数右移一位，阶码加1。尾数右移时，最高位1被移到小数点前一位作为隐藏位，最后一位移除时，考虑舍入。</li>
<li>左归：当结果如②时，进行左归。尾数每左移一位，阶码减1。可能需要左规多次，直到将第一位1移到小数点左边。</li>
</ul>
<blockquote>
<p><strong>左规一次相当于乘2，右规一次相当于除2；需要右规时，只需进行一次。</strong></p>
</blockquote>
</li>
<li><p>4）舍入</p>
<p>在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般<strong>将低位移出的两位保留下来</strong>，参加中间过程的运算，最后将运算结果进行舍入，还原表示成IEEE754格式。</p>
<ul>
<li>0舍1入法：类似于十进制的“四舍五入”法。运算结果保留位的最高数位为0，则舍去；最高数位为1，则在尾数的末位加1。这样可能会使尾数溢出，此时需再做一次右规。</li>
<li>恒置1法：不论丢掉的最高数位是0还是1，都把右移后的尾数末位恒置1。</li>
<li>截断法：直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/f80c7a91e8efe65cbcf6d055b96c6e7c.png" alt="image-20220128155152407"></p>
</li>
<li><p>5）溢出判断</p>
<p>在尾数规格化和尾数舍入时，可能会对阶码执行加&#x2F;减运算。因此，必须考虑指数溢出的问题。</p>
<ul>
<li><p><strong>指数上溢</strong>：若一个正指数超过了最大允许值(127或1023)，则发生指数上溢，<strong>产生异常</strong>。</p>
<ul>
<li>右规和尾数舍入。数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶。右规时阶加1，导致阶增大，因此需要判断是否发生了指数上溢。当调整前的阶码为11111110时，加1后，会变成11111111而发生指数上溢。</li>
</ul>
</li>
<li><p><strong>指数下溢</strong>：若一个负指数超过了最小允许值(-126或-1022)，则发生指数下溢，通常把结果按<strong>机器零处理</strong>。</p>
<ul>
<li>左规。左规时阶减1，导致阶减小，因此需要判断是否发生了指数下溢。其判断规则与指数上溢类似，左规一次，阶码减1，然后判断阶码是否为全0来确定是否指数下溢。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2）例题</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/7d6dde27997a8eecb1da0bb355d926ac.png" alt="image-20220128154425894"></p>
<p>3）强制类型转换</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/e4d37e1734a0490dac5242ee752764e2.png" alt="image-20220128155130204"></p>
<ul>
<li>无损：char-&gt;int-&gt;long-&gt;double；float-&gt;double<ul>
<li>范围、精度从小到大，转换过程没有损失</li>
</ul>
</li>
<li>有损：<ul>
<li>int-&gt;float：可能会损失精度（float尾数的数值位有1隐藏位+23尾数位）</li>
<li>float-&gt;int：可能会溢出，也可能会损失精度（如小数转整数）</li>
</ul>
</li>
</ul>
<h5 id="5、电路的基本原理"><a href="#5、电路的基本原理" class="headerlink" title="5、电路的基本原理"></a>5、电路的基本原理</h5><ul>
<li>存储器芯片的基本结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/423b74ad7e7e08968578560d6bd96d31.png" alt="image-20220130152344905"></p>
<ul>
<li>寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/003d51260e7bad7114d37b17f5c9ee21.png" alt="image-20220130153001312"></p>
<h4 id="2-4-算数逻辑单元（ALU）"><a href="#2-4-算数逻辑单元（ALU）" class="headerlink" title="2.4 算数逻辑单元（ALU）"></a>2.4 算数逻辑单元（ALU）</h4><h5 id="1、原码乘法运算"><a href="#1、原码乘法运算" class="headerlink" title="1、原码乘法运算"></a>1、原码乘法运算</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/78a6d46b6cfb08d73fbfaac0760f10d5.png" alt="image-20220127163743939"></p>
<h5 id="2、补码乘法运算"><a href="#2、补码乘法运算" class="headerlink" title="2、补码乘法运算"></a>2、补码乘法运算</h5><ul>
<li>机器实现</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/9725aaa09c3de568822601e510897875.png" alt="image-20220127215747197"></p>
<ul>
<li>手算步骤</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/281c62665c158815b5262af7436e8d6d.png" alt="image-20220127215810158"></p>
<h5 id="3、原码除法运算"><a href="#3、原码除法运算" class="headerlink" title="3、原码除法运算"></a>3、原码除法运算</h5><ul>
<li>机器运算过程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/ded52c58ba10c98b23733febae1b3619.png" alt="image-20220128125621231"></p>
<ul>
<li>恢复余数法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/83b84c96e274adbb91a6e1a7cf57bfef.png" alt="image-20220128131154037"></p>
<ul>
<li>加减交替法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/ef636573ba7e44f3a8f2329004a56c5c.png" alt="image-20220128131225276"></p>
<h5 id="4、补码除法运算"><a href="#4、补码除法运算" class="headerlink" title="4、补码除法运算"></a>4、补码除法运算</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/89e42a4e83a55d0c93db4cffd827a76e.png" alt="image-20220128130246826"></p>
<h5 id="5、强制类型转换"><a href="#5、强制类型转换" class="headerlink" title="5、强制类型转换"></a>5、强制类型转换</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/fe4e9e607725a012bf889eac83020997.png" alt="image-20220128131830289"></p>
<ul>
<li>有符号数和无符号数的转换<ul>
<li>转换只改变数值，而两个变量对应的每位都是一样的。</li>
</ul>
</li>
<li>不同字长整数之间的转换<ul>
<li>长整数变短整数：高位截断，保留低位。</li>
<li>短整数变长整数：符号扩展。</li>
</ul>
</li>
</ul>
<h5 id="6、数据的存储和排列"><a href="#6、数据的存储和排列" class="headerlink" title="6、数据的存储和排列"></a>6、数据的存储和排列</h5><p>1）大端方式和小端方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/70c30e4e6eba63bca5aaca0ed620175e.png" alt="image-20220128132209812"></p>
<p>通常用<strong>最低有效字节（LSB）</strong>和<strong>最高有效字节（MSB）</strong>来分别表示数的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为01234567H，其最高有效字节MSB&#x3D;01H，最低有效字节LSB&#x3D;67H。</p>
<ul>
<li><p><strong>大端方式</strong>按从<strong>最高有效字节</strong>到<strong>最低有效字节</strong>的顺序存储数据，即最高有效字节存放在前面</p>
</li>
<li><p><strong>小端方式</strong>按从<strong>最低有效字节</strong>到<strong>最高有效字节</strong>的顺序存储数据，即最低有效字节存放在前面</p>
</li>
</ul>
<p>2）边界对齐方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/383ef119b26cce46beb66b29f3e64bc7.png" alt="image-20220128141621511"></p>
<p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，<strong>半字地址一定是2的整数倍</strong>，<strong>字地址一定是4的整数倍</strong>，这样无论所取的数据是字节、半字还是字，均可一次访存取出。</p>
<p><strong>边界对齐方式</strong>相对边界不对齐方式是一种<strong>空间换时间的思想</strong>。精简指令系统计算机RISC通常采用边界对齐方式，因为对齐方式取指令时间相同，因此能适应指令流水。</p>
<h4 id="2-5-本章提出的问题与回答"><a href="#2-5-本章提出的问题与回答" class="headerlink" title="2.5 本章提出的问题与回答"></a>2.5 本章提出的问题与回答</h4><h5 id="1、在计算机中，为什么要采用二进制来表示数据？"><a href="#1、在计算机中，为什么要采用二进制来表示数据？" class="headerlink" title="1、在计算机中，为什么要采用二进制来表示数据？"></a>1、在计算机中，为什么要采用二进制来表示数据？</h5><ul>
<li>从可行性来说，<span style="color:red">采用二进制，只有0和1两个状态，能够表示0、1两种状态的电子器件很多</span>，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示0、1两个数码。使用二进制，电子器件具有实现的可行性。</li>
<li>从运算的简易性来说，<span style="color:red">二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化</span>(十进制的乘法九九口诀表有55条公式，而二进制乘法只有4条规则)从逻辑上来说，由于二进制0和1正好和逻辑代数的假( false)和真(true)相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。</li>
</ul>
<h5 id="2、计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"><a href="#2、计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。" class="headerlink" title="2、计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"></a>2、计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</h5><p>计算机采用二进制来表示数据，在字长足够时，<span style="color:red">可以表示任何一个整数</span>。而二进制表示小数时只能够用1(2)的和的任意组合表示，即使字长很长，也<span style="color:red">不可能精确表示出所有小数</span>，只能无限逼近。<strong>例如0.1就无法用二进制精确地表示</strong>。</p>
<h5 id="3、字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"><a href="#3、字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？" class="headerlink" title="3、字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"></a>3、字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</h5><p>字长相同时，<span style="color:red">浮点数取字长的一部分作为阶码，所以表示范围比定点数要大</span>，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而<span style="color:red">定点数</span>字长的全部位都用来表示数值本身，<span style="color:red">精度</span>要比同字长的浮点数<span style="color:red">更大</span>。</p>
<h5 id="4、用移码表示浮点数的阶码有什么好处？"><a href="#4、用移码表示浮点数的阶码有什么好处？" class="headerlink" title="4、用移码表示浮点数的阶码有什么好处？"></a>4、用移码表示浮点数的阶码有什么好处？</h5><p>移码的两个好处：</p>
<ul>
<li>①<strong>浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，移码比较大小更方便。</strong></li>
<li>②检验移码的特殊值(0和max)时比较容易。阶码以移码编码时的特殊值如下。<strong>0:表示指数为负无穷大</strong>，相当于分数分母无穷大，整个数无穷接近0,在尾数也为0时可用来表示0:尾数不为零表示未正规化的数。<strong>max:表示指数正无穷大</strong>，若尾数为0,则表示浮点数超出表示范围（正负无穷大）；尾数不为0,则表示浮点数运算错误。</li>
</ul>
<h4 id="2-6-常见问题和易混淆知识点"><a href="#2-6-常见问题和易混淆知识点" class="headerlink" title="2.6 常见问题和易混淆知识点"></a>2.6 常见问题和易混淆知识点</h4><h5 id="1、如何表示一个数值数据？计算机中的数値数据都是二进制数吗？"><a href="#1、如何表示一个数值数据？计算机中的数値数据都是二进制数吗？" class="headerlink" title="1、如何表示一个数值数据？计算机中的数値数据都是二进制数吗？"></a>1、如何表示一个数值数据？计算机中的数値数据都是二进制数吗？</h5><p>在计算机内部，数值数据的表示方法有以下两大类。</p>
<ul>
<li>①直接用二进制数表示。分为无符号数和有符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）；定点数用来表示整数；浮点数用来表示实数。</li>
<li>②二进制编码的十进制数，一般都采用8421码(也称NBCD码)来表示，用来表示整数。</li>
</ul>
<p>所以，<strong>计算机中的数值数据虽然都用二进制来编码表示，但不全是二进制数，也有用十进制数表示的</strong>。后面一章有关指令类型的内容中，就有对应的二进制加法指令和十进制加法指令。</p>
<h5 id="2、在高级语言编程中所定义的-unsigned-x2F-short-x2F-int-x2F-long-x2F-float-x2F-double型数据是怎么表示的？什么称为无符号整数的“溢出”？"><a href="#2、在高级语言编程中所定义的-unsigned-x2F-short-x2F-int-x2F-long-x2F-float-x2F-double型数据是怎么表示的？什么称为无符号整数的“溢出”？" class="headerlink" title="2、在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？"></a>2、在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</h5><ul>
<li>unsigned型数据就是无符号整数，不考虑符号位。直接用全部二进制位对数值进行编码得到的就是<strong>无符号数，一般都用补码表示</strong>。</li>
<li><strong>int型数据就是定点整数，一般用补码表示</strong>。int型数据的位数与运行平台和编译器有关，一般是32位或16位。例如，真值是-12的int型整数，在机器内存储的机器数（假定用32位寄存器寄存）是1111-1111-1111-1111-1111-1111-1111-0100。</li>
<li>long型数据和short型数据也都是定点整数，只是位数不同，分别是长整型和短整型数，通常用<strong>补码</strong>表示。</li>
<li>float型数据是用来表示实数的浮点数。现代计算机用IEEE754标准表示浮点数，其中32位单精度浮点数就是float型，64位双精度浮点数就是 double型。</li>
</ul>
<p>需要注意的是，C语言中的int型和 unsigned型变量的存储方式没有区别，都按照补码的形式存储，在不溢出范围内的<strong>加减法运算也是相同的</strong>，只是<span style="color:red">int型变量的最高位代表符号位，而unsigned型中的最高位表示数值位</span>，两者在C语言中的区别体现在输出时到底是采用%d还是采用%u。</p>
<p>对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低n位，<strong>舍弃高位</strong>。这样，会产生以下两种结果：</p>
<ul>
<li>①保留的低n位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第n+1位，称此时发生了“<strong>溢出</strong>”现象</li>
<li>②保留的低n位数能正确表达计算结果，即高位的舍去并不影响其运算结果。</li>
</ul>
<h5 id="3、如何判断一个浮点数是否是规格化数？"><a href="#3、如何判断一个浮点数是否是规格化数？" class="headerlink" title="3、如何判断一个浮点数是否是规格化数？"></a>3、如何判断一个浮点数是否是规格化数？</h5><p>为了使浮点数能尽量多地表示有效位数，一般要求<span style="color:red">运算结果用规格化数形式表示</span>。<strong>规格化浮点数的尾数小数点后的第一位一定是个非零数</strong>。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为1就行：对于补码表示的尾数，只要看符号位和尾数最高位是否相反。需要注意的是，IEEE754标准的<strong>浮点数尾数是用原码编码的</strong>。</p>
<h5 id="4、对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"><a href="#4、对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？" class="headerlink" title="4、对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"></a>4、对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</h5><p>不是，可表示的数据个数取决于编码所采用的位数。<span style="color:red">编码位数一定，编码出来的数据个数就是一定的</span>。m位编码只能表示2^m^个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多(有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异)。</p>
<h5 id="5、浮点数如何进行舍入？"><a href="#5、浮点数如何进行舍入？" class="headerlink" title="5、浮点数如何进行舍入？"></a>5、浮点数如何进行舍入？</h5><p>舍入方法选择的原则是：</p>
<ul>
<li>①尽量使误差范围对称，使得平均误差为0，即有舍有入，以防误差积累。</li>
<li>②方法要简单，以加快速度。</li>
</ul>
<p>IEEE754有4种舍入方式：</p>
<ul>
<li>①就近舍入：舍入为最近可表示的数，若结果值正好落在两个可表示数的中间，则一般选择舍入结果为偶数</li>
<li>②正向舍入：朝+∞方向舍入，即取右边的那个数</li>
<li>③负向舍入：朝-∞方向舍入，即取左边的那个数</li>
<li>④截去：朝0方向舍入，即取绝对值较小的那个数</li>
</ul>
<h5 id="6、现代计算机中是否要考虑原码加减运算？如何实现"><a href="#6、现代计算机中是否要考虑原码加减运算？如何实现" class="headerlink" title="6、现代计算机中是否要考虑原码加减运算？如何实现?"></a>6、现代计算机中是否要考虑原码加减运算？如何实现?</h5><p>因为现代计算机中浮点数采用IEEE754标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为IEEE754规定浮点数的尾数都用原码表示。</p>
<p>原码的加减运算可以有以下两种实现方式：</p>
<ul>
<li>1)转换为补码后，用补码加减法实现，结果再转换为原码。</li>
<li>2)直接用原码进行加减运算，符号和数值部分分开进行（具体过程见原码加减运算部分）。</li>
</ul>
<h5 id="7、长度为n-1的定点数，按照不同的编码方式，表示的数值范围是多少？"><a href="#7、长度为n-1的定点数，按照不同的编码方式，表示的数值范围是多少？" class="headerlink" title="7、长度为n+1的定点数，按照不同的编码方式，表示的数值范围是多少？"></a>7、长度为n+1的定点数，按照不同的编码方式，表示的数值范围是多少？</h5><p>各编码方式的数值范围见表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210121105658823.png" alt="在这里插入图片描述"></p>
<h5 id="8、设阶码和尾数均用补码表示，阶码部分共K-1位-含1位阶符-，尾数部分共n-1位（含1位数符），则这样的浮点数的表示范围是多少？"><a href="#8、设阶码和尾数均用补码表示，阶码部分共K-1位-含1位阶符-，尾数部分共n-1位（含1位数符），则这样的浮点数的表示范围是多少？" class="headerlink" title="8、设阶码和尾数均用补码表示，阶码部分共K+1位(含1位阶符)，尾数部分共n+1位（含1位数符），则这样的浮点数的表示范围是多少？"></a>8、设阶码和尾数均用补码表示，阶码部分共K+1位(含1位阶符)，尾数部分共n+1位（含1位数符），则这样的浮点数的表示范围是多少？</h5><p>浮点数的表示范围见表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210121110204602.png" alt="在这里插入图片描述"></p>
<h3 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h3><p>【复习提示】<br>本章是历年考査的重点，特别是有关 Cache和存储器扩展的知识点容易出综合题。此外，存储器的分类与特点，存储器的扩展(芯片选择、连接方式、地址范围等)，低位交叉存储器，Cache的相关计算与替换算法，虚拟存储器与快表也容易出选择题。读者应在掌握基本原理和理论的基础上，多结合习题进行练习复习，以加深和巩固。另外，读者还需掌握存在 Cache和TLB的计算机中的地址翻译与 Cache映射问题，该问题在《操作系统考研复习指导》中有详细说明。<br>本章有两个难点：</p>
<ul>
<li>一是 Cache映射规律、容量计算及替换特性；</li>
<li>二是交又存储器访问时间和访问效率;</li>
<li>二者都可与第5章的大题综合，或与第6章总线访问内存时间的计算问题综合。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118103433182.png" alt="在这里插入图片描述"></p>
<h4 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h4><h5 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h5><blockquote>
<p><span style="color:red"><strong>相联存储器</strong></span>的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是 <span style="color:red"><strong>按内容或地址进行寻址的</strong></span>，价格较为昂贵。 <span style="color:red"><strong>一般用来制作TLB、相联 Cache等</strong></span>。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118125012658.png" alt="在这里插入图片描述"></p>
<p>1、按在计算机中的作用对存储器分类：</p>
<ul>
<li><strong>主存储器</strong>。简称主存，又称<strong>内存储器（内存）</strong>，用来存放计算机运行期间所需的程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位的价格较高。</li>
<li><strong>辅助存储器</strong>。简称辅存，又称<strong>外存储器（外存）</strong>，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息。辅存的内容需要调入主存后才能被CPU访问。其特点是容量大、存取速度较慢、单位成本低。</li>
<li><strong>高速缓冲存储器</strong>。简称<strong>Cache</strong>，<strong>位于主存和CPU之间</strong>，用来存放当前CPU经常使用的指令和数据，以便CPU能高速地访问它们。Cache的存取速度可与CPLU的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在CPU中。</li>
</ul>
<p>存储系统层次结构主要体现在缓存一主存和主存一辅存这两个存储层次上</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/816877bad1b7d5fca8417580dd970e8c.png" alt="image-20230824160821810"></p>
<ul>
<li><strong>缓存-主存层次</strong>主要解决CPU和主存速度不匹配的问题。</li>
<li><strong>主存-辅存层次</strong>主要解决存储系统的容量问题。</li>
</ul>
<p>2、按存储介质分类：</p>
<ul>
<li>半导体存储器：以半导体器件存储信息；主存、Cache</li>
<li>磁表面存储器：以磁性材料存储信息；磁盘、磁带</li>
<li>光存储器：光盘</li>
</ul>
<p>3、按存取方式分类：</p>
<ul>
<li><strong>随机存储器（RAM）</strong>：存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关，主要用作主存或高速缓冲存储器。<ul>
<li>静态RAM：触发器原理寄存信息</li>
<li>动态RAM：电容充电原理寄存信息</li>
<li>优点：读写方便，使用灵活，主要用于主存或高速缓重存储器</li>
</ul>
</li>
<li><strong>只读存储器（ROM）</strong>：存储器的内容只能随机读出而不能写入。ROM一旦有了信息则不能轻易改变，即使断电，内容也不会丢失。<ul>
<li>掩膜式只读存储器（MROM）</li>
<li>一次可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）：不能取代RAM，因为<strong>编程次数有限，且写入速度很慢</strong>。</li>
<li>闪速存储器（Flash Memory）：由E2ROM发展得到；应用U盘。</li>
<li>固态硬盘（SSD）</li>
</ul>
</li>
<li><strong>相联存储器(CAM)</strong><ul>
<li>不根据地址而是根据<strong>存储内容和指定地址方式</strong>来进行存取的存储器，可以实现快速地<strong>查找快表</strong>。</li>
</ul>
</li>
<li>串行访问存储器：对存储单元进行读&#x2F;写操作时，需按其物理位置的先后顺序寻址，包括<strong>顺序存取存储器</strong>（如磁带）与<strong>直接存取存储器</strong>（如磁盘）。<ul>
<li>顺序存取存储器（SAM）：内容只能<strong>顺序读取</strong>，存取时间长短与信息在存储体上的物理位置有关；<ul>
<li>如磁带。</li>
<li>优点是结构简单，成本低廉，容量大，适合于存放顺序访问的信息。</li>
<li>缺点是存取速度慢，不方便随机访问。</li>
</ul>
</li>
<li>直接存取存储器（DAM）：内容可以<strong>直接读取</strong>，存取时间与信息在存储体上的物理位置无关；<ul>
<li>如磁盘、光盘；</li>
<li>优点是存取速度快，方便随机访问。</li>
<li>缺点是结构复杂，成本较高，容量有限，适合于存放<strong>长期随机访问</strong>的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4、按信息的可保存性分类：</p>
<p><strong>断电后，存储信息即消失的存储器，称为易失性存储器，如RAM</strong>。<strong>断电后信息仍然保持的存储器，称为非易失性存储器，如ROM</strong>，磁表面存储器和光存储器。若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p>
<ul>
<li>易失性存储器：RAM、主存、Cache</li>
<li>非易失性存储器：ROM、磁表面存储器、光存储器</li>
<li>破坏性读出：信息读出后，原存储信息被破坏；如DRAM芯片，读出数据后要进行重写</li>
<li>非破坏性读出：信息读出后，原存储信息不被破坏；如SRAM芯片、磁盘、光盘</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118124526918.png" alt="在这里插入图片描述"></p>
<p>5、信息的可更改性</p>
<ul>
<li><p>读写存储器（Read&#x2F;Write Memory）：即可读、也可写（如：磁盘、内存、Cache）</p>
</li>
<li><p>只读存储器（Read Only Memory）：只能读，不能写（如：实体音乐专辑通常采用CD-RGM，实体电影采用蓝光光碟，BIOS通常写在ROM中。）</p>
</li>
</ul>
<h5 id="3-1-2-存储器的性能指标"><a href="#3-1-2-存储器的性能指标" class="headerlink" title="3.1.2 存储器的性能指标"></a>3.1.2 存储器的性能指标</h5><p>存储器的性能指标，有3个主要的性能指标，存储容量，单位成本和存储速度。</p>
<ul>
<li><strong>存储容量 &#x3D; 存储字数*字长</strong> ，存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</li>
<li>单位成本：每位价格&#x3D;总成本&#x2F;总容量</li>
<li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li>
</ul>
<p><strong>存取时间：指从启动一次存储器操作到完成该操作所经历的时间；从存储器读出或写入一次信息所需要的平均时间；分为读出时间和写入时间。</strong></p>
<p><span style="color:red"><strong>存取周期：它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</strong></span></p>
<p>主存带宽：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字&#x2F;秒，字节&#x2F;秒。</p>
<p><strong>存取时间不等于存储周期，通常存储周期大于存取时间。</strong>因为任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118125344491.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>存取周期（Tm）</strong>&#x2F;读写周期&#x2F;访问周期：存储器进行一次<strong>完整的读写</strong>操作所需的<strong>全部时间</strong>；连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</li>
<li><strong>主存带宽（Bm）</strong>&#x2F;数据传输率：每秒从主存进入信息的最大数量；单位为字&#x2F;秒、字节&#x2F;秒（B&#x2F;s）或位&#x2F;秒（b&#x2F;s）。</li>
</ul>
<h4 id="3-2-存储器的层次结构"><a href="#3-2-存储器的层次结构" class="headerlink" title="3.2 存储器的层次结构"></a>3.2 存储器的层次结构</h4><h5 id="1、存储器的层次化结构"><a href="#1、存储器的层次化结构" class="headerlink" title="1、存储器的层次化结构"></a>1、存储器的层次化结构</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118125626787.png" alt="在这里插入图片描述"></p>
<h5 id="2、存储器的基本概念"><a href="#2、存储器的基本概念" class="headerlink" title="2、存储器的基本概念"></a>2、存储器的基本概念</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119000836086.png" alt="image-20231119000836086"></p>
<h5 id="3、主存储器"><a href="#3、主存储器" class="headerlink" title="3、主存储器"></a>3、主存储器</h5><p>主存储器由<strong>DRAM实现</strong>，靠处理器的那一层（Cache）则由<strong>SRAM</strong>实现，它们都属于<strong>易失性存储器</strong>，只要电源被切断，原来保存的信息便会丢失。</p>
<p>DRAM的每位价格低于SRAM，速度也慢于SRAM，价格差异主要是因为制造SRAM需要更多的硅。</p>
<p><img src="https://img-blog.csdnimg.cn/2021011811115092.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>主存储器的简单模型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118111601687.png" alt="在这里插入图片描述"></p>
<h5 id="4、存储器芯片的基本结构"><a href="#4、存储器芯片的基本结构" class="headerlink" title="4、存储器芯片的基本结构"></a>4、存储器芯片的基本结构</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118112030572.png" alt="在这里插入图片描述"></p>
<h5 id="5、寻址"><a href="#5、寻址" class="headerlink" title="5、寻址"></a>5、寻址</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118112546228.png" alt="在这里插入图片描述"></p>
<h4 id="3-3-半导体随机存储器"><a href="#3-3-半导体随机存储器" class="headerlink" title="3.3 半导体随机存储器"></a>3.3 半导体随机存储器</h4><h5 id="3-3-1-SRAM和DRAM"><a href="#3-3-1-SRAM和DRAM" class="headerlink" title="3.3.1 SRAM和DRAM"></a>3.3.1 SRAM和DRAM</h5><p>通常把存放一个二进制位的物理器件称为<strong>存储元</strong>，它是存储器的最基本的构件。地址码相同的多个存储元构成一个<strong>存储单元</strong>。若干存储单元的集合构成<strong>存储体</strong>。</p>
<p>1）半导体存储芯片的基本结构</p>
<p>存储器芯片由存储体、I&#x2F;O读写电路、地址译码和控制电路等部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118120319811.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>存储体（存储矩阵）</strong>。存储体是存储单元的集合，它由行选择线（X）和列选择线（Y）来选择所访问单元，存储体的相同行、列上的位同时被读出或写入。</li>
<li>地址译码器。用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路。</li>
</ul>
<p>采用地址线复用技术，使用行列地址双译码结构，<strong>行、列地址分两次送</strong>，是为了减少选通线数量。</p>
<blockquote>
<p> 若有2^8^个芯片，单地址译码需要256条选通线，而双地址译码只需要24+24&#x3D;32条选通线。</p>
</blockquote>
<ul>
<li>I&#x2F;O控制电路。用以控制被选中的单元的读出或写入，具有放大信息的作用。</li>
<li>片选控制信号。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。</li>
<li>读&#x2F;写控制信号。根据CPU给出的读命令或写命令，控制被选中单元进行读或写。</li>
</ul>
<p>2）SRAM和DRAM的比较</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118121332468.png" alt="在这里插入图片描述"></p>
<p>3）DRAM的刷新</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118121733617.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>集中刷新</strong>：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间<strong>停止对存储器的读写操作</strong>，称为“死时间”，又称访存“死区”。<ul>
<li>优点：读写操作时不受刷新工作的影响；</li>
<li>缺点：在集中刷新期间（死区）不能访问存储器。</li>
</ul>
</li>
<li><strong>分散刷新</strong>：把对每行的刷新分<strong>散到各个工作周期</strong>中。这样，一个存储器的系统工作周期分为两部分：<strong>前半部分用于正常读、写或保持</strong>；<strong>后半部分用于刷新</strong>。这种刷新方式<strong>增加了系统的存取周期</strong>，如存储芯片的存取周期为0.5μs，则系统的存取周期为1μs。<ul>
<li>优点是<strong>没有死区</strong>；</li>
<li>缺点是加长了系统的存取周期，降低了整机的速度。</li>
</ul>
</li>
<li><strong>异步刷新</strong>：异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用<strong>最大刷新间隔为2ms</strong>的特点。具体做法是将<strong>刷新周期除以行数</strong>，得到两次刷新操作之间的<strong>时间间隔t</strong>，利用逻辑电路每隔时间t产生一次刷新请求。<ul>
<li>这样可以避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118122206696.png" alt="在这里插入图片描述"></p>
<p>4）SRAM的读周期</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118122500900.png" alt="在这里插入图片描述"></p>
<p>5）SRAM的写周期</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118122635264.png" alt="在这里插入图片描述"></p>
<p>6）RAM-易失性存储器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118122754849.png" alt="在这里插入图片描述"></p>
<h5 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h5><ul>
<li>RAM-易失性存储器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118123203340.png" alt="在这里插入图片描述"></p>
<ul>
<li>ROM：Read-Only Memory</li>
</ul>
<p>ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118123813543.png" alt="在这里插入图片描述"></p>
<p>闪速存储器（Flash Memory）：由于闪存需要先擦除在写入，因此闪存的<strong>“写”速度要比“读”速度更慢</strong>。应用：U盘、SD卡。</p>
<ul>
<li>知识回顾和总结</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011812392214.png" alt="在这里插入图片描述"></p>
<h5 id="3-3-3-主存的基本组成（存储系统）"><a href="#3-3-3-主存的基本组成（存储系统）" class="headerlink" title="3.3.3 主存的基本组成（存储系统）"></a>3.3.3 主存的基本组成（存储系统）</h5><p>MAR和MDR是直接做在CPU芯片上面的！</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118140221267.png" alt="在这里插入图片描述"></p>
<p>CPU访问主存过程：</p>
<ul>
<li>CPU首先把被访问单元的地址送到MAR中；通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元</li>
<li>CPU将读写信号通过控制线送到主存的读写控制电路<ul>
<li>写操作：CPU同时将要写的信息送到MDR中，在读写控制电路的控制下，经数据线将信号写入选中的单元</li>
<li>读操作：主存读出选中单元的内容送到数据线，然后送到MDR中</li>
</ul>
</li>
</ul>
<p>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。地址线的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为0 ~ 2^36^-1，即<strong>地址从0开始编号</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118111601687.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>例1：某一SRAM芯片，其容量为1024×8位，除电源和接地端外，该芯片的引脚的最小数目为？</p>
<p>按字节（8位）取地址，需要8位数据线；共有1024&#x3D;2^10^个存储单元，SRAM不复用地址线，需要10位地址线；还需要1片选线，2位读写控制线，共8+10+1+2&#x3D;21位。</p>
<p>例2：某一DRAM芯片，其容量为1024×8位，除电源和接地端外，该芯片的引脚的最小数目为？</p>
<p>DRAM复用地址线，分两次传递地址，地址线减半，需要5位地址线；片选线需要行选通线和列选通线，增加到2根，共8+5+2+2&#x3D;17。</p>
<p><strong>注意：SRAM和DRAM的区别，DRAM采用地址复用技术，而SRAM不采用。</strong></p>
</blockquote>
<h4 id="3-4-主存储器与CPU的连接"><a href="#3-4-主存储器与CPU的连接" class="headerlink" title="3.4 主存储器与CPU的连接"></a>3.4 主存储器与CPU的连接</h4><h5 id="3-4-1-连接原理"><a href="#3-4-1-连接原理" class="headerlink" title="3.4.1 连接原理"></a>3.4.1 连接原理</h5><p>单个芯片的容量不可能很大，往往通过<strong>存储器芯片扩展技术</strong>，将<strong>多个芯片</strong>集成在一个内存条上，然后由多个内存条及主板上的ROM芯片组成计算机所需的主存空间，再通过总线与CPU相连。</p>
<p>内存条插槽就是<strong>存储器总线</strong>，内存条中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到<strong>CPU芯片</strong>。</p>
<p> 主存与CPU连接原理：</p>
<ul>
<li>1）主存储器通过数据总线、地址总线和控制总线与CPU连接。</li>
<li>2）数据总线的位数与工作频率的乘积正比于数据传输率。</li>
<li>3）地址总线的位数决定了可寻址的最大内存空间。</li>
<li>4）控制总线（读&#x2F;写）指出总线周期的类型和本次输入&#x2F;输出操作完成的时刻。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/d4d36b19db69bbd4d2f1d77e955063b1.png" alt="image-20230828134514493"></p>
<h5 id="3-4-2-主存容量的扩展"><a href="#3-4-2-主存容量的扩展" class="headerlink" title="3.4.2 主存容量的扩展"></a>3.4.2 主存容量的扩展</h5><p>1、位扩展</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118131138347.png" alt="在这里插入图片描述"></p>
<p>用多个存储器件对字长进行扩充，增加<strong>存储字长</strong>使其<strong>数据位数</strong>与<strong>CPU的数据线数</strong>相等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118131242359.png" alt="在这里插入图片描述"></p>
<p>连接方式：将多个存储芯片的<strong>地址端、片选端和读写控制端</strong>相应并联，数据端分别引出。</p>
<blockquote>
<p>注意：仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以<strong>片选信号CS</strong>要<strong>连接到所有芯片</strong>。</p>
</blockquote>
<p>2、字扩展</p>
<p>增加存储器中字的数量，而位数不变。</p>
<ol>
<li>CS：片选线（决定主存是否工作）这种写法是高电平有效</li>
<li>WE：读写控制线</li>
<li>A0~A13：地址线</li>
<li>D0~D7：数据线</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118131602758.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118131821650.png" alt="在这里插入图片描述"></p>
<p>连接方式：将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p>
<blockquote>
<p>注意：仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号CS或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<ul>
<li>1）译码器功能</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118132217258.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118132312933.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）带译码器的字扩展</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118132515341.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118132725555.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）线选法和译码片选法的区别</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118132847588.png" alt="在这里插入图片描述"></p>
<p>3、字位同时扩展法</p>
<p>字位同时扩展是指既增加存储字的数量，又增加存储字长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118133202267.png" alt="在这里插入图片描述"></p>
<p>如上图所示，用8片16K×4位的RAM芯片组成64K×8位的存储器。每两片构成一组16K×8位的存储器（位扩展），4组便构成64K×8位的存储器（字扩展）。</p>
<blockquote>
<p>注意：采用字位同时扩展时，各芯片连接<strong>地址线的方式相同</strong>，但连接<strong>数据线的方式不同</strong>，而且需要通过片选信号CS或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<p>4、例题</p>
<p>设CPU有16根地址线，8根数据线，并用MREQ作为访存控制信号（低电平有效），用WR作为读&#x2F;写控制信号（高电平为读，低电平为写）。现有下列存储芯片：1K×4位RAM，4K×8位RAM，8K×8位RAM，2K×8位ROM，4K×8位ROM，8K×8位ROM及74LS138译码器和各种门电路。画出CPU与存储器的连接图，要求：<br>1）主存地址空间分配：6000H～67FFH为系统程序区；6800H～6BFFH为用户程序区。<br>2）合理选用上述存储芯片，说明各选几片？<br>3）详细画出存储芯片的片选逻辑图。<br>补充：系统程序区用ROM，用户程序区用RAM。</p>
<p>解题：</p>
<ul>
<li>步骤一</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118134716117.png" alt="在这里插入图片描述"></p>
<ul>
<li>步骤二</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119003534670.png" alt="image-20231119003534670"></p>
<ul>
<li>步骤三</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119003654558.png" alt="image-20231119003654558"></p>
<p>4、知识回顾和总结</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118133331377.png" alt="在这里插入图片描述"></p>
<h4 id="3-5-双端口RAM和多模块存储器"><a href="#3-5-双端口RAM和多模块存储器" class="headerlink" title="3.5 双端口RAM和多模块存储器"></a>3.5 双端口RAM和多模块存储器</h4><h5 id="3-5-1-双端口RAM"><a href="#3-5-1-双端口RAM" class="headerlink" title="3.5.1 双端口RAM"></a>3.5.1 双端口RAM</h5><p>双端口顾名思义就是存储器芯片提供两个端口给两个CPU进行访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011814115163.png" alt="在这里插入图片描述"></p>
<h5 id="3-5-2-多模块存储器"><a href="#3-5-2-多模块存储器" class="headerlink" title="3.5.2 多模块存储器"></a>3.5.2 多模块存储器</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118141608410.png" alt="在这里插入图片描述"></p>
<h5 id="3-5-3-多体并行存储器"><a href="#3-5-3-多体并行存储器" class="headerlink" title="3.5.3 多体并行存储器"></a>3.5.3 多体并行存储器</h5><p>多体并行存储器由多体模块组成。每个模块都有<strong>相同的容量</strong>和<strong>存取速度</strong>，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p>
<blockquote>
<p>多体并行存储器分为高位交叉编址(顺序方式)和低位交叉编址(交叉方式)两种。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118142221658.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118142720710.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118143106156.png" alt="在这里插入图片描述"></p>
<p>交叉存储器实际上是一种模块式的存储器，它能并行执行多个独立的读&#x2F;写操作。</p>
<h5 id="3-5-4-知识回顾"><a href="#3-5-4-知识回顾" class="headerlink" title="3.5.4 知识回顾"></a>3.5.4 知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118143226136.png" alt="在这里插入图片描述"></p>
<h4 id="3-6-高速缓冲存储器"><a href="#3-6-高速缓冲存储器" class="headerlink" title="3.6 高速缓冲存储器"></a>3.6 高速缓冲存储器</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118152531151.png" alt="在这里插入图片描述"></p>
<h5 id="3-6-1-程序访问的局部性原理"><a href="#3-6-1-程序访问的局部性原理" class="headerlink" title="3.6.1 程序访问的局部性原理"></a>3.6.1 程序访问的局部性原理</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118153706155.png" alt="在这里插入图片描述"></p>
<p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。因为指令通常是顺序存放、 顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</p>
<p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；因为程序中存在循环。</p>
<p>高速缓冲技术就是<strong>利用局部性原理</strong>，把程序中正在使用的部分数据存放在一个<strong>高速的、容量较小</strong>的Cache 中，使CPU的访存操作大多数针对Cache进行，从而<strong>提高程序的执行速度</strong>。</p>
<ul>
<li>性能分析</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118154054452.png" alt="在这里插入图片描述"></p>
<ul>
<li>例题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118154622198.png" alt="在这里插入图片描述"></p>
<ul>
<li>本节回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119204813263.png" alt="image-20231119204813263"></p>
<h5 id="3-6-2-Cache的基本工作原理"><a href="#3-6-2-Cache的基本工作原理" class="headerlink" title="3.6.2 Cache的基本工作原理"></a>3.6.2 Cache的基本工作原理</h5><p>1、工作原理</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118155220907.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>1）Cache特点</p>
<ul>
<li>Cache块：Cache和主存都被划分为相等的块，<strong>Cache块又称Cache行</strong>，每块由若干字节组成，块的长度称为块长（Cache行长)。</li>
<li>由于Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。</li>
<li>Cache按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。</li>
</ul>
</li>
<li><p>2）Cache工作流程</p>
<ul>
<li>当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；</li>
<li><strong>若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。（地址映射）</strong></li>
<li><strong>若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。（替换算法）</strong></li>
</ul>
<blockquote>
<p>注意：某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止；否则访问主存并替换Cache。</p>
</blockquote>
</li>
<li><p>3）整个过程全部由硬件实现</p>
<ul>
<li>值得注意的是，<strong>CPU与Cache之间的数据交换以字为单位</strong>，而<strong>Cache与主存之间的数据交换则以Cache块为单位</strong>。</li>
</ul>
</li>
</ul>
<p>2、Cache和主存的映射方式</p>
<p>Cache 行中的信息是主存中某个块的副本，<strong>地址映射是指把主存地址空间映射到Cache地址空间</strong>，即把存放在主存中的信息按照某种规则装入Cache。</p>
<p>由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要为每块加一个<strong>标记</strong>，<span style="color:red">指明它是主存中哪一块的副本</span>。该标记的内容相当于<strong>主存中块的编号</strong>。为了说明Cache行中的信息是否有效，每个Cache行需要一个<strong>有效位</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118161908289.png" alt="在这里插入图片描述"></p>
<ul>
<li>1）全相联映射</li>
</ul>
<blockquote>
<p>主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118160044877.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）直接映射</li>
</ul>
<blockquote>
<p>主存块只能放到特定的某个Cache行，若这个位置已有内容，则产生冲突，原来的块被替换（无需替换算法）</p>
<p>直接映射的关系可定义为：Cache行号 &#x3D; 主存块号 % Cache总行数 。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118161005288.png" alt="在这里插入图片描述"></p>
<p>假设Cache有2^c^行，主存有2^m^块，在直接映射方式，主存的第0块、第2^c^块、第2^c+1^块…只能映射到第0行。</p>
<p>由此看出，主存块号低c位正好是要装入Cache的行号。给每个Cache设置长为t&#x3D;m-c的标记（tag），当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中。</p>
<blockquote>
<p>首先根据访存地址中间的c位，找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为0，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送CPU。</p>
</blockquote>
<ul>
<li>3）组相联映射</li>
</ul>
<p>主存块可以放到<strong>特定分组</strong>中的<strong>任意位置</strong>。常用的有2路组相联映射。</p>
<blockquote>
<p>组相联映射的关系可以定义为： Cache组号 &#x3D; 主存块号 % Cache组数（Q）</p>
<p>路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118161717189.png" alt="在这里插入图片描述"></p>
<p>CPU访存过程如下：</p>
<ol>
<li>首先根据访存地址中间的组号找到对应的Cache组；</li>
<li>将对应Cache组中<strong>每个行的标记</strong>与<strong>主存地址的高位标记</strong>进行比较；</li>
<li>若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息；</li>
<li>若都不相等或虽相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。</li>
</ol>
<p>3、本节回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118162110824.png" alt="在这里插入图片描述"></p>
<h5 id="3-6-3-Cache中主存块的替换算法"><a href="#3-6-3-Cache中主存块的替换算法" class="headerlink" title="3.6.3 Cache中主存块的替换算法"></a>3.6.3 Cache中主存块的替换算法</h5><blockquote>
<p>全相联映射和组相联映射需要，直接相连映射不需要。从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。</p>
</blockquote>
<ol>
<li><p><strong>随机算法(RAND)</strong>: 随机地确定替换的 Cache块。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低。</p>
</li>
<li><p><strong>先进先出算法(FIFO)</strong>: 选择最早调入的行进行替换。它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入 Cache的块替换掉。</p>
</li>
<li><p><strong>近期最少使用算法（LRU)</strong>: 依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FIFO要高，是堆栈类算法。</p>
<p>LRU算法对每行设置一个计数器， Cache每命中一次，命中行计数器清0,而其他各行计数器均加1,需要替换时比较各特定行的计数值，将计数值最大的行换出。</p>
<p>特点：<strong>基于“局部性原理”</strong>，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，<strong>Cache命中率高</strong>。</p>
<blockquote>
<p>若被频繁访问的主存块数量&gt;Cache行的数量，则有可能发生“<strong>抖动</strong>”，如：[1，2，3，4，5，1，2，3，4，5，1，2…）</p>
</blockquote>
</li>
<li><p><strong>最不经常使用算法(LFU</strong>): 将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1,需要替换时比较各特定行的计数值，将计数值最小的行换出。</p>
<p>特点：曾经被经常访问的主存块在未来不一定会用到（如：微信视频聊天相关的块），并没有很好地遵循局部性原理，因此实际运行效果不如LRU。</p>
</li>
</ol>
<p>例题：</p>
<ul>
<li>1）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118165532966.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118165814310.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170111197.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170304797.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170454838.png" alt="在这里插入图片描述"></p>
<p>小结</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170712263.png" alt="在这里插入图片描述"></p>
<p>Cache写策略</p>
<ul>
<li>1）写策略-写命中<ul>
<li><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。<ul>
<li>减少了访存次数，但存在数据不一致的隐患。</li>
<li>每个Cache行必须设直一个<strong>标志位（脏位）</strong>，以反映此块是否被<strong>CPU修改过</strong>。</li>
</ul>
</li>
<li><strong>全写法</strong>：当CPU对Cache写命中时，必须把<strong>数据同时写入Cache和主存</strong>，一般使用写缓冲（write buffer）。<ul>
<li>访存次数增加，速度变慢，但更能保证数据一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170905141.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>2）写策略-写不命中</p>
<ul>
<li>写分配法<ul>
<li>当CPU对Cache写不命中时，把<strong>主存中的块调入Cache</strong>，在Cache中修改。</li>
<li>&#x3D;&#x3D;通常搭配写回法使用&#x3D;&#x3D;。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118170952485.png" alt="在这里插入图片描述"></p>
<ul>
<li>非写分配法<ul>
<li>当CPU对Cache写不命中时，<strong>只写入主存</strong>，不调入Cache。</li>
<li>&#x3D;&#x3D;搭配全写法使用&#x3D;&#x3D;。</li>
<li>只有“读”未命中时才调入Cache。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118171022149.png" alt="在这里插入图片描述"></p>
</li>
<li><p>3）小结</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118171131890.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）多级Cache<ul>
<li>现代计算机常采用多级Cache离CPU越近的速度越快，容量越小离CPU越远的速度越慢，容量越大。</li>
<li>各级<strong>Cache之间</strong>常采用<strong>“全写法+非写分配法”</strong></li>
<li><strong>Cache-主存</strong> 之间常采用<strong>“写回法+写分配法”</strong></li>
</ul>
</li>
</ul>
<p>Cache工作原理知识回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011817132510.png" alt="在这里插入图片描述"></p>
<p>Cache例题</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118180753574.png" alt="在这里插入图片描述"></p>
<ul>
<li>1）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118181530140.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118182718274.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118183406215.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118183544596.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118184200685.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）补充</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119212533394.png" alt="image-20231119212533394"></p>
<p>Cache工作原理流程图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118183841211.png" alt="在这里插入图片描述"></p>
<h4 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h4><blockquote>
<p>主存和辅存共同构成了<strong>虚拟存储器</strong>，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是<strong>透明</strong>的。虚拟存储器具有<strong>主存的速度和辅存的容量</strong>。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119212748986.png" alt="image-20231119212748986"></p>
<h5 id="3-7-1-虚拟存储器的基本概念"><a href="#3-7-1-虚拟存储器的基本概念" class="headerlink" title="3.7.1 虚拟存储器的基本概念"></a>3.7.1 虚拟存储器的基本概念</h5><blockquote>
<p><strong>虚拟存储器</strong>将主存或辅存的地址空间<strong>统一编址</strong>，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而<strong>不必在乎实际的主存容量</strong>和程序在主存中实际的存放位置。</p>
</blockquote>
<p>1）地址空间</p>
<ul>
<li><strong>逻辑地址</strong>：又称虚地址，用户编程允许涉及的地址。虚地址要比实地址大很多。</li>
<li><strong>程序空间</strong>：又称虚拟空间，虚地址对应的存储空间。虚拟存储器的地址空间如下图所示。</li>
<li><strong>物理地址</strong>：又称实地址，实际的主存单元地址。</li>
<li><strong>主地址空间</strong>：又称实地址空间，实地址对应的存储空间。</li>
</ul>
<p>2）虚拟地址工作流程</p>
<p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。</p>
<ul>
<li>若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；</li>
<li>若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。</li>
<li>若主存已满，则采用替换算法置换主存中的交换块（即页面）。</li>
</ul>
<p>3）映射方式与写机制</p>
<ul>
<li>虚拟存储机制采用<strong>全相联映射</strong>，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。</li>
<li>当进行写操作时，不能每次写操作都同时写回磁盘，因而，在处理一致性问题时，采用<strong>回写法</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118185557288.png" alt="在这里插入图片描述"></p>
<h5 id="3-7-2-页式虚拟存储器"><a href="#3-7-2-页式虚拟存储器" class="headerlink" title="3.7.2 页式虚拟存储器"></a>3.7.2 页式虚拟存储器</h5><blockquote>
<p>页式虚拟存储器以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页。</p>
</blockquote>
<p>1）概念</p>
<ul>
<li>实页：主存的页，又称页框。</li>
<li>虚页：虚存的页。</li>
<li><strong>虚拟地址：虚页号+页内地址。</strong></li>
<li>页表：页表是一张<strong>存放在主存</strong>中的<strong>虚页号和实页号的对照表</strong>，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般<strong>长久地保存在内存</strong>中。虚拟地址到物理地址的转换是由页表实现的。</li>
</ul>
<p>2）页表</p>
<ul>
<li>有效位：又称装入位，用来表示对应页面是否在主存，<ul>
<li>若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号；</li>
<li>若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。</li>
</ul>
</li>
<li><strong>脏位：又称修改位，用来表示页面是否被修改过</strong>，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。</li>
<li><strong>引用位：又称使用位，用来配合替换策略进行设置</strong>，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略等。</li>
<li>页表的使用：<ul>
<li>CPU执行指令时，需要先将虚拟地址转换为主存物理地址。</li>
</ul>
</li>
<li>页表基址寄存器存放进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，<ul>
<li>若装入位为1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；</li>
<li>若装入位为0，则说明缺页，需要操作系统进行缺页处理。</li>
</ul>
</li>
</ul>
<p>3）快表（TLB）</p>
<ul>
<li>问题：由地址转换过程可知，访存时<strong>先访问一次主存去查页表，再访问主存</strong>才能取得数据。如果缺页，那么还要进行<strong>页面替换、页面修改</strong>等，因此采用虚拟存储机制后，访问主存的次数更多了。</li>
<li>解决：将近期访问的页表项放入更高速的存储器组成的<strong>快表（TLB），可加快地址变换的速度</strong>。相应的把放<strong>在主存中的页表称为慢表</strong>。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。</li>
<li>结构：快表通常采用全相联或组相联方式。每个TLB项由页表表项内容加上一个TLB标记字段组成，<ul>
<li><strong>TLB标记</strong>用来表示该表项取自页表中哪个虚页号对应的页表项，</li>
<li>全相联方式：TLB标记对应该页表项的虚页号；</li>
<li>组相联方式：TLB标记对应虚页号的高位部分，而虚页号的低位部分用于选择TLB组的组索引。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意区别：快表中存储的是页表项的副本；Cache中存储的是主存块的副本</strong>。</p>
</blockquote>
<p>4）具有TLB和Cache的多级存储系统</p>
<ul>
<li><p><strong>CPU利用虚页号查询快表TLB</strong>。TLB每一项都有一个比较器，查找时将<strong>虚页号</strong>与每个<strong>TLB标记字段</strong>同时进行比较，</p>
<ul>
<li><p>若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行<strong>地址转换</strong>；</p>
</li>
<li><p>若未命中，则TLB缺失，需要访问主存去查页表。</p>
</li>
</ul>
<blockquote>
<p>地址转换指，将虚拟地址转换为物理地址。</p>
</blockquote>
</li>
<li><p><strong>TLB未命中查询页表（慢表）</strong>。图中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，</p>
<ul>
<li>若TLB已满，则还需要采用替换策略。</li>
</ul>
</li>
<li><p><strong>根据物理地址查询Cache</strong>。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，</p>
<ul>
<li>将对应<strong>Cache行中的标记</strong>与<strong>物理地址中的高位部分</strong>进行比较，若相等且对应<strong>有效位为1</strong>，则Cache命中，此时根据块内地址取出对应的字送CPU。</li>
</ul>
<blockquote>
<p>查找时，<strong>快表和慢表也可以同步进行</strong>，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118190505251.png" alt="在这里插入图片描述"></p>
<p>在一个具有Cache和TLB的虚拟存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问。</p>
<p>CPU访存过程中存在三种缺失情况：</p>
<ul>
<li>①TLB缺失：要访问的页面的页表项不在TLB中；</li>
<li>②Cache缺失：要访问的主存块不在Cache中；</li>
<li>③Page缺失：要访问的页面不在主存中。这三种缺失的可能组合情况如下表所示。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/ddd900a6fda9c4e3809e7dca1229d098.png" alt="image-20230829095743473"></p>
<ul>
<li>最好的情况是第1种组合，此时<strong>无须访问主存</strong>；</li>
<li>第2种和第3种组合都需要<strong>访问一次主存</strong>；</li>
<li>第4种组合需要<strong>访问两次主存</strong>；</li>
<li>第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。Cache缺失处理由硬件完成。</li>
</ul>
<blockquote>
<p>缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；</p>
<p>而TLB缺失既可以用硬件又可以用软件来处理。</p>
</blockquote>
<p>5）例题</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118191640275.png" alt="在这里插入图片描述"></p>
<h5 id="3-7-3-段式虚拟存储器"><a href="#3-7-3-段式虚拟存储器" class="headerlink" title="3.7.3 段式虚拟存储器"></a>3.7.3 段式虚拟存储器</h5><blockquote>
<p>段式虚拟存储器中的段是&#x3D;&#x3D;按程序的逻辑结构（功能模块）&#x3D;&#x3D;划分的，各个段的长度因程序而异。</p>
</blockquote>
<p>1）虚拟地址&#x3D;段号+段内地址</p>
<p>2）段表：是<strong>程序的逻辑段</strong>和<strong>在主存中存放位置</strong>的对照表，实现虚拟地址到实地址之间的变换。</p>
<ul>
<li>段表的每行记录与某个段对应的<strong>段号、装入位、段起点和段长</strong>等信息。由于段的长度可变，所以段表中要给出各段的<strong>起始地址与段的长度</strong>。</li>
</ul>
<p>3）访存方式</p>
<ul>
<li>CPU根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，</li>
<li>然后根据该段表行的装入位判断该段是否已调入主存<ul>
<li>装入位为“1”，表示该段已调入主存；</li>
<li>装入位为“0”，表示该段不在主存中。</li>
</ul>
</li>
<li>已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。下图为段式虚拟存储器的地址变换过程。</li>
</ul>
<p>​	<img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/1e49850a94003f6bcf803664bb0ef051.png" alt="image-20230829101527718"></p>
<p>4）特点</p>
<ul>
<li><strong>优点</strong>：段的分界与程序的自然分界相对应，因而具有<strong>逻辑独立性</strong>，使得它易于编译、管理、修改和保护，也便于多道程序的共享</li>
<li><strong>缺点</strong>：因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118190638653.png" alt="在这里插入图片描述"></p>
<h5 id="3-7-4-段页式虚拟存储器"><a href="#3-7-4-段页式虚拟存储器" class="headerlink" title="3.7.4 段页式虚拟存储器"></a>3.7.4 段页式虚拟存储器</h5><p>1）定义</p>
<ul>
<li>把程序按逻辑结构分段，每段再划分为固定大小的页</li>
<li>主存空间也划分为大小相等的页</li>
<li><span style="color:red">程序对主存的调入、调出仍以页为基本传送单位</span></li>
<li><strong>每个程序对应一个段表，每段对应一个页表</strong></li>
<li>虚拟地址：段号+段内页号+页内地址</li>
</ul>
<p>2）内存布局</p>
<ul>
<li>在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</li>
</ul>
<p>3）地址转换</p>
<p>虚地址分为段号、段内页号、页内地址三部分。</p>
<ul>
<li>CPU根据虚地址访存时，首先根据段号得到段表地址；</li>
<li>然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；</li>
<li>最后从页表中取出实页号，与页内地址拼接形成主存实地址。</li>
</ul>
<p>4）特点</p>
<ul>
<li>优点：兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。</li>
<li>缺点：在地址变换过程中需要两次查表，系统开销较大。</li>
</ul>
<h5 id="3-7-5-快表（TLB）"><a href="#3-7-5-快表（TLB）" class="headerlink" title="3.7.5 快表（TLB）"></a>3.7.5 快表（TLB）</h5><ul>
<li>页表、段表存放在主存中，收到虚拟地址后要先访问主存，査询页表、段表，进行虚实地址转换</li>
<li>放在主存中的页表称为慢表(Page)</li>
<li>提高变换速度→<strong>用高速绥沖存储器存放常用的页表项</strong> → 快表(TLB)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118191319965.png" alt="在这里插入图片描述"></p>
<h5 id="3-7-6-虚拟存储器与Cache的比较"><a href="#3-7-6-虚拟存储器与Cache的比较" class="headerlink" title="3.7.6 虚拟存储器与Cache的比较"></a>3.7.6 虚拟存储器与Cache的比较</h5><p>相同点：</p>
<ul>
<li>1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</li>
<li>2）都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。</li>
<li>3）都有地址的映射、替换算法、更新策略等问题。</li>
<li>4）依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中。</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>1）<strong>Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。</strong></p>
</li>
<li><p>2）<strong>Cache全由硬件实现</strong>，是硬件存储器，<strong>对所有程序员透明</strong>；而<strong>虚拟存储器由OS和硬件共同实现</strong>，是逻辑上的存储器，<strong>对系统程序员不透明，但对应用程序员透明</strong>。</p>
<blockquote>
<p>主存一辅存：实现虚拟存储系统，解决了主存容量不够的问题</p>
<p>Cache-主存：解决了主存与CPU速度不匹配的问题</p>
</blockquote>
</li>
<li><p>3）对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。</p>
</li>
<li><p>4）CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p>
</li>
</ul>
<h4 id="3-8-本章提出的问题与回答"><a href="#3-8-本章提出的问题与回答" class="headerlink" title="3.8 本章提出的问题与回答"></a>3.8 本章提出的问题与回答</h4><h5 id="1、存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？"><a href="#1、存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？" class="headerlink" title="1、存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？"></a>1、存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？</h5><ul>
<li>存储器的层次结构主要体现在 Cache-主存 和 主存-辅存这两个存储层次上。</li>
<li><strong>Cache-主存</strong>层次在存储系统中主要 <strong>对CPU访存起加速作用</strong>，即从整体运行的效果分析，CPU访存速度加快，接近于 Cache的速度，而寻址空间和位价却接近于主存。</li>
<li><strong>主存-辅存</strong>层次在存储系统中主要 <strong>起扩容作用</strong>，即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存。</li>
<li>综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。</li>
<li><strong>主存与 Cache之间的信息调度功能全部由硬件自动完成</strong>。而主存与辅存层次的调度目前广泛采用<span style="color:red">虚拟存储技术</span>实现，即将主存与辅存的一部分通过软&#x2F;硬结合的技术组成虚拟存储器，程序员可用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软&#x2F;硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。因此，这两个层次上的调度或转换操作对于程序员来说都是透明的。</li>
</ul>
<h5 id="2、存取周期和存取时间有何区别？"><a href="#2、存取周期和存取时间有何区别？" class="headerlink" title="2、存取周期和存取时间有何区别？"></a>2、存取周期和存取时间有何区别？</h5><p>存取周期和存取时间的主要区别是：存取时间仅为完成一次操作的时间；而<span style="color:red">存取周期不仅包含操作时间，而且包含操作后线路的恢复时间</span>，即<strong>存取周期&#x3D;存取时间+恢复时间</strong>。(这是不是也可以解释，为什么IC前端，时序分析中有建立时间和保持时间吧)</p>
<h5 id="3、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？"><a href="#3、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？" class="headerlink" title="3、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？"></a>3、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？</h5><p><span style="color:red">页面不能设置得过大，也不能设置得过小。</span>因为页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率；页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入&#x2F;调出的时间较长。</p>
<h4 id="3-9-常见问题和易混淆知识点"><a href="#3-9-常见问题和易混淆知识点" class="headerlink" title="3.9 常见问题和易混淆知识点"></a>3.9 常见问题和易混淆知识点</h4><h5 id="1、存取时间Ta就是存储周期Tm吗？"><a href="#1、存取时间Ta就是存储周期Tm吗？" class="headerlink" title="1、存取时间Ta就是存储周期Tm吗？"></a>1、存取时间T<del>a</del>就是存储周期T<del>m</del>吗？</h5><ul>
<li>不是。存取时间T<del>a</del>是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间。</li>
<li><strong>存储周期T<del>m</del>是指存储器进行连续两次独立地读或写操作所需的最小时间间隔</strong>。所以存取时间T<del>a</del>不等于存储周期T<del>m</del>。<span style="color:red">通常存储周期T<del>m</del>大于存取时间T<del>a</del></span>。</li>
</ul>
<h5 id="2、Cache行的大小和命中率之间有什么关系？"><a href="#2、Cache行的大小和命中率之间有什么关系？" class="headerlink" title="2、Cache行的大小和命中率之间有什么关系？"></a>2、Cache行的大小和命中率之间有什么关系？</h5><p>行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个：</p>
<ul>
<li>行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。</li>
<li>行长太大， Cache项数变少，因而命中的可能性变小。</li>
</ul>
<h5 id="3、发生取指令Cache缺失的处理过程是什么？"><a href="#3、发生取指令Cache缺失的处理过程是什么？" class="headerlink" title="3、发生取指令Cache缺失的处理过程是什么？"></a>3、发生取指令Cache缺失的处理过程是什么？</h5><ul>
<li>1)程序计数器恢复当前指令的值。</li>
<li>2)对主存进行读的操作。</li>
<li>3)<span style="color:red">将读入的指令写入 Cache中，更改有效位和标记位</span>。</li>
<li>4)重新执行当前指令。</li>
</ul>
<h5 id="4、关于-Cache的一些小知识"><a href="#4、关于-Cache的一些小知识" class="headerlink" title="4、关于 Cache的一些小知识"></a>4、关于 Cache的一些小知识</h5><ul>
<li>多级 Cache。现代计算机系统中，一般采用多级的 Cache系统。CPU执行指令时，先到速度最快的一级 Cache( LI Cache)中寻找指令或数据，找不到时，再到速度次快的二级Cache(L2 Cache)中找…最后到主存中找。</li>
<li>指令 Cache和数据 Cache。指令和数据可以分别存储在不同的 Cache中（ LI Cache一般会这么做），这种结构也称哈佛 Cache，其特点是允许CPU在同一个 Cache存储周期内同时提取指令和数据，由于指令执行过程取指和取数据都有可能访问 Cache，因此这一特性可以保证不同的指令同时访存。</li>
</ul>
<h3 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h3><p>【复习提示】<br>指令系统是表征一台计算机性能的重要因素。读者应注意扩展操作码技术，各种寻址方式的特点及有效地址的计算，相对寻址有关的计算，CISC与RISC的特点与区别。本章知识点出选择题的概率较大，但也有可能结合其他章节出有关指令的综合题。2014年、2015年已连续两次出现指令系统和指令流水线的大题。指令系统格式和指令寻址方式与CPU指令执行过程部分紧密结合，希望读者引起重视。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119195316544.png" alt="在这里插入图片描述"></p>
<h4 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119080130248.png" alt="在这里插入图片描述"></p>
<h5 id="4-1-1-指令的基本格式"><a href="#4-1-1-指令的基本格式" class="headerlink" title="4.1.1 指令的基本格式"></a>4.1.1 指令的基本格式</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119080328115.png" alt="在这里插入图片描述"></p>
<ul>
<li>地址码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119080751543.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119080907495.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119081243715.png" alt="在这里插入图片描述"></p>
<ul>
<li>操作码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119081412855.png" alt="在这里插入图片描述"></p>
<ul>
<li>扩展操作码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119081728969.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119082005821.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119082700651.png" alt="在这里插入图片描述"></p>
<ul>
<li>指令操作码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119082835355.png" alt="在这里插入图片描述"></p>
<ul>
<li>操作类型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119083045779.png" alt="在这里插入图片描述"></p>
<ul>
<li>小结回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119083155606.png" alt="在这里插入图片描述"></p>
<h4 id="4-2-指令寻址方式"><a href="#4-2-指令寻址方式" class="headerlink" title="4.2 指令寻址方式"></a>4.2 指令寻址方式</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231119215105160.png" alt="image-20231119215105160"></p>
<h5 id="4-2-1-指令的寻址方式"><a href="#4-2-1-指令的寻址方式" class="headerlink" title="4.2.1 指令的寻址方式"></a>4.2.1 指令的寻址方式</h5><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类。</p>
<ul>
<li>指令寻址<ul>
<li>顺序寻址：通过<strong>程序计数器PC加1</strong>（1个指令字长），自动形成下一条指令的地址。</li>
<li>跳跃寻址：通过<strong>转移类指令实现</strong>。执行转移类指令导致的<strong>PC值改变</strong>，跳跃的地址分为绝<strong>对地址</strong>（由标记符直接得到）和<strong>相对地址</strong>（相对于当前指令地址的偏移量）。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119084909639.png" alt="在这里插入图片描述"></p>
<ul>
<li>操作数类型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011908542061.png" alt="在这里插入图片描述"></p>
<h5 id="4-2-2-常见的数据寻址方式"><a href="#4-2-2-常见的数据寻址方式" class="headerlink" title="4.2.2 常见的数据寻址方式"></a>4.2.2 常见的数据寻址方式</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119085615596.png" alt="在这里插入图片描述"></p>
<p><strong>通过寻址特征和形式地址求出有效地址</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119085738146.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119085848678.png" alt="在这里插入图片描述"></p>
<ul>
<li>1）隐含寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119091626348.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）立即寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119090126687.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）直接寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119090404850.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）间接寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119090647364.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119090909241.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）寄存器寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011909123018.png" alt="在这里插入图片描述"></p>
<ul>
<li>6）寄存器间接寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119091458907.png" alt="在这里插入图片描述"></p>
<ul>
<li>7）相对寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119101949246.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119102220360.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119102957480.png" alt="在这里插入图片描述"></p>
<ul>
<li>8）基址寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119093521307.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119093931734.png" alt="在这里插入图片描述"></p>
<ul>
<li>9）变址寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119101038975.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119101749652.png" alt="在这里插入图片描述"></p>
<ul>
<li>10）堆栈寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119103839345.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011910392940.png" alt="在这里插入图片描述"></p>
<ul>
<li>11）偏移寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119093328746.png" alt="在这里插入图片描述"></p>
<ul>
<li>12）知识回顾与总结</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119103151148.png" alt="在这里插入图片描述"></p>
<h5 id="4-2-3-数据存放方式"><a href="#4-2-3-数据存放方式" class="headerlink" title="4.2.3 数据存放方式"></a>4.2.3 数据存放方式</h5><ul>
<li>1）编址与寻址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119083804299.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）大端方式和小端方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119084236506.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）边界对齐</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119084516263.png" alt="在这里插入图片描述"></p>
<h5 id="4-2-4-知识回顾与总结"><a href="#4-2-4-知识回顾与总结" class="headerlink" title="4.2.4 知识回顾与总结"></a>4.2.4 知识回顾与总结</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119105339671.png" alt="在这里插入图片描述"></p>
<h4 id="4-3-CISC和RISC的基本概念"><a href="#4-3-CISC和RISC的基本概念" class="headerlink" title="4.3 CISC和RISC的基本概念"></a>4.3 CISC和RISC的基本概念</h4><ul>
<li>基本含义</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119104517320.png" alt="在这里插入图片描述"></p>
<ul>
<li>特点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119104936411.png" alt="在这里插入图片描述"></p>
<h4 id="4-4-本章提出的问题与回答"><a href="#4-4-本章提出的问题与回答" class="headerlink" title="4.4 本章提出的问题与回答"></a>4.4 本章提出的问题与回答</h4><h5 id="1、什么是指令？什么是指令系统？为什么要引入指令系统？"><a href="#1、什么是指令？什么是指令系统？为什么要引入指令系统？" class="headerlink" title="1、什么是指令？什么是指令系统？为什么要引入指令系统？"></a>1、什么是指令？什么是指令系统？为什么要引入指令系统？</h5><p><strong>指令就是要计算机执行某种操作的命令</strong>，一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。</p>
<h5 id="2、一般来说，指令分为哪些部分？每部分有什么用处？"><a href="#2、一般来说，指令分为哪些部分？每部分有什么用处？" class="headerlink" title="2、一般来说，指令分为哪些部分？每部分有什么用处？"></a>2、一般来说，指令分为哪些部分？每部分有什么用处？</h5><p>一条指令通常包括<span style="color:red">操作码字段</span>和<span style="color:red">地址码字段</span>两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。</p>
<h5 id="3、对于一个指令系统来说，寻址方式多和少有什么影响？"><a href="#3、对于一个指令系统来说，寻址方式多和少有什么影响？" class="headerlink" title="3、对于一个指令系统来说，寻址方式多和少有什么影响？"></a>3、对于一个指令系统来说，寻址方式多和少有什么影响？</h5><p>寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章），也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。</p>
<h4 id="4-5-常见问题和易混淆知识点"><a href="#4-5-常见问题和易混淆知识点" class="headerlink" title="4.5 常见问题和易混淆知识点"></a>4.5 常见问题和易混淆知识点</h4><h5 id="1、简述各常见指令寻址方式的特点和适用情况"><a href="#1、简述各常见指令寻址方式的特点和适用情况" class="headerlink" title="1、简述各常见指令寻址方式的特点和适用情况"></a>1、简述各常见指令寻址方式的特点和适用情况</h5><ul>
<li>立即寻址操作数获取便捷，通常用于给寄存器赋初值。</li>
<li>直接寻址相对于立即寻址，缩短了指令长度。</li>
<li>间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。</li>
<li>寄存器寻址的指令字较短，指令执行速度较快。</li>
<li>寄存器间接寻址扩大了寻址范围。</li>
<li>基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。</li>
<li>变址寻址主要用于处理数组问题，适合编制循环程序。</li>
<li>相对寻址用于控制程序的执行顺序、转移等。</li>
<li>基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是<strong>在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的</strong>；而<strong>在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。</strong></li>
</ul>
<h5 id="2、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？"><a href="#2、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？" class="headerlink" title="2、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？"></a>2、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？</h5><p>现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如char、int、foat、 double)可能是8位、16位、32位或64位等，因此可能占用1个、2个、4个或8个内存单元。也就是说，一个操作数可能有多个内存地址对应。<br>有两种不同的地址指定方式：大端方式和小端方式。</p>
<ul>
<li>大端方式：指令中给出的地址是操作数最高有效字节(<strong>MSB</strong>)所在的地址。</li>
<li>小端方式：指令中给出的地址是操作数最低有效字节(<strong>LSB</strong>)所在的地址。</li>
</ul>
<h5 id="3、装入-x2F-存储-Load-x2F-Store-型指令有什么特点？"><a href="#3、装入-x2F-存储-Load-x2F-Store-型指令有什么特点？" class="headerlink" title="3、装入&#x2F;存储(Load&#x2F; Store)型指令有什么特点？"></a>3、装入&#x2F;存储(Load&#x2F; Store)型指令有什么特点？</h5><p><span style="color:red">装入&#x2F;存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格</span>。这种指令风格在RISC指令系统中较为常见。为了规整指令格式，使指令具有相同的长度，规定<strong>只有 Load&#x2F;Store指令才能访问内存</strong>。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。</p>
<p>这种装入&#x2F;存储型风格的指令系统的最大特点是，<strong>指令格式规整，指令长度一致，一般为32位</strong>。由于只有 Load&#x2F;Store 指令オ能访问内存，程序中可能会包含许多装入指令和存储指令，与ー般通用寄存器型指令风格相比，其程序长度会更长。</p>
<h3 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h3><p>【复习提示】<br>中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119195152802.png" alt="在这里插入图片描述"></p>
<h4 id="5-1-CPU的功能和基本构造"><a href="#5-1-CPU的功能和基本构造" class="headerlink" title="5.1 CPU的功能和基本构造"></a>5.1 CPU的功能和基本构造</h4><h5 id="5-1-1-CPU的基本功能"><a href="#5-1-1-CPU的基本功能" class="headerlink" title="5.1.1 CPU的基本功能"></a>5.1.1 CPU的基本功能</h5><p>中央处理器（CPU）由运算器和控制器组成。</p>
<ul>
<li><strong>控制器</strong>的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；</li>
<li><strong>运算器</strong>的功能是对数据进行加工。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119105931494.png" alt="在这里插入图片描述"></p>
<p>CPU的功能：</p>
<ol>
<li>指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</li>
<li>操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</li>
<li>时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</li>
<li>数据加工：对数据进行算术和逻辑运算。</li>
<li>中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119110230138.png" alt="在这里插入图片描述"></p>
<h5 id="5-1-2-CPU的基本结构"><a href="#5-1-2-CPU的基本结构" class="headerlink" title="5.1.2 CPU的基本结构"></a>5.1.2 CPU的基本结构</h5><h5 id="1、运算器"><a href="#1、运算器" class="headerlink" title="1、运算器"></a>1、运算器</h5><ul>
<li>算术逻辑单元（ALU）：主要功能是进行算术&#x2F;逻辑运算。</li>
<li>暂存寄存器：用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。</li>
<li>累加寄存器（ACC）：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</li>
<li>通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</li>
<li>程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。</li>
<li>移位器：对操作数或运算结果进行移位运算。</li>
<li>计数器（CT）：控制乘除运算的操作步数。</li>
</ul>
<blockquote>
<p>通用寄存器供用户自由编程，可以存放数据和地址。而<strong>指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器代替。</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119110727470.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119111049993.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011911131797.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119111607500.png" alt="在这里插入图片描述"></p>
<h5 id="2、控制器"><a href="#2、控制器" class="headerlink" title="2、控制器"></a>2、控制器</h5><p>功能：协调并控制计算机各部件执行程序的指令序列，基本功能如下：</p>
<ul>
<li>分析指令：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址。</li>
<li>执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I&#x2F;O设备完成相应操作</li>
<li>中断处理：管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印字符）。</li>
</ul>
<p>组成：</p>
<ul>
<li><strong>程序计数器PC: 存放下一条指令在主存中的地址，具有自增功能。</strong><span style="color:red">容量：log<del>2</del>存储容量</span></li>
<li>指令寄存器IR：存放当前正在执行的指令。<span style="color:red">容量：指令字长</span></li>
<li>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。</li>
<li>存储器地址寄存器（MAR）。用于存放要访问的主存单元的地址。<span style="color:red">容量：log<del>2</del>存储容量</span></li>
<li>存储器数据寄存器（MDR）。用于存放向主存写入的信息或从主存读出的信息。<span style="color:red">容量：存储字长</span></li>
<li>时序系统。用于产生各种时序信号，它们都由统一时钟（CLOCK）分频得到。</li>
<li>微操作信号发生器。根据IR的内容（指令)、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li>
</ul>
<blockquote>
<p>条件转移指令执行时，需要对<strong>标志寄存器</strong>的内容进行测试，判断是否满足转移条件。<br>转移指令时，需要判断转移是否成功，若成功则PC修改为转移指令的目标地址，否则下一条指令的地址仍然为PC自增后的地址。</p>
</blockquote>
<p>指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119112138911.png" alt="在这里插入图片描述"></p>
<p><span style="color:red"><strong>注意：CPU内部寄存器大致可分为两类：一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组、程序状态字寄存器；另一类是用户不可见的寄存器，对用户是透明的，不可对这类寄存器编程，如存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR。</strong></span></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119112338283.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119112414457.png" alt="在这里插入图片描述"></p>
<h5 id="３、本节知识回顾"><a href="#３、本节知识回顾" class="headerlink" title="３、本节知识回顾"></a>３、本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119112507363.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>用户可见寄存器</strong>：通用寄存器组、程序状态字寄存器、程序计数器；可对这类寄存器编程</li>
<li><strong>用户不可见的寄存器</strong>：存储器地址寄存器、存储器数据寄存器、指令寄存器、暂存寄存器；不可对这类寄存器编程</li>
</ul>
<h4 id="5-2-指令执行过程"><a href="#5-2-指令执行过程" class="headerlink" title="5.2 指令执行过程"></a>5.2 指令执行过程</h4><h5 id="5-2-1-指令周期"><a href="#5-2-1-指令周期" class="headerlink" title="5.2.1 指令周期"></a>5.2.1 指令周期</h5><ul>
<li>指令周期：CPU从主存中取出并执行一条指令的时间称为<strong>指令周期</strong>，不同指令的指令周期可能不同。</li>
<li>机器周期：也称节拍或T周期，指令周期常用若干机器周期来表示，它是<strong>CPU操作的最基本单位</strong>。</li>
<li>时钟周期：一个机器周期包含若干时钟周期。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119124520329.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231120202332853.png" alt="image-20231120202332853"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119125109768.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119125431174.png" alt="在这里插入图片描述"></p>
<h5 id="5-2-2-指令周期的数据流"><a href="#5-2-2-指令周期的数据流" class="headerlink" title="5.2.2 指令周期的数据流"></a>5.2.2 指令周期的数据流</h5><p>1、取指周期</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119125811367.png" alt="在这里插入图片描述"></p>
<p><strong>任务</strong>：取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中</p>
<p>数据流：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2cac7ea6426c6f9d1f4a5ba13f4c05cc.png" alt="image-20230830114154711"></p>
<ul>
<li>PC-①-&gt;MAR-②-&gt;地址总线-③-&gt;主存<ul>
<li>当前指令地址送至存储器地址寄存器，记做：(PC)→ MAR</li>
</ul>
</li>
<li>CU发出读命令-④-&gt;控制总线-⑤-&gt;主存<ul>
<li>CU发出读信号，经控制总线传到主存，记做：1→R</li>
</ul>
</li>
<li>主存-⑥-&gt;数据总线-⑦-&gt;MDR-⑧-&gt;IR (存放指令)<ul>
<li>将MAR所指主存内容经数据总线送入MDR，记做：M(MAR)→MDR</li>
<li>将MDR中的内容（此时是指令）送入IR，记做：(MDR)→IR</li>
</ul>
</li>
<li>CU发出控制信号-⑨-&gt;PC内容加1<ul>
<li>CU发出控制信号，形成下一条指令地址，记做：(PC)+1→PC</li>
</ul>
</li>
</ul>
<p>2、间址周期</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119130156676.png" alt="在这里插入图片描述"></p>
<p><strong>间址周期的作用是取操作数的有效地址</strong>，因此间址周期结束后，MDR的内容为操作数地址。</p>
<p>数据流：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/51024b5592af3d8687f287c106b8e2d3.png" alt="image-20230830114554924"></p>
<ul>
<li>Ad(IR) (或MDR)-①-&gt;MAR-②-&gt;地址总线-③-&gt;主存<ul>
<li>将指令的地址码送入MAR，记做：Ad(IR)→ MAR或Ad(MDR)→ MAR</li>
</ul>
</li>
<li>CU发出读命令-④-&gt;控制总线-⑤-&gt;主存<ul>
<li>CU发出控制信号，启动主存做读操作，记做：1→R</li>
</ul>
</li>
<li>主存-⑥-&gt;数据总线-⑦-&gt;MDR (存放有效地址)<ul>
<li>将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR)→ MDR</li>
<li>将有效地址送至指令的地址码字段，记做：（MDR）→ Ad（IR）</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中，Ad(IR)表示取出IR中存放的指令字的地址字段</p>
</blockquote>
<p>3、执行周期</p>
<p>根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行操作不同，因此没有统一的数据流向。</p>
<p>4、中断周期</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119130702148.png" alt="在这里插入图片描述"></p>
<p><strong>任务</strong>：处理中断请求。暂停当前任务去完成其他任务，为了能够恢复当前任务，需要保存断点。</p>
<p> 一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。</p>
<p>数据流：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/fd53a6a2577867f73e06872dde2907c8.png" alt="image-20230830135138285"></p>
<ul>
<li>CU控制将SP减1，SP-①-&gt;MAR-②-&gt;地址总线-③-&gt;主存<ul>
<li>CU控制将SP减1，修改后的地址送入MAR记做：(SP)-1 → SP，(SP)→ MAR</li>
<li>本质上是将断点存入某个存储单元，假设其地址为a，故可记做：a→MAR</li>
</ul>
</li>
<li>CU发出写命令-④-&gt;控制总线-⑤-&gt;主存<ul>
<li>CU发出控制信号，启动主存做写操作，记做：1→ W</li>
</ul>
</li>
<li>PC-⑥-&gt;MDR-⑦-&gt;数据总线-⑧-&gt;主存 (程序断点存入主存)<ul>
<li>将断点（PC内容）送入MDR，记做：(PC)→ MDR</li>
</ul>
</li>
<li>CU (中断服务程序的入口地址) -⑨-&gt;PC<ul>
<li>CU控制将中断服务程序的入口地址（由向量地址形成部件产生）送入PC，记做：向量地址→PC</li>
</ul>
</li>
</ul>
<h5 id="5-2-3-指令执行方案"><a href="#5-2-3-指令执行方案" class="headerlink" title="5.2.3 指令执行方案"></a>5.2.3 指令执行方案</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119131446274.png" alt="在这里插入图片描述"></p>
<p>一个指令周期通常要包括几个时间段(执行步骤)，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</p>
<p>1）单指令周期</p>
<ul>
<li>特点：对所有指令都选用相同的执行时间来完成，指令之间串行执行。<ul>
<li>指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。</li>
</ul>
</li>
<li>时钟周期：时钟周期取决于执行时间最长的指令的执行时间。<ul>
<li>对于那些本来可以在更短时间内完成的指令，要使用较长的周期来完成，会降低整个系统的运行速度。</li>
</ul>
</li>
</ul>
<p>2）多指令周期</p>
<ul>
<li>特点：对不用类型的指令选用不同的执行步骤来完成，指令之间串行执行。</li>
<li>时钟周期：可选用不同个数的时钟周期来完成不同指令的执行过程，需要更复杂的硬件设计。</li>
</ul>
<p>3）流水线方案</p>
<ul>
<li>特点：指令之间并行执行。</li>
<li>时钟周期：在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。</li>
</ul>
<h5 id="5-2-4-本节知识回顾"><a href="#5-2-4-本节知识回顾" class="headerlink" title="5.2.4 本节知识回顾"></a>5.2.4 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119131809244.png" alt="在这里插入图片描述"></p>
<h4 id="5-3-数据通路的功能和基本结构"><a href="#5-3-数据通路的功能和基本结构" class="headerlink" title="5.3 数据通路的功能和基本结构"></a>5.3 数据通路的功能和基本结构</h4><h5 id="1、数据通路"><a href="#1、数据通路" class="headerlink" title="1、数据通路"></a>1、数据通路</h5><ul>
<li>数据通路：数据在功能部件之间传送的路径。<ul>
<li>数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</li>
</ul>
</li>
<li>构成：包括数据通路上流经的部件，如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。<ul>
<li>数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。</li>
</ul>
</li>
<li>功能：实现CPU内部的运算器与寄存器及寄存器之间的数据交换。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119133221226.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119133339824.png" alt="在这里插入图片描述"></p>
<h5 id="2、数据通路-CPU内部单总线方式"><a href="#2、数据通路-CPU内部单总线方式" class="headerlink" title="2、数据通路-CPU内部单总线方式"></a>2、数据通路-CPU内部单总线方式</h5><ul>
<li><p><strong>内部总线</strong>是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;</p>
</li>
<li><p><strong>系统总线</strong>是指同一台计算机系统的各部件，如CPU、内存、通道和各类l&#x2F;o接口间互相连接的总线。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119135135687.png" alt="在这里插入图片描述"></p>
<h5 id="3、CPU内部单总线方式-例题"><a href="#3、CPU内部单总线方式-例题" class="headerlink" title="3、CPU内部单总线方式-例题"></a>3、CPU内部单总线方式-例题</h5><ul>
<li>1）取指周期</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119140006571.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）间址周期</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119140339151.png" alt="在这里插入图片描述"></p>
<p>实际考试中，建议把间址周期合并到执行周期，因为每个人对间址周期的理解是不一样的。</p>
<ul>
<li>3）执行周期</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119141120865.png" alt="在这里插入图片描述"></p>
<h5 id="4、专用数据通路方式"><a href="#4、专用数据通路方式" class="headerlink" title="4、专用数据通路方式"></a>4、专用数据通路方式</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119151756526.png" alt="在这里插入图片描述"></p>
<ul>
<li>1）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119152318465.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119152404724.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119152635439.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119152835322.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119153049854.png" alt="在这里插入图片描述"></p>
<ul>
<li>6）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119153220468.png" alt="在这里插入图片描述"></p>
<h5 id="5、本节知识回顾"><a href="#5、本节知识回顾" class="headerlink" title="5、本节知识回顾"></a>5、本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231120203905908.png" alt="image-20231120203905908"></p>
<p>注意ALU不是通用寄存器！！！</p>
<h4 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h4><h5 id="5-4-1-控制器的结构和功能"><a href="#5-4-1-控制器的结构和功能" class="headerlink" title="5.4.1 控制器的结构和功能"></a>5.4.1 控制器的结构和功能</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119154106238.png" alt="在这里插入图片描述"></p>
<p>控制器是计算机系统的指挥中心，控制器的主要功能有：</p>
<ul>
<li>1)从主存中取出一条指令，并指出下一条指令在主存中的位置。</li>
<li>2)对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</li>
<li>3)指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119154739341.png" alt="在这里插入图片描述"></p>
<h5 id="5-4-2-硬布线控制器"><a href="#5-4-2-硬布线控制器" class="headerlink" title="5.4.2 硬布线控制器"></a>5.4.2 硬布线控制器</h5><p>1、硬布线控制单元图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119155253622.png" alt="在这里插入图片描述"></p>
<p>2、硬布线控制器的时序及微操作</p>
<p>3、CPU控制方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119155503373.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119155647626.png" alt="在这里插入图片描述"></p>
<p>4、硬布线控制单元设计步骤</p>
<ul>
<li>1）取指阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119160720283.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）间址阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119160842794.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）执行阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119161125769.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119161613254.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）中断阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011916185724.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）组合逻辑设计</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119162208814.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119162312620.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119162600242.png" alt="在这里插入图片描述"></p>
<ul>
<li>6）微操作信号综合</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011916283621.png" alt="在这里插入图片描述"></p>
<ul>
<li>7）逻辑图</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119163108466.png" alt="在这里插入图片描述"></p>
<ul>
<li>8）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231120205027639.png" alt="image-20231120205027639"></p>
<h5 id="5-4-3-微程序控制器"><a href="#5-4-3-微程序控制器" class="headerlink" title="5.4.3 微程序控制器"></a>5.4.3 微程序控制器</h5><p>1、控制器的设计思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119164005442.png" alt="在这里插入图片描述"></p>
<p>2、微程序的基本思想</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119164352577.png" alt="在这里插入图片描述"></p>
<p>3、微程序控制的基本概念</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119171918581.png" alt="在这里插入图片描述"></p>
<p>4、微程序控制组成和工作过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119164726269.png" alt="在这里插入图片描述"></p>
<ul>
<li>控制存储器：它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119165101204.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>微指令寄存器</strong>。用于存放从CM中取出的微指令，它的位数同微指令字长相等</li>
<li><strong>微地址形成部件</strong>。用于产生初始微地址和后维微地址，以保证微指令的连续执行</li>
<li><strong>微地址寄存器</strong>。接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</li>
</ul>
<p>微程序和机器指令：</p>
<p>一条机器指令对应一个微程序。由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p>
<p>5、微指令</p>
<ul>
<li>1）微指令的格式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119165505141.png" alt="在这里插入图片描述"></p>
<p>水平型微指令和垂直型微指令的比较：</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>水平微指令</th>
<th>垂直微指令</th>
</tr>
</thead>
<tbody><tr>
<td>并行能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr>
<td>执行时间</td>
<td>长</td>
<td>长</td>
</tr>
<tr>
<td>微指令字长短</td>
<td>指令字较长；微程序短</td>
<td>微指令字较短；微程序长</td>
</tr>
<tr>
<td>编程难易程度</td>
<td>难</td>
<td>简单</td>
</tr>
</tbody></table>
<ul>
<li>2）微指令的编码方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119165852245.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119170147777.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119170308182.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119170432723.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）微指令的地址形成方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119170635131.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119171544326.png" alt="在这里插入图片描述"></p>
<p>6、微程序控制单元的设计<br>设计步骤：</p>
<ul>
<li>分析每个阶段的微操作序列</li>
<li>写出对应机器指令的微操作命令及节拍安排</li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119172624806.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119172506538.png" alt="在这里插入图片描述"></p>
<p>7、动态微程序设计和毫微程序设计</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119172816851.png" alt="在这里插入图片描述"></p>
<p>8、<strong>硬布线和微程序控制器的特点</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119173018709.png" alt="在这里插入图片描述"></p>
<p>9、本节知识回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119173221780.png" alt="在这里插入图片描述"></p>
<p>10、一些易混淆的概念</p>
<blockquote>
<p><strong>指令&#x3D;微程序</strong></p>
<p><strong>微程序由多个微指令组成</strong></p>
<p><strong>微指令由多个微命令组成</strong></p>
<p><strong>微命令是微操作的控制信号</strong></p>
<p><strong>微操作是微命令的执行过程</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/80814de282fdac2d673542871ec8dd51.png" alt="image-20220205135623551"></p>
<h4 id="5-5-指令流水线"><a href="#5-5-指令流水线" class="headerlink" title="5.5 指令流水线"></a>5.5 指令流水线</h4><h5 id="5-5-1-指令流水的基本概念"><a href="#5-5-1-指令流水的基本概念" class="headerlink" title="5.5.1 指令流水的基本概念"></a>5.5.1 指令流水的基本概念</h5><p>可从两方面提高处理机的并行性：</p>
<ol>
<li><strong>时间上的并行技术</strong>，将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为<strong>流水线技术</strong>。</li>
<li><strong>空间上的并行技术</strong>，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为<strong>超标量处理机</strong>。</li>
</ol>
<ul>
<li>1）指令流水线的定义</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119185445548.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119185834152.png" alt="在这里插入图片描述"></p>
<p> 一条指令的执行过程可以分为以下5个阶段：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
<strong>取指（IF）</strong>：从指令存储器或Cache 中取指令。</p>
</li>
<li><p><input disabled="" type="checkbox"> 
<strong>译码&#x2F;读寄存器（ID）</strong>：操作控制器对指令进行译码，同时从寄存器堆中取操作数。</p>
</li>
<li><p><input disabled="" type="checkbox"> 
**执行&#x2F;计算地址（EX)**：执行运算操作或计算地址。</p>
</li>
<li><p><input disabled="" type="checkbox"> 
<strong>访存（MEM）</strong>：对存储器进行读写操作。</p>
</li>
<li><p><input disabled="" type="checkbox"> 
<strong>写回（WB）</strong>：将指令执行结果写回寄存器堆。</p>
<p>把k+1条指令的取指阶段提前到第k条指令的译码阶段，从而将第k+1条指令的译码阶段与第k条指令的执行阶段同时进行，如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/5283ea64f3a6216ac9a19934a4231a4d.png" alt="image-20230830173454362"></p>
</li>
</ul>
<p>理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即CPI）都为1。</p>
<p>为了利于实现指令流水线，指令集应具有如下特征：</p>
<ol>
<li>指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不一，使取指部件极其复杂，且也不利于指令译码。</li>
<li>指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。</li>
<li><strong>采用Load&#x2F;Store指令，其他指令都不能访问存储器</strong>，这样可把Load&#x2F;Store指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。</li>
<li><strong>数据和指令在存储器中“对齐”存放</strong>。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。</li>
</ol>
<ul>
<li>2）流水线的表示方法</li>
</ul>
<p>通常用时空图来直观地描述流水线的执行情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119190342616.png" alt="在这里插入图片描述"></p>
<p>在时空图中，横坐标表示时间，它被分割成长度相等的时间段T；纵坐标为空间，表示当前指令所处的功能部件。</p>
<blockquote>
<p> 只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，非常适合采用流水线技术。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的。</p>
</blockquote>
<ul>
<li><p>3）流水线的性能指标</p>
<ul>
<li>吞吐率</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119190735588.png" alt="在这里插入图片描述"></p>
<ul>
<li>加速比</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119190859710.png" alt="在这里插入图片描述"></p>
<ul>
<li>效率</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119191114548.png" alt="在这里插入图片描述"></p>
</li>
<li><p>4）机器周期的设置</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119191538491.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119191305725.png" alt="在这里插入图片描述"></p>
<h5 id="5-5-2-影响流水线的因素"><a href="#5-5-2-影响流水线的因素" class="headerlink" title="5.5.2 影响流水线的因素"></a>5.5.2 影响流水线的因素</h5><p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为流水线冒险。</p>
<ul>
<li>1）结构相关（资源冲突）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021011919174694.png" alt="在这里插入图片描述"></p>
<p>解决办法：</p>
<ol>
<li>前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</li>
<li>资源重复配置：单独设置<strong>数据存储器</strong>和<strong>指令存储器</strong>，使取数和取指令操作各自在不同的存储器中进行。</li>
</ol>
<ul>
<li>2）数据相关（数据冲突）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119192228295.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119192625138.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119193034304.png" alt="在这里插入图片描述"></p>
<p>在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令发生数据冲突。</p>
<ol>
<li><strong>写后读（ReadAfterWrite，RAW）相关</strong>：表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误（旧）数据。</li>
<li><strong>读后写（WriteAfterRead，WAR）相关</strong>：表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。</li>
<li><strong>写后写（WriteAfterWrite，WAW）相关</strong>：表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值</li>
</ol>
<p>解决办法：</p>
<ol>
<li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。<ul>
<li>可分为硬件阻塞(stall) 和软件插入“NOP”两种方法。</li>
</ul>
</li>
<li>数据旁路技术（转发机制）：从执行阶段结果出来后送回ALU输入端。</li>
<li>编译优化：通过编译器调整指令顺序来解决数据相关。</li>
</ol>
<ul>
<li>3）控制相关（控制冲突）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119193257802.png" alt="在这里插入图片描述"></p>
<p>当流水线遇到转移指令和其他改变PC值的指令，必需等待分支处理结果而造成断流时，会引起控制相关。</p>
<p>解决办法：</p>
<ol>
<li>转移指令分支预测。简单预测（永远猜ture或false）、动态预测（根据历史情况动态调整）</li>
<li>预取转移成功和不成功两个控制流方向上的目标指令</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向的猜准率</li>
</ol>
<ul>
<li>4）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119193414445.png" alt="在这里插入图片描述"></p>
<h5 id="5-5-3-流水线的分类"><a href="#5-5-3-流水线的分类" class="headerlink" title="5.5.3 流水线的分类"></a>5.5.3 流水线的分类</h5><p>1、部件功能级、处理机级和处理机间级流水线</p>
<ul>
<li>根据流水线使用的级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</li>
<li>部件功能级流水就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。</li>
<li>处理机级流水是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回5个子过程。</li>
<li>处理机间流水是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。</li>
</ul>
<p>2、单功能流水线和多功能流水线</p>
<ul>
<li>按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线；</li>
<li>单功能流水线指只能实现一种固定的专门功能的流水线；</li>
<li>多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</li>
</ul>
<p>3、动态流水线和静态流水线</p>
<ul>
<li>按同一时间内各段之问的连接方式，流水线可分为静态流水线和动态流水线。</li>
<li>静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</li>
</ul>
<p>4、线性流水线和非线性流水线</p>
<ul>
<li>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</li>
<li>线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li>
<li>作线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</li>
</ul>
<h5 id="5-5-4-超标量流水线的基本概念"><a href="#5-5-4-超标量流水线的基本概念" class="headerlink" title="5.5.4 超标量流水线的基本概念"></a>5.5.4 超标量流水线的基本概念</h5><p>1、超标量流水技术</p>
<p>也称动态多发射技术，<strong>每个时钟周期内可并发多条独立指令</strong>，以并行操作方式将两条或多条指令编译并执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119194250666.png" alt="在这里插入图片描述"></p>
<p>2、超流水技术</p>
<p>在流水线一个时钟周期再划分多个功能段，通过提高流水线主频的方式来提升流水线性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119194432988.png" alt="在这里插入图片描述"></p>
<p>但是流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。</p>
<ul>
<li>超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令，CPI&#x3D;1，但其主频更高；</li>
<li>多发射流水线CPU每个时钟周期可以处理多条指令，CPI&lt;1，相对而言，多发射流水线成本更高，控制更复杂。</li>
</ul>
<p>3、超长指令字技术</p>
<p>也称静态多发射技术，由编译程序挖掘出指令间<strong>潜在的并行性</strong>，将多条<strong>能并行操作的指令</strong>组合成<strong>一条具有多个操作码字段</strong>的超长指令字（可达几百位），为此需要采用多个处理部件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119194552962.png" alt="在这里插入图片描述"></p>
<p>4、本节知识回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119194647396.png" alt="在这里插入图片描述"></p>
<h4 id="5-6-异常和中断机制"><a href="#5-6-异常和中断机制" class="headerlink" title="5.6 异常和中断机制"></a>5.6 异常和中断机制</h4><h5 id="5-6-1-异常和中断的基本概念"><a href="#5-6-1-异常和中断的基本概念" class="headerlink" title="5.6.1 异常和中断的基本概念"></a>5.6.1 异常和中断的基本概念</h5><p>1）异常：<strong>由CPU内部产生的意外事件被称为异常，有些教材中也称内中断。</strong></p>
<ul>
<li>是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件。</li>
</ul>
<p>2）中断：<strong>由来自CPU外部的设备向CPU发出的中断请求被称为中断</strong>，通常用于信息的输入和输出，有些教材中也称外中断。</p>
<ul>
<li>是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。</li>
</ul>
<h5 id="5-6-2-异常和中断的分类"><a href="#5-6-2-异常和中断的分类" class="headerlink" title="5.6.2 异常和中断的分类"></a>5.6.2 异常和中断的分类</h5><p>1）异常的分类</p>
<ul>
<li><p>故障（Fault）</p>
<ul>
<li>定义：指在引起故障的指令启动后、执行结束前被检测到的异常事件。</li>
<li>例：指令译码时，出现“<strong>非法操作码</strong>”；取数据时，发生<strong>“缺段”或“缺页”<strong>；执行整数除法指令时，发现“</strong>除数为0</strong>”等。</li>
<li>处理：内核程序修复后会把CPU使用权还给应用程序，让它继续执行。（如缺页中断）</li>
<li>对于“非法操作码”和“除数为0”等，因为无法通过异常处理恢复故障，必需终止程序。</li>
</ul>
</li>
<li><p>自陷（Trap）</p>
<ul>
<li><p>定义：也称陷阱或陷入，它是<strong>预先安排</strong>的一种“异常”事件，就像预先设定的“陷阱”一样。</p>
</li>
<li><p>例：“断点调试”、单步跟踪、系统调用</p>
</li>
<li><p>处理：CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p>
<blockquote>
<p>故障和自陷异常属于软件中断（程序性异常）；终止和外中断属于硬件中断。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>终止（Abort）</p>
<ul>
<li>定义：由致命错误起，内核程序无法修复该错误，一股直接终止该应用程序。</li>
<li>例：如控制器出错、存储器校验错误、总线错误等；此时，只能调出中断服务程序来重启系统。</li>
</ul>
</li>
</ul>
<p>2）中断的分类</p>
<p>中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括IO设备发出的IO中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按Esc键、定时器计数时间到）等。</p>
<p>外部I&#x2F;O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。</p>
<ul>
<li>可屏蔽中断<ul>
<li>指通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU。</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件。</li>
</ul>
</li>
</ul>
<p>3）中断和异常的不同点</p>
<ul>
<li>“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</li>
<li>异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。</li>
</ul>
<h5 id="5-6-3-异常和中断响应过程"><a href="#5-6-3-异常和中断响应过程" class="headerlink" title="5.6.3 异常和中断响应过程"></a>5.6.3 异常和中断响应过程</h5><p>CPU对异常和中断响应的过程可分为：关中断、保存断点和程序状态、识别异常和中断并转到相应的处理程序。</p>
<p>1）关中断</p>
<p>在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。</p>
<p>通常通过设置“中断允许”（IF）触发器来实现，</p>
<ul>
<li>若IF置为1，则为开中断，表示允许响应中断；</li>
<li>若IF置为0，则表示关中断，表示不允许响应中断。</li>
</ul>
<p>2）保存断点和程序状态</p>
<p>为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这是为了支持异常或中断的嵌套。</p>
<p>异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器PSWR的内容也需要保存在栈或特定寄存器中，<strong>在异常和中断返回时恢复到PSWR中</strong>。</p>
<p>3）识别异常和中断并转到相应的处理程序</p>
<p>异常和中断源的识别有软件识别和硬件识别两种方式。</p>
<ul>
<li>软件识别方式是指CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。</li>
<li>硬件识别方式又称<strong>向量中断</strong>，<strong>异常或中断处理程序的首地址称为中断向量</strong>，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。</li>
</ul>
<h4 id="5-7-多处理器的基本概念"><a href="#5-7-多处理器的基本概念" class="headerlink" title="5.7 多处理器的基本概念"></a>5.7 多处理器的基本概念</h4><h5 id="5-7-1-SISD、SIMD、MIMD的基本概念"><a href="#5-7-1-SISD、SIMD、MIMD的基本概念" class="headerlink" title="5.7.1 SISD、SIMD、MIMD的基本概念"></a>5.7.1 SISD、SIMD、MIMD的基本概念</h5><p>1、单指令流单数据流（SISD）结构</p>
<ul>
<li>特性：在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令。</li>
<li>各指令序列只能并发、不能并行，每条指令处理一两个数据；不是数据级并行技术。</li>
<li>硬件构成：传统的串行计算机结构，一个处理器和一个存储器；若采用指令流水线，需设置多个功能部件，采用多模块交叉存储器。</li>
</ul>
<blockquote>
<p> 前面介绍的内容多属于SISD结构</p>
</blockquote>
<p>2、单指令流多数据流（SIMD）结构</p>
<ul>
<li>特性：一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。</li>
<li>各指令序列只能并发、不能并行，但每条指令可同时处理很多个具有相同特征的数据。</li>
<li>硬件组成：一个指令控制部件(CU)+多个处理单元&#x2F;执行单元(如ALU)+多个局部存储器+一个主存储器。</li>
<li>每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，这样每个单元就都有不同的数据地址。不同处理单元执行的<strong>同一条指令所处理的不同数据</strong>。</li>
</ul>
<blockquote>
<p>SIMD在使用for循环处理数组时最有效，比如，一条分别对16对数据进行运算的SIMD指令，如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算。</p>
<p>SIMD在使用case或switch语句时效率最低，此时<strong>每个执行单元必须根据不同的数据执行不同的操作</strong>。</p>
</blockquote>
<p>3、多指令流单数据流（MISD）结构</p>
<ul>
<li>多条指令并行执行，处理同一个数据。现实中<strong>不存在</strong>这种计算机。</li>
</ul>
<p>4、多指令流多数据流（MIMD）结构</p>
<p>MIMD是指同时执行多条指令分别处理多个不同的数据，MIMD分为<strong>多计算机系统</strong>和<strong>多处理器系统</strong>。</p>
<ul>
<li>特性：各指令序列并行执行，分别处理多个不同的数据；是一种线程级并行、甚至是线程级以上并行技术。</li>
<li>多计算机系统<ul>
<li>特性：各计算机之间，不能通过存取指令直接访问对方的存储器，只能通过“消息传递”相互传送数据</li>
<li>硬件组成：由多台计算机组成，因此拥有多个处理器+多个主存储器；每台计算机拥有各自的私有存储器，物理地址空间相互独立。</li>
</ul>
</li>
<li>多处理器系统<ul>
<li>特性：各处理器之间，可以通过存取指令，访问同一个主存储器，可通过主存相互传送数据。</li>
<li>硬件组成：一台计算机内，包含多个处理器+一个主存储器；多个处理器共享单一的物理地址空间。</li>
</ul>
</li>
</ul>
<p>5、向量处理器：向量处理器是SIMD的变体，是一种实现了<strong>直接操作一维数组（向量）</strong>指令集的CPU，而串行处理器只能处理单一数据集。</p>
<ul>
<li>基本理念：将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。</li>
<li>向量处理器在特定工作环境中极大地提升了性能，擅长对向量型数据并行计算、浮点数运算，常被用于超级计算机中，处理科学研究中巨大运算量。</li>
<li>硬件组成：多个处理单元，多组“向量寄存器”；主存储器应采用“多个端口同时读取”的交叉多模块存储器；主存储器大小限定了机器的解题规模，因此要有大容量的、集中式的主存储器。</li>
</ul>
<h5 id="5-7-2-硬件多线程的基本概念"><a href="#5-7-2-硬件多线程的基本概念" class="headerlink" title="5.7.2 硬件多线程的基本概念"></a>5.7.2 硬件多线程的基本概念</h5><p>为了减少线程切换过程中的开销，便诞生了硬件多线程。在支持硬件多线程的CPU中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。</p>
<blockquote>
<p>硬件多线程有3种实现方式：细粒度多线程、粗粒度多线程和同时多线程（SMT)。</p>
</blockquote>
<p>1、细粒度多线程</p>
<ul>
<li>多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。</li>
<li>处理器能在每个时钟周期切换线程。</li>
</ul>
<p>2、粗粒度多线程</p>
<ul>
<li>仅在一个线程出现了较大开销的阻塞时，才切换线程，如Cache 缺失。</li>
<li>阻塞时，新线程的指令开始执行前需要重载流水线，线程切换的开销比细粒度多线程更大。</li>
</ul>
<p>3、同时多线程</p>
<ul>
<li>同时多线程（SMT）在同一个时钟周期中，发射多个不同线程中的多条指令执行。</li>
<li>Intel 处理器中的超线程（Hyper-threading）就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>细粒度多线程</strong></th>
<th><strong>细粒度多线程</strong></th>
<th><strong>同时多线程（SMT)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>指令发射</td>
<td>各个时钟周期，轮流发射多个线程的指令</td>
<td>连续几个时钟周期，都发射同一线程的指令序列，流水线阻塞时，切换另一个线程</td>
<td>一个时钟周期内，同时发射多个线程的搭令</td>
</tr>
<tr>
<td>一个时钟周期内，同时发射多个线程的搭令</td>
<td>每个时钟周期切换一次线程</td>
<td>只有流水线阻塞时才切换一次线程</td>
<td></td>
</tr>
<tr>
<td>线程切换代价</td>
<td>低</td>
<td>高，需要重载流水线</td>
<td></td>
</tr>
<tr>
<td>并行性</td>
<td>高，需要重载流水线</td>
<td>指令级并行，线程间不并行</td>
<td>指令级并行，线程级并行</td>
</tr>
</tbody></table>
<p>三种硬件多线程方式的调度示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/47f9c0f2b87f8ba5cbc857d895f6cfdd.png" alt="image-20230831135511333"></p>
<h5 id="5-7-3-多核处理器的基本概念"><a href="#5-7-3-多核处理器的基本概念" class="headerlink" title="5.7.3 多核处理器的基本概念"></a>5.7.3 多核处理器的基本概念</h5><p>多核处理器是指将多个处理单元集成到单个CPU中，每个处理单元称为一个核（core)。</p>
<p>每个核可以有自己的Cache,也可以共享同一个Cacheo所有核一般都是对称的，并且共享主存储器，因此多核属于共享存储的对称多处理器。下图是不共享Cache的双核CPU结构。</p>
<ul>
<li>在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程（或多进程）执行，使得每个核在同一时刻都有线程在执行。</li>
<li>多核上的多个线程是在<strong>物理上并行执行</strong>的，是真正意义上的并行执行，在<strong>同一时刻有多个线程在并行执行</strong>。而单核上的多线程是一 种<strong>并发的多线程交错执行</strong>，实际上在<strong>同一时刻只有一个线程在执行</strong>。</li>
</ul>
<h5 id="5-7-4-共享内存多处理器的基本概念"><a href="#5-7-4-共享内存多处理器的基本概念" class="headerlink" title="5.7.4 共享内存多处理器的基本概念"></a>5.7.4 共享内存多处理器的基本概念</h5><p>1、定义</p>
<ul>
<li>具有共享的单一物理地址空间的多处理器被称为共享内存多处理器（SMP)。</li>
<li>处理器通过存储器中的<strong>共享变量互相通信</strong>，所有处理器都能通过存取指令访问任何存储器的位置。注意，即使这些系统<strong>共享同一个物理地址空间</strong>，它们仍然可在自己的虚拟地址空间中单独地运行程序。</li>
</ul>
<p>2、分类</p>
<ul>
<li>统一存储访问（UMA）多处理器<ul>
<li>定义：每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。</li>
<li>结构：CPU通过前端总线和北桥芯片相连，越来越多的CPU对前端总线的争用使得前端总线成为瓶颈。</li>
<li>分类：根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。</li>
</ul>
</li>
<li>非统一存储访问（NUMA）多处理器<ul>
<li>定义：某些访存请求要比其他的快，具体取决于哪个处理器提出了访问请求以及访问哪个字，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器。</li>
<li>结构：内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器。每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为本地内存。</li>
<li>分类：处理器中不带高速缓存时，被称为NC-NUMA；处理器中带有一致性高速缓存时，被称为CC-NUMA。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在NUMA架构下，内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存。</p>
</blockquote>
<h4 id="5-8-本章提出的问题与回答"><a href="#5-8-本章提出的问题与回答" class="headerlink" title="5.8 本章提出的问题与回答"></a>5.8 本章提出的问题与回答</h4><h5 id="1、CPU分为哪几部分？分别实现什么功能？"><a href="#1、CPU分为哪几部分？分别实现什么功能？" class="headerlink" title="1、CPU分为哪几部分？分别实现什么功能？"></a>1、CPU分为哪几部分？分别实现什么功能？</h5><p><span style="color:red">CPU分为运算器和控制器</span>。其中运算器主要负责数据的加工，即对数据进行算术和逻辑运算控制器是整个系统的指挥中枢，对整个计算机系统进行有效的控制，包括指令控制、操作控制、时间控制和中断处理。</p>
<h5 id="2、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？"><a href="#2、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？" class="headerlink" title="2、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？"></a>2、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？</h5><ul>
<li>从时间上讲，<span style="color:red">取指令事件发生在“取指周期”，取数据事件发生在“执行周期”</span>。</li>
<li>从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）。</li>
</ul>
<h5 id="3、什么是指令周期、机器周期和时钟周期？它们之间有何关系？"><a href="#3、什么是指令周期、机器周期和时钟周期？它们之间有何关系？" class="headerlink" title="3、什么是指令周期、机器周期和时钟周期？它们之间有何关系？"></a>3、什么是指令周期、机器周期和时钟周期？它们之间有何关系？</h5><p><span style="color:red">CPU每取出并执行一条指令所需的全部时间称为指令周期</span>；机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排<strong>机器周期长度&#x3D;主存周期</strong>；时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常<strong>时钟周期&#x3D;计算机主频的倒数</strong>。</p>
<h5 id="4、指令周期是否有一个固定值？为什么？"><a href="#4、指令周期是否有一个固定值？为什么？" class="headerlink" title="4、指令周期是否有一个固定值？为什么？"></a>4、指令周期是否有一个固定值？为什么？</h5><p>由于计算机中各种指令执行所需的时间差异很大，因此为了提高CPU的运行效率，即使在同步控制的机器中，<span style="color:red">不同指令的指令周期长度都是不一致的，即指令周期对不同的指令来说不是个固定值</span>。</p>
<h5 id="5、什么是微指令？它和第4章谈到的指令有什么关系？"><a href="#5、什么是微指令？它和第4章谈到的指令有什么关系？" class="headerlink" title="5、什么是微指令？它和第4章谈到的指令有什么关系？"></a>5、什么是微指令？它和第4章谈到的指令有什么关系？</h5><p>控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为<strong>微命令</strong>，而一组实现一定操作功能的微命令的组合，构成一条<strong>微指令</strong>。许多条微指令组成的序列构成<strong>微程序</strong>，微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。<span style="color:red">在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令</span>。</p>
<h5 id="6、什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？"><a href="#6、什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？" class="headerlink" title="6、什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？"></a>6、什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？</h5><ul>
<li>指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种<strong>并行处理技术</strong>，通过在同一个时间段使用各功能部件，使得利用率明显提高。</li>
<li>流水线的加速比指的是完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。一条k段流水线理论上的最大加速比为S<del>max</del>&#x3D; k。因此，在现代计算机中提高流水线段数有利于提高计算机的吞吐量。具体的加速比要使用<strong>时空图</strong>来计算。</li>
</ul>
<h4 id="5-9-常见问题和易混淆知识点"><a href="#5-9-常见问题和易混淆知识点" class="headerlink" title="5.9 常见问题和易混淆知识点"></a>5.9 常见问题和易混淆知识点</h4><h5 id="1、流水线越多，并行度就越高。是否流水段越多，指令执行越快？"><a href="#1、流水线越多，并行度就越高。是否流水段越多，指令执行越快？" class="headerlink" title="1、流水线越多，并行度就越高。是否流水段越多，指令执行越快？"></a>1、流水线越多，并行度就越高。是否流水段越多，指令执行越快？</h5><p>错误，因为如下：</p>
<ul>
<li>1)<span style="color:red">流水段缓冲之间的额外开销增大</span>。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。</li>
<li>2)<span style="color:red">流水段间控制逻辑变多、变复杂</span>。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。</li>
</ul>
<h5 id="2、有关指令相关、数据相关的几个概念"><a href="#2、有关指令相关、数据相关的几个概念" class="headerlink" title="2、有关指令相关、数据相关的几个概念"></a>2、有关指令相关、数据相关的几个概念</h5><ul>
<li>1)两条连续的指令读取相同的寄存器时，会产生<strong>读后读( Read After Read,RAR)相关</strong>，这种相关不会影响流水线。</li>
<li>2)某条指令要读取上一条指令所写入的寄存器时，会产生<strong>写后读( Read After Write,RAW)相关</strong>，它称数据相关或真相关，影响流水线。按序流动的流水线只可能出现RAW相关。</li>
<li>3)某条指令的上条指令要读&#x2F;写该指令的输出寄存器时，会产生**读后写（ Write After Read,WAR)<strong>和</strong>写后写( Write After Write,WAW)**相关。在非按序流动的流水线中，既可能发生RAW相关，又可能发生WAR相关和WAW相关。</li>
</ul>
<p><span style="color:red"><strong>对流水线影响最严重的指令相关是数据相关。</strong></span></p>
<h3 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h3><p>【复习提示】<br>本章的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119200448840.png" alt="在这里插入图片描述"></p>
<h4 id="6-1-总线的概述"><a href="#6-1-总线的概述" class="headerlink" title="6.1 总线的概述"></a>6.1 总线的概述</h4><h5 id="6-1-1-总线基本概念"><a href="#6-1-1-总线基本概念" class="headerlink" title="6.1.1 总线基本概念"></a>6.1.1 总线基本概念</h5><p>1、总线的定义</p>
<p>总线是一组能为多个部件分时共享的公共信息传送线路。</p>
<ul>
<li><strong>分时</strong>：指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。</li>
<li><strong>共享</strong>：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息。</li>
</ul>
<p>2、总线设备</p>
<p>总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。</p>
<ul>
<li><strong>主设备</strong>：指获得总线控制权的设备。</li>
<li><strong>从设备</strong>：指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。</li>
</ul>
<p>3、总线的特点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120081324146.png" alt="在这里插入图片描述"></p>
<p>4、总线的特性</p>
<ul>
<li>机械特性：尺寸、形状、管脚数、排列顺序</li>
<li>电气特性：传输方向和有效的电平范围</li>
<li>功能特性：每根传输线的功能(地址、数据、控制)</li>
<li>时间特性：信号的时序关系</li>
</ul>
<h5 id="6-1-2-总线的分类"><a href="#6-1-2-总线的分类" class="headerlink" title="6.1.2 总线的分类"></a>6.1.2 总线的分类</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120082438589.png" alt="在这里插入图片描述"></p>
<p>1、按数据传输格式分类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120082335300.png" alt="在这里插入图片描述"></p>
<p>2、按总线的功能分类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120083119763.png" alt="在这里插入图片描述"></p>
<ul>
<li>系统总线详解</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120082941849.png" alt="在这里插入图片描述"></p>
<ol>
<li><strong>数据总线</strong>：用来传输各功能部件之间的数据信息，它是<strong>双向传输总线</strong>，其位数与<strong>机器字长、存储字长</strong>有关。</li>
<li><strong>地址总线</strong>：用来指出数据总线上的源数据或目的数据所在的主存单元或I&#x2F;O端口的地址，它是<strong>单向传输总线</strong>，地址总线的位数与主存地址空间的大小有关。</li>
<li><strong>控制总线</strong>：传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。</li>
</ol>
<blockquote>
<p>注意区分<strong>数据通路</strong>和<strong>数据总线</strong>：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。</p>
<p>数据通路表示的是数据流经的路径，而数据总线是承载的媒介。</p>
</blockquote>
<p>I&#x2F;O总线</p>
<p>I&#x2F;O总线主要用于连接中低速的I&#x2F;O设备，通过I&#x2F;O接口与系统总线相连接，目的是将低速设备与高速总线分离，以提升总线的系统性能，常见的有USB、PCI总线。</p>
<p>通信总线</p>
<p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。</p>
<blockquote>
<p>此外，按时序控制方式可将总线划分为<strong>同步总线</strong>和<strong>异步总线</strong>，还可按数据传输格式将总线划分为<strong>并行总线</strong>和<strong>串行总线</strong>。</p>
</blockquote>
<p>3、系统总线的结构</p>
<ul>
<li>1）单总线结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012008335890.png" alt="在这里插入图片描述"></p>
<p>单总线结构将CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）都挂在一组总线上，允许I&#x2F;O设备之间、I&#x2F;O设备与主存之间直接交换信息。</p>
<p>CPU与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p>
<blockquote>
<p>注意：单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</p>
</blockquote>
<ul>
<li>2）双总线结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120083732931.png" alt="在这里插入图片描述"></p>
<p>双总线结构有两条总线：一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是I&#x2F;O总线，用于在多个外部设备与通道之间传送数据。</p>
<blockquote>
<p>通道：通道是具有特殊功能的处理器，能对I&#x2F;O设备进行统一管理，通道程序放在主存中。</p>
<p>支持<strong>突发（猝发）传送</strong>，<span style="color:red">即送出一个地址，收到多个地址连续的数据。</span></p>
<p>局部总线：连接计算机硬件系统的某一个子系统或部分部件的总线，这样可将一些高速外设，如图形卡，硬盘控制器等状系统总线上卸下而通过局部总线直接挂接。</p>
</blockquote>
<ul>
<li>3）三总线结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120083918649.png" alt="在这里插入图片描述"></p>
<p>三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为主存总线、I&#x2F;O总线和直接内存访问（DMA）总线。</p>
<blockquote>
<p>DMA：Direct Memory Access，直接内存访问。</p>
</blockquote>
<ul>
<li>4）四总线结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120084056105.png" alt="在这里插入图片描述"></p>
<p>4、本节知识回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120084407305.png" alt="在这里插入图片描述"></p>
<h5 id="6-1-3-总线的性能指标"><a href="#6-1-3-总线的性能指标" class="headerlink" title="6.1.3 总线的性能指标"></a>6.1.3 总线的性能指标</h5><ol>
<li><p>总线的传输周期（总线周期）</p>
<p>一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</p>
</li>
<li><p>总线时钟周期</p>
<p>即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p>
</li>
<li><p>总线工作频率</p>
<p>总线上各种操作的频率，为总线周期的倒数。实际上指一秒内传送几次数据。</p>
</li>
<li><p>总线的时钟频率</p>
<p>即机器的时钟频率，为时钟周期的倒数。实际上指一秒内有多少个时钟周期。</p>
</li>
<li><p>总线宽度</p>
<p>又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位总线。</p>
</li>
<li><p>总线带宽</p>
<p>可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节&#x2F;秒（B&#x2F;s）表示。</p>
</li>
<li><p>总线复用</p>
<p>总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。</p>
</li>
<li><p>信号线数</p>
<p><strong>地址总线、数据总线和控制总线3种总线数的总和称为信号线数</strong>。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120085029526.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120085417624.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120090406298.png" alt="在这里插入图片描述"></p>
<ul>
<li>带宽例题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120090024262.png" alt="在这里插入图片描述"></p>
<ul>
<li>串行总线和并行总线哪个速度更快</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120090218707.png" alt="在这里插入图片描述"></p>
<p><strong>本节知识回顾</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012009044716.png" alt="在这里插入图片描述"></p>
<h4 id="6-2-总线仲裁"><a href="#6-2-总线仲裁" class="headerlink" title="6.2 总线仲裁"></a>6.2 总线仲裁</h4><h5 id="6-2-1-总线仲裁的基本概念"><a href="#6-2-1-总线仲裁的基本概念" class="headerlink" title="6.2.1 总线仲裁的基本概念"></a>6.2.1 总线仲裁的基本概念</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120090841429.png" alt="在这里插入图片描述"></p>
<h5 id="6-2-2-集中仲裁方式"><a href="#6-2-2-集中仲裁方式" class="headerlink" title="6.2.2 集中仲裁方式"></a>6.2.2 集中仲裁方式</h5><ul>
<li>1）链式查询方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120091731942.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）计数器查询方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012009211387.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）独立请求方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120092416938.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120092456227.png" alt="在这里插入图片描述"></p>
<h5 id="6-2-3-分布仲裁方式"><a href="#6-2-3-分布仲裁方式" class="headerlink" title="6.2.3 分布仲裁方式"></a>6.2.3 分布仲裁方式</h5><p>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</p>
<ul>
<li>当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上；</li>
<li>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；</li>
<li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上。</li>
</ul>
<h4 id="6-3-总线操作和定时"><a href="#6-3-总线操作和定时" class="headerlink" title="6.3 总线操作和定时"></a>6.3 总线操作和定时</h4><h5 id="6-3-1-总线传输的四个阶段"><a href="#6-3-1-总线传输的四个阶段" class="headerlink" title="6.3.1 总线传输的四个阶段"></a>6.3.1 总线传输的四个阶段</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120092959621.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>突发（猝发）传送方式</strong>能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。</p>
</blockquote>
<h5 id="6-3-2-同步定时方式（同步通信）"><a href="#6-3-2-同步定时方式（同步通信）" class="headerlink" title="6.3.2 同步定时方式（同步通信）"></a>6.3.2 同步定时方式（同步通信）</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120093356624.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/202101200932152.png" alt="在这里插入图片描述"></p>
<h5 id="6-3-3-异步定时方式（异步通信）"><a href="#6-3-3-异步定时方式（异步通信）" class="headerlink" title="6.3.3 异步定时方式（异步通信）"></a>6.3.3 异步定时方式（异步通信）</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120094049852.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120093928801.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120094337814.png" alt="在这里插入图片描述"></p>
<h5 id="6-3-4-半同步通信"><a href="#6-3-4-半同步通信" class="headerlink" title="6.3.4 半同步通信"></a>6.3.4 半同步通信</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120095701690.png" alt="在这里插入图片描述"></p>
<h5 id="6-3-5-分离式通信"><a href="#6-3-5-分离式通信" class="headerlink" title="6.3.5 分离式通信"></a>6.3.5 分离式通信</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012009592410.png" alt="在这里插入图片描述"></p>
<h5 id="6-3-6-本节知识回顾"><a href="#6-3-6-本节知识回顾" class="headerlink" title="6.3.6 本节知识回顾"></a>6.3.6 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120100027820.png" alt="在这里插入图片描述"></p>
<h4 id="6-4-总线标准"><a href="#6-4-总线标准" class="headerlink" title="6.4 总线标准"></a>6.4 总线标准</h4><p>总线标准的基本概念：</p>
<ul>
<li>总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。</li>
<li><strong>系统总线</strong>标准：ISA、EISA、VESA、PCI、PCI- Express等。</li>
<li>设备总线标准：IDE、AGP、RS-232C、USB、SATA、SCSI、 PCMCIA等。</li>
<li><strong>局部总线</strong>标准：在ISA总线和CPU总线之间增加的一级总线或管理层，如PCI、PCI-E、VESA、AGP等，可以节省系统的总带宽。</li>
<li>**即插即用( Plug-and-Play)**的作用是自动配置（低层）计算机中的板卡和其他设备，然后告诉对应的设备都做了什么。把物理设备和软件（设备驱动程序）相配合，并操作设备，在每个设备和它的驱动程序之间建立通信信道</li>
<li><strong>热插拔( hot-plugging或 Hot Swap)即带电插拔</strong>，热插拔功能就是允许用户在不关闭系统，不切断电源的情况下取出和更换损坏的硬盘、电源或板卡等部件，从而提高了系统对灾难的及时恢复能力、扩展性和灵活性等，例如一些面向高端应用的磁盘镜像系统都可以提供磁盘的热插拔功能。</li>
</ul>
<h5 id="6-4-1-常见的总线标准"><a href="#6-4-1-常见的总线标准" class="headerlink" title="6.4.1 常见的总线标准"></a>6.4.1 常见的总线标准</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120100602267.png" alt="在这里插入图片描述"></p>
<h5 id="6-4-2-系统总线标准"><a href="#6-4-2-系统总线标准" class="headerlink" title="6.4.2 系统总线标准"></a>6.4.2 系统总线标准</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120100815313.png" alt="在这里插入图片描述"></p>
<h5 id="6-4-3-局部总线标准"><a href="#6-4-3-局部总线标准" class="headerlink" title="6.4.3 局部总线标准"></a>6.4.3 局部总线标准</h5><ul>
<li>1）PCI</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120101127778.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）AGP</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120101242330.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）PCI-E</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120101351712.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）VESA</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/202101201016167.png" alt="在这里插入图片描述"></p>
<h5 id="6-4-4-设备总线标准"><a href="#6-4-4-设备总线标准" class="headerlink" title="6.4.4 设备总线标准"></a>6.4.4 设备总线标准</h5><ul>
<li>1）USB</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012010180662.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）RS-232C</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120101935775.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）IDE（ATA）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120102024342.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）SATA</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120102128334.png" alt="在这里插入图片描述"></p>
<ul>
<li>5）SCSI</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120102239282.png" alt="在这里插入图片描述"></p>
<ul>
<li>6）PCMCIA</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120102355517.png" alt="在这里插入图片描述"></p>
<h5 id="6-4-5-本节知识回顾"><a href="#6-4-5-本节知识回顾" class="headerlink" title="6.4.5 本节知识回顾"></a>6.4.5 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120102921711.png" alt="在这里插入图片描述"></p>
<p>补充：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120103119807.png" alt="在这里插入图片描述"></p>
<h4 id="6-5-本章提出的问题与回答"><a href="#6-5-本章提出的问题与回答" class="headerlink" title="6.5 本章提出的问题与回答"></a>6.5 本章提出的问题与回答</h4><h5 id="1、引入总线结构有什么好处？"><a href="#1、引入总线结构有什么好处？" class="headerlink" title="1、引入总线结构有什么好处？"></a>1、引入总线结构有什么好处？</h5><p>引入总线结构主要有以下优点</p>
<ul>
<li>①简化了系统结构，便于系统设计制造。</li>
<li>②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。</li>
<li>③便于接口设计，所有与总线连接的设备均采用类似的接口。</li>
<li>④便于系统的扩充、更新与灵活配置，易于实现系统的模块化。</li>
<li>⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。</li>
<li>⑥便于故障诊断和维修，同时也能降低成本。</li>
</ul>
<h5 id="2、引入总线会导致什么问题？如何解决？"><a href="#2、引入总线会导致什么问题？如何解决？" class="headerlink" title="2、引入总线会导致什么问题？如何解决？"></a>2、引入总线会导致什么问题？如何解决？</h5><p><strong>引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时要求使用总线时就会导致总线的冲突</strong>。为解决多个主设备同时竞争总线控制权的问题，应当采用<span style="color:red">总线仲裁部件</span>，以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。</p>
<h4 id="6-6-常见问题和易混淆知识点"><a href="#6-6-常见问题和易混淆知识点" class="headerlink" title="6.6 常见问题和易混淆知识点"></a>6.6 常见问题和易混淆知识点</h4><h5 id="1、同一个总线不能既采用同步方式又采用异步方式通信吗？"><a href="#1、同一个总线不能既采用同步方式又采用异步方式通信吗？" class="headerlink" title="1、同一个总线不能既采用同步方式又采用异步方式通信吗？"></a>1、同一个总线不能既采用同步方式又采用异步方式通信吗？</h5><p><strong>半同步通信总线</strong>可以。这类总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。</p>
<p>例如，某个采用半同步方式的总线总是从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效，再去数据线上取数据。PCI总线也是一种半同步总线，它的所有事件都在时钟下降沿同步，总线设备在时钟开始的上升沿采样总线信号。</p>
<h5 id="2、一个总线在某一时刻可以有多对主从设备进行通信吗？"><a href="#2、一个总线在某一时刻可以有多对主从设备进行通信吗？" class="headerlink" title="2、一个总线在某一时刻可以有多对主从设备进行通信吗？"></a>2、一个总线在某一时刻可以有多对主从设备进行通信吗？</h5><p>不可以。在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信（即一对一的关系），或对所有设备进行广播通信（即一对多的关系）。所以<span style="color:red">一个总线在某一时刻不能有多对主从设备进行通信，否则会发生数据冲突</span>。</p>
<h3 id="七、输入-x2F-输出系统"><a href="#七、输入-x2F-输出系统" class="headerlink" title="七、输入&#x2F;输出系统"></a>七、输入&#x2F;输出系统</h3><p>【复习提示】<br>I&#x2F;O方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考査，特别是各种IO方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA方式的特点、传输过程、与中断方式的区别等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210119200603623.png" alt="在这里插入图片描述"></p>
<h4 id="7-1-I-x2F-O系统基本概念"><a href="#7-1-I-x2F-O系统基本概念" class="headerlink" title="7.1 I&#x2F;O系统基本概念"></a>7.1 I&#x2F;O系统基本概念</h4><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210118102514764.png" alt="在这里插入图片描述"></p>
<h5 id="7-1-1-输入-x2F-输出系统"><a href="#7-1-1-输入-x2F-输出系统" class="headerlink" title="7.1.1 输入&#x2F;输出系统"></a>7.1.1 输入&#x2F;输出系统</h5><p>输入&#x2F;输出是以主机为中心而言的，将信息<strong>从外部设备传送到主机</strong>称为<strong>输入</strong>，反之称为输出。输入&#x2F;输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。</p>
<blockquote>
<p>输入、输出设备都属于外部设备。</p>
</blockquote>
<ul>
<li>1）I&#x2F;O系统的演变过程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120105942936.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）I&#x2F;O系统的基本组成</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120110325900.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）I&#x2F;O接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120110518182.png" alt="在这里插入图片描述"></p>
<h5 id="7-1-2-I-x2F-O控制方式"><a href="#7-1-2-I-x2F-O控制方式" class="headerlink" title="7.1.2 I&#x2F;O控制方式"></a>7.1.2 I&#x2F;O控制方式</h5><p>输入&#x2F;输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的I&#x2F;O控制方式，基本的控制方式主要有以下4种。</p>
<p>1）程序查询方式：由CPU通过程序不断查询i&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。<br>2）程序中断方式：只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才予以响应。<br>3）DMA方式：主存和IO设备之间有一条直接数据通路，当主存和I&#x2F;O设备交换信息时无须调用中断服务程序。<br>4）通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I&#x2F;O命令时，只需启动有关通道，通道将执行通道程序，从而完成I&#x2F;O操作。<br>其中，方式1)和方式2)主要用于数据传输率较低的外部设备，方式3)和方式4)主要用于数据传输率较高的设备。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120110937684.png" alt="在这里插入图片描述"></p>
<h5 id="7-1-3-解析"><a href="#7-1-3-解析" class="headerlink" title="7.1.3 解析"></a>7.1.3 解析</h5><ul>
<li>I&#x2F;O设备不可能直接与主板总线相连，它总是通过<strong>设备控制器</strong>来相连的。</li>
<li><strong>I&#x2F;O指令</strong>是指令系统的一部分，是<strong>机器指令的一类</strong>，但其为了反映与I&#x2F;O设备交互的特点，格式和其他通用指令相比有所不同。</li>
<li><strong>通道程序存放在主存而非通道中，由通道从主存中取出并执行</strong>。<span style="color:red">通道程序由通道执行，且只能在具有通道的I&#x2F;O系统中执行</span>。</li>
</ul>
<h5 id="7-1-4-本节知识回顾"><a href="#7-1-4-本节知识回顾" class="headerlink" title="7.1.4 本节知识回顾"></a>7.1.4 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120111048677.png" alt="在这里插入图片描述"></p>
<h4 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h4><ul>
<li>外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。</li>
</ul>
<h5 id="7-2-1-输入设备"><a href="#7-2-1-输入设备" class="headerlink" title="7.2.1 输入设备"></a>7.2.1 输入设备</h5><ul>
<li>用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120111952239.png" alt="在这里插入图片描述"></p>
<h5 id="7-2-2-输出设备"><a href="#7-2-2-输出设备" class="headerlink" title="7.2.2 输出设备"></a>7.2.2 输出设备</h5><ul>
<li>1）用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120112337680.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）打印机从打字原理的角度可以分为：击打式和非击打式！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120113202531.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）打印机从工作方式的角度可以分为：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120113304718.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120113323753.png" alt="在这里插入图片描述"></p>
<h5 id="7-2-3-外部存储器（辅存）"><a href="#7-2-3-外部存储器（辅存）" class="headerlink" title="7.2.3 外部存储器（辅存）"></a>7.2.3 外部存储器（辅存）</h5><p>是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120122317646.png" alt="在这里插入图片描述"></p>
<p>1、磁盘存储器</p>
<ul>
<li>1）磁盘设备的组成</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120122805431.png" alt="在这里插入图片描述"></p>
<p>存储区域：一块硬盘含有若干<strong>记录面</strong>，每个记录面划分为若干<strong>磁道</strong>，而每条磁道又划分为若干<strong>扇区</strong>，扇区（也称块）是磁盘读写的<strong>最小单位</strong>，即<strong>磁盘按块存取</strong>。</p>
<blockquote>
<p>磁头数（Heads）：即记录面数，表示硬盘共有多少个磁头，磁头用于读取&#x2F;写入盘片上记录面的信息，一个记录面对应一个磁头。<br>柱面数（Cylinders）：表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。<br>扇区数（Sectors）：表示每条磁道上有多少个扇区。</p>
</blockquote>
<ul>
<li>2）磁盘的性能指标</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120123204130.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120123600331.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120123713603.png" alt="在这里插入图片描述"></p>
<p><strong>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。</strong></p>
<ul>
<li>3）磁盘地址和磁盘工作过程</li>
</ul>
<blockquote>
<ul>
<li>驱动器号：电脑可能有多个硬盘</li>
<li>柱面（磁道）号：移动磁头臂（寻道）</li>
<li>盘面号：激活某个磁头</li>
<li>扇区号：通过旋转将特定扇区划过磁头下方</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125023450.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>若系统中有4&#x3D;2^2^个驱动器，每个驱动器带一个磁盘，每个磁盘256&#x3D;2^8^个磁道、16&#x3D;2^4^个盘面，每个盘面划分为16&#x3D;2^4^个扇区，则每个扇区地址要18位二进制代码，其格式如上图所示。</p>
</blockquote>
<p>2、磁盘阵列</p>
<p>串行：不能同时写和读！</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125222974.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125253209.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125434130.png" alt="在这里插入图片描述"></p>
<p>3、光盘存储器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125538701.png" alt="在这里插入图片描述"></p>
<p>4、固态硬盘</p>
<p>1）固态硬盘（SSD）是一种基于闪存技术的存储器，属于电可擦除ROM，即EEPROM。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125639707.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>闪存芯片</strong>：替代传统旋转磁盘中的机械驱动器，每个芯片包含多个块（block），每个块包含多个页（page）</li>
<li><strong>闪存翻译层</strong>：将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号，负责翻译逻辑块号，找到对应页（Page）</li>
</ul>
<p>2）读写性能特性：</p>
<ul>
<li>以页（page）为单位读&#x2F;写——相当于磁盘的“扇区”</li>
<li>以块（block）为单位”擦除”，擦干净的块，其中的每页都可以写一次，读无限次</li>
<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li>
<li>读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</li>
</ul>
<p>3）与机械硬盘相比的特点：</p>
<ul>
<li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>
<li>SSD安静无噪音、耐摔抗震、能耗低、造价更贵</li>
<li>SSD的一个“块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li>
</ul>
<h5 id="7-2-4-解析"><a href="#7-2-4-解析" class="headerlink" title="7.2.4 解析"></a>7.2.4 解析</h5><ul>
<li><strong>存取一个扇区的平均延迟时间为旋转半周的时间</strong>。</li>
<li><strong>磁盘存储器的最小读写单位为一个扇区，即磁盘按块存取</strong>。</li>
</ul>
<h5 id="7-2-5-本节知识回顾"><a href="#7-2-5-本节知识回顾" class="headerlink" title="7.2.5 本节知识回顾"></a>7.2.5 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120125849762.png" alt="在这里插入图片描述"></p>
<h4 id="7-3-I-x2F-O接口"><a href="#7-3-I-x2F-O接口" class="headerlink" title="7.3 I&#x2F;O接口"></a>7.3 I&#x2F;O接口</h4><p>I&#x2F;O接口(I&#x2F;O控制器)是<strong>主机和外设之间的交接界面</strong>，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了<strong>解决这些差异</strong>而设置的。</p>
<h5 id="7-3-1-I-x2F-O接口的功能"><a href="#7-3-1-I-x2F-O接口的功能" class="headerlink" title="7.3.1 I&#x2F;O接口的功能"></a>7.3.1 I&#x2F;O接口的功能</h5><ul>
<li>进行地址译码和设备选择。CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</li>
<li>实现主机和外设的通信联络控制。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</li>
<li>实现数据缓冲。CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</li>
<li>信号格式的转换。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并&#x2F;串或串&#x2F;并转换、模&#x2F;数或数&#x2F;模转换等。</li>
<li>传送控制命令和状态信息。CPU要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令;外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反锁给外设。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120130210540.png" alt="在这里插入图片描述"></p>
<h5 id="7-3-2-I-x2F-O接口的基本结构"><a href="#7-3-2-I-x2F-O接口的基本结构" class="headerlink" title="7.3.2 I&#x2F;O接口的基本结构"></a>7.3.2 I&#x2F;O接口的基本结构</h5><p>通过数据总线，在数据缓冲寄存器与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在状态寄存器中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I&#x2F;O接口的控制寄存器。状态寄存器和控制寄存器在传送方向上是相反的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120130511159.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120130738612.png" alt="在这里插入图片描述"></p>
<h5 id="7-3-3-接口与端口"><a href="#7-3-3-接口与端口" class="headerlink" title="7.3.3 接口与端口"></a>7.3.3 接口与端口</h5><p>I&#x2F;O端口是指接口电路中可以被CPU直接访问的寄在器。</p>
<p><strong>接口&#x3D;端口（数据端口：读&amp;写、控制端口：写、状态端口：读）+ 控制逻辑</strong></p>
<p>I&#x2F;O端口要想能够被CPU访问，就必须要对各个端口进行编号，每个<strong>端口</strong>对应一个<strong>端口地址</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120131000927.png" alt="在这里插入图片描述"></p>
<h5 id="7-3-4-I-x2F-O端口及其编址"><a href="#7-3-4-I-x2F-O端口及其编址" class="headerlink" title="7.3.4 I&#x2F;O端口及其编址"></a>7.3.4 I&#x2F;O端口及其编址</h5><p>1）统一编址</p>
<p>又称存储器映射方式，是指把I&#x2F;O端口当作存储器的单元进行地址分配，这种方式CPU不需要设置专门的I&#x2F;O指令，<strong>用统一的访存指令</strong>就可以访问I&#x2F;O端口。</p>
<ul>
<li>优点：不需要专门的输入&#x2F;输出指令，可使CPU访问I&#x2F;O的操作更灵活、更方便，还可使端口有较大的编址空间。</li>
<li>缺点：端口占用存储器地址，使内存容量变小，而且利用存储器编址的I&#x2F;O设备进行数据输入&#x2F;输出操作，执行速度较慢</li>
</ul>
<blockquote>
<p>靠不同的地址码区分内存和I&#x2F;O设备，I&#x2F;O地址要求相对固定在地址的某部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120131209430.png" alt="在这里插入图片描述"></p>
<p>2）独立编址</p>
<p>又称I&#x2F;O映射方式，I&#x2F;O端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的I&#x2F;O指令来访问I&#x2F;O端口。</p>
<ul>
<li>优点：输入输出指令与存储器指令有明显区别，程序编制清晰，便于理解。</li>
<li>缺点：输入输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读&#x2F;写、I&#x2F;O设备读写两组控制信号，增加了控制的复杂性。</li>
</ul>
<blockquote>
<p>靠不同的指令区分内存和I&#x2F;O设备。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120131540410.png" alt="在这里插入图片描述"></p>
<h5 id="7-3-5-I-x2F-O接口的类型"><a href="#7-3-5-I-x2F-O接口的类型" class="headerlink" title="7.3.5 I&#x2F;O接口的类型"></a>7.3.5 I&#x2F;O接口的类型</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120131813794.png" alt="在这里插入图片描述"></p>
<h5 id="7-3-6-本节知识回顾"><a href="#7-3-6-本节知识回顾" class="headerlink" title="7.3.6 本节知识回顾"></a>7.3.6 本节知识回顾</h5><p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120132007317.png" alt="在这里插入图片描述"></p>
<h4 id="7-4-I-x2F-O方式"><a href="#7-4-I-x2F-O方式" class="headerlink" title="7.4 I&#x2F;O方式"></a>7.4 I&#x2F;O方式</h4><p>输入&#x2F;输出系统实现主机与I&#x2F;O设备之间的数据传送，可以采用不同的控制方式。常用的I&#x2F;O方式有程序查询、程序中断、DMA和通道等，其中前两种方式更依赖于CPU中程序指令的执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012013390569.png" alt="在这里插入图片描述"></p>
<h5 id="7-4-1-程序查询方式"><a href="#7-4-1-程序查询方式" class="headerlink" title="7.4.1 程序查询方式"></a>7.4.1 程序查询方式</h5><p>信息交换的控制完<strong>全由CPU执行程序</strong>实现，程序查询方式接口中设置一个<strong>数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）</strong>。</p>
<blockquote>
<p>查询方式：</p>
<p>CPU“忙等”慢速设备完成工作，二者串行工作。CPU查询速率应比输入速率高；不然数据丢失。</p>
<p>CPU不断轮询检查I&#x2F;O控制器中的“状态寄存器”，检测到状态为“已完成”之后再从数据寄存器取出输入数据。</p>
</blockquote>
<ul>
<li>1）流程图</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/202101201342067.png" alt="在这里插入图片描述"></p>
<ul>
<li>2）接口结构</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012013440456.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）例题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120135010720.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）本节回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120135231238.png" alt="在这里插入图片描述"></p>
<h5 id="7-4-2-程序中断方式"><a href="#7-4-2-程序中断方式" class="headerlink" title="7.4.2 程序中断方式"></a>7.4.2 程序中断方式</h5><p>设备准备数据时，CPU继续工作。设备准备好之后向CPU发出中断请求，CPU在指令周期的末位检查中断并做出中断响应（执行中断处理程序）。</p>
<ul>
<li>1）总览</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231120231900455.png" alt="image-20231120231900455"></p>
<p>中断功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231120233003471.png" alt="image-20231120233003471"></p>
<ul>
<li>2）基本概念</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120141926967.png" alt="在这里插入图片描述"></p>
<ul>
<li>3）中断请求的分类</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120142304772.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120142425467.png" alt="在这里插入图片描述"></p>
<ul>
<li>4）中断请求标记</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120142804716.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>5）中断响应判优</p>
<p><strong>中断响应优先级</strong>：中断响应优先级是指CPU响应中断请求的先后顺序。</p>
<p>由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过<strong>中断判优逻辑</strong>来确定响应哪个中断源的请求。</p>
<ul>
<li>实现</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120143042355.png" alt="在这里插入图片描述"></p>
<ul>
<li>优先级设置</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120143108902.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>①不可屏蔽中断&gt;内部异常&gt;可屏蔽中断；</p>
<p>②内部异常中，硬件故障&gt;软件中断；</p>
<p>③DMA中断请求＞I&#x2F;O设备传送的中断请求；</p>
<p>④在I&#x2F;O传送类中断请求中，高速设备＞低速设备，输入设备＞输出设备，实时设备＞普通设备。</p>
</blockquote>
</li>
<li><p>6）中断处理过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/3473889611fdcc34e116ab4245f17fda.png" alt="image-20230901173205434"></p>
<p>①关中断。</p>
<p>②保存断点。</p>
<p>③中断服务程序寻址。</p>
<p>④保存现场和屏蔽字。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放着程序执行到断点处的现行值。</p>
<blockquote>
<p>注意：现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现；而断点信息由CPU在中断响应时自动保存到栈或指定的寄存器中，即由硬件实现。</p>
</blockquote>
<p>⑤开中断。允许更高级中断请求得到响应，实现中断嵌套。</p>
<p>⑥执行中断服务程序。这是中断请求的目的。</p>
<p>⑦关中断。保证在恢复现场和屏蔽字时不被中断。</p>
<p>⑧恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</p>
<p>⑨开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<blockquote>
<p>其中，① ~ ③由中断隐指令（硬件自动）完成；④ ~ ⑨由中断服务程序完成。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120143551516.png" alt="在这里插入图片描述"></p>
<ul>
<li>硬件向量法</li>
</ul>
<blockquote>
<p><strong>中断隐指令</strong>：中断隐指令并不是指令系统中的一条真正的指令，只是一种虚拟的说法，本质上是硬件的一系列自动操作。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120143949802.png" alt="在这里插入图片描述"></p>
<ul>
<li>中断服务程序</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120144400388.png" alt="在这里插入图片描述"></p>
<ul>
<li>中断处理过程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/2021012014454146.png" alt="在这里插入图片描述"></p>
</li>
<li><p>7）单重中断与多重中断</p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>单重中断</strong>：若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而CPU对新的中断请求不予响应，则这种中断称为单重中断，如图（a）所示。</li>
<li><strong>多重中断</strong>：若CPU暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为多重中断，又称中断嵌套，如图（b）所示。</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120145123868.png" alt="在这里插入图片描述"></p>
<p>CPU要具备多重中断的功能，必须满足下列条件：</p>
<p>​	①在中断服务程序中提前设置开中断指令。</p>
<p>​	②优先级别高的中断源有权中断优先级别低的中断源。</p>
<ul>
<li>8）中断屏蔽技术</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/image-20231121222313467.png" alt="image-20231121222313467"></p>
<ul>
<li>中断屏蔽技术-例题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120150308433.png" alt="在这里插入图片描述"></p>
<ul>
<li>9）例题<ul>
<li>程序中断方式过程</li>
</ul>
</li>
</ul>
<blockquote>
<p>恢复现场即算做下一次启动</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120150843694.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120151113869.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120151611248.png" alt="在这里插入图片描述"></p>
<ul>
<li>10）本节知识回顾</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120151646307.png" alt="在这里插入图片描述"></p>
<h5 id="7-4-3-DMA方式"><a href="#7-4-3-DMA方式" class="headerlink" title="7.4.3 DMA方式"></a>7.4.3 DMA方式</h5><p>DMA方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。</p>
<p>DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。</p>
<p>这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。</p>
<p>1）DMA方式的特点</p>
<p>主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，<strong>I&#x2F;O与主机并行工作，程序和传送并行工作</strong>。</p>
<ul>
<li>①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</li>
<li>②在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li>
<li>③主存中要开辟专用缓冲区，及时供给和接收外设的数据。</li>
<li>④DMA传送速度快，CPU和外设并行工作，提高了系统效率。</li>
<li>⑤DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li>
</ul>
<p>2）DMA控制器的主要功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120152205404.png" alt="在这里插入图片描述"></p>
<p>3）DMA控制器的组成</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120153622980.png" alt="在这里插入图片描述"></p>
<ul>
<li>主存地址计数器：简称AR，存放要交换数据的主存地址。</li>
<li>传送长度计数器：简称WC，用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li>
<li>数据缓冲寄存器：暂存每次传送的数据。</li>
<li>DMA请求触发器：每当I&#x2F;O设备准备好数据后给出一个控制信号，使DMA请求触发器置位。</li>
<li>控制&#x2F;状态逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。</li>
<li>中断机构：数据传送完毕后触发中断机构，提出中断请求。</li>
</ul>
<blockquote>
<p><span style="color:red">在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线，CPU的 主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。</span></p>
</blockquote>
<p>4）DMA传送过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120153749657.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120153908734.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120153952935.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120154049766.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>预处理：CPU完成寄存器初值设置等准备工作</p>
<ul>
<li><p>首先，CPU执行几条I&#x2F;O指令，用以测试I&#x2F;O设备状态，初始化DMA控制器中的有关寄存器、设置传送方向、启动该设备等。</p>
</li>
<li><p>然后，CPU继续执行原来的程序，直到I&#x2F;O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I&#x2F;O设备向DMA控制器发送DMA请求。</p>
</li>
<li><p>再由DMA控制器向CPU发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
</li>
</ul>
</li>
<li><p>数据传送：CPU继续执行主程序，DMA控制器完成数据传送</p>
<ul>
<li>DMA的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。</li>
<li>对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。</li>
<li>需要指出的是，这一循环也是由DMA控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</li>
</ul>
</li>
<li><p>后处理：CPU执行中断服务程序做DMA结束处理</p>
<ul>
<li>包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转诊断程序）及决定是否继续使用DMA传送其他数据等。</li>
</ul>
</li>
</ul>
<p>5）DMA传送方式</p>
<p>主存和I&#x2F;O设备之间交换信息时，不通过CPU。但当I&#x2F;O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存：</p>
<ul>
<li>停止CPU访存：需要数据传送时，停止CPU访存，总线控制权交给DMA控制器。</li>
<li>交替访存：将CPU周期分为DMA访存和CPU访存两个部分。</li>
<li>周期挪用（周期窃取）：I&#x2F;O设备需要访存时，挪用一个或几个存取周期。<ul>
<li>CPU此时不访存（不冲突）</li>
<li>CPU正在访存（存取周期结束让出总线）</li>
<li>CPU与DMA同时请求访存（I&#x2F;O访存优先）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120154432194.png" alt="在这里插入图片描述"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120154822413.png" alt="在这里插入图片描述"></p>
<p>6）DMA方式与中断方式对比</p>
<p>DMA方式和中断方式的重要区别如下：</p>
<ul>
<li>①中断方式是程序的切换，需要保护和恢复现场：而DMA方式不中断现行程序，无需保护现场，除了预处理和后处理，其他时候不占用任何CPU资源。</li>
<li>②对中断请求的响应只能发生在每条指令执行结束时（执行周期后）：而对DMA请求的响应可以发生在任意一个机器周期结束时（取指、间址、执行周期后均可）。</li>
<li>③中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</li>
<li>④DMA请求的优先级高于中断请求。</li>
<li>⑤中断方式具有处理异常事件的能力，而DMA方式仅局限于大批数据的传送。</li>
<li>⑥从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120155144682.png" alt="在这里插入图片描述"></p>
<p>7）例题</p>
<ul>
<li>CPU占用情况 - 中断方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120155537747.png" alt="在这里插入图片描述"></p>
<ul>
<li>CPU占用情况 - DMA方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120155811934.png" alt="在这里插入图片描述"></p>
<p>8）本节知识回顾</p>
<p><img src="https://cdn.jsdelivr.net/gh/CentLabs/PictureRepository@master/img/20210120155910155.png" alt="在这里插入图片描述"></p>
<h4 id="7-5-本章提出的问题与回答"><a href="#7-5-本章提出的问题与回答" class="headerlink" title="7.5 本章提出的问题与回答"></a>7.5 本章提出的问题与回答</h4><h5 id="1、I-x2F-O设备有哪些编址方式？各有何特点？"><a href="#1、I-x2F-O设备有哪些编址方式？各有何特点？" class="headerlink" title="1、I&#x2F;O设备有哪些编址方式？各有何特点？"></a>1、I&#x2F;O设备有哪些编址方式？各有何特点？</h5><p>统一编址和独立编址。<strong>统一编址</strong>是在主存地址中划出一定的范围作为I&#x2F;O地址，以便<strong>通过访存指令即可实现对I&#x2F;O的访问</strong>，但主存的容量相应减少。<span style="color:red">独立编址是指IO地址和主存是分开的，I&#x2F;O地址不占主存空间，但访存需专门的I&#x2F;O指令</span>。</p>
<h5 id="2、CPU响应中断应具备哪些条件？"><a href="#2、CPU响应中断应具备哪些条件？" class="headerlink" title="2、CPU响应中断应具备哪些条件？"></a>2、CPU响应中断应具备哪些条件？</h5><ul>
<li>①在CPU内部设置的中断屏蔽触发器必须是开放的；</li>
<li>②外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号；</li>
<li>③外设(接ロ)中断允许触发器必须为“1”，这样才能把外设中断请求送至CPU。</li>
</ul>
<p>具备上述三个条件时，CPU在现行指令结束的最后一个状态周期响应中断。</p>
<h4 id="7-6-常见问题和易混淆知识点"><a href="#7-6-常见问题和易混淆知识点" class="headerlink" title="7.6 常见问题和易混淆知识点"></a>7.6 常见问题和易混淆知识点</h4><h5 id="1、中断响应优先级和中断处理优先级分别指什么？"><a href="#1、中断响应优先级和中断处理优先级分别指什么？" class="headerlink" title="1、中断响应优先级和中断处理优先级分别指什么？"></a>1、中断响应优先级和中断处理优先级分别指什么？</h5><p><span style="color:red"><strong>中断响应优先级</strong></span>是<strong>由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变</strong>；而<span style="color:red"><strong>中断处理优先级</strong></span>可以<strong>由中断屏蔽字来改变</strong>，反映的是正在处理的中断是否比新发生的中断的处理优先级低(屏蔽位为“0”，对新中断开放)，若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</p>
<h5 id="2、向量中断、中断向量、向量地址三个概念是什么关系？"><a href="#2、向量中断、中断向量、向量地址三个概念是什么关系？" class="headerlink" title="2、向量中断、中断向量、向量地址三个概念是什么关系？"></a>2、向量中断、中断向量、向量地址三个概念是什么关系？</h5><ul>
<li><strong>中断向量</strong>：每个中断源都有对应的处理程序，这个处理程序称为<strong>中断服务程序</strong>，<strong>其入口地址称为中断向量</strong>。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。</li>
<li>向量地址：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。</li>
<li>向量中断：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。</li>
</ul>
<h5 id="3、程序中断和调用子程序有何区别？"><a href="#3、程序中断和调用子程序有何区别？" class="headerlink" title="3、程序中断和调用子程序有何区别？"></a>3、程序中断和调用子程序有何区别？</h5><p>两者的根本区别主要表现在服务时间和服务对象上不一样。</p>
<ul>
<li>1)<strong>调用子程序过程发生的时间是已知的和固定的</strong>，即在主程序中的调用指令(CALL)执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的。</li>
<li>2)<strong>子程序完全为主程序服务，两者属于主从关系</strong>。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是平行关系。</li>
<li>3)<strong>主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路</strong>；而中断处理系统是一个软&#x2F;硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程。</li>
<li>4)<strong>子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制</strong>；而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。</li>
</ul>
<p>从宏观上看，虽然<strong>程序中断方式</strong>克服了程序査询方式中的CPU“踏步”现象，<strong>实现了CPU与I&#x2F;O并行工作</strong>，提高了CPU的资源利用率；但从微观操作分析，CPU在处理中断服务程序时，仍需暂停原程序的正常运行，尤其是当高速I&#x2F;O设备或辅助存储器频繁地、成批地与主存交换信息时，需要不断打断CPU执行现行程序，而执行中断服务程序。</p>
<h5 id="4、IO指令和通道指令有何区别？"><a href="#4、IO指令和通道指令有何区别？" class="headerlink" title="4、IO指令和通道指令有何区别？"></a>4、IO指令和通道指令有何区别？</h5><ul>
<li><strong>I&#x2F;O指令是CPU指令系统的一部分，是CPU用来控制输入&#x2F;输出操作的指令</strong>，由CPU译码后执行。在具有通道结构的机器中，I&#x2F;O指令不实现I&#x2F;O数据传送，主要完成启、停I&#x2F;O设备，査询通道和I&#x2F;O设备的状态，及控制通道进行其他一些操作等。</li>
<li><strong>通道指令是通道本身的指令，用来执行I&#x2F;O操作</strong>，如读、写、磁带走带及磁盘找道等操作。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">https://centlabs.github.io/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/11/16/Operating%20System/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Operating System</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-14</div><div class="title">Data Structure - 题库</div></div></a></div><div><a href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Data Structure - 王道</div></div></a></div><div><a href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Data Structure Algorithm</div></div></a></div><div><a href="/2023/11/12/Data%20Structure/" title="Data Structure"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Data Structure</div></div></a></div><div><a href="/2023/11/16/Operating%20System/" title="Operating System"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Operating System</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 计算机发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 计算机硬件的发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 计算机软件的发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 计算机的分类与发展方向</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 计算机系统层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 计算机系统的组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 计算机硬件的基本组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 计算机软件的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 计算机的工作过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.2.5 计算机系统的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">1.2.6 计算机系统的层次结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 计算机性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、机器字长</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、数据通路带宽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、主存容量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6"><span class="toc-number">1.3.4.</span> <span class="toc-text">4、运算速度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B8%B8%E7%94%A8%E6%95%B0%E9%87%8F%E5%8D%95%E4%BD%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">5、常用数量单位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.6.</span> <span class="toc-text">6、基准程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%87%A0%E4%B8%AA%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.7.</span> <span class="toc-text">7、几个专业术语</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F%E4%BB%A5%E5%93%AA%E9%83%A8%E5%88%86%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、计算机由哪几部分组成？以哪部分为中心？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E9%A2%91%E9%AB%98%E7%9A%84CPU%E4%B8%80%E5%AE%9A%E6%AF%94%E4%B8%BB%E9%A2%91%E4%BD%8E%E7%9A%84CPU%E5%BF%AB%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、主频高的CPU一定比主频低的CPU快吗？为什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F%E3%80%81%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E3%80%81%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E3%80%81%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%83%BD%E8%A2%AB%E7%A1%AC%E4%BB%B6%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%97%A2%E5%8F%AF%E4%BB%A5%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8F%88%E5%8F%AF%E4%BB%A5%E7%94%B1%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、同一个功能既可以由软件实现又可以由硬件实现吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%8F%E6%98%8E%E6%80%A7%EF%BC%9F%E9%80%8F%E6%98%8E%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%E9%83%BD%E8%83%BD%E7%9C%8B%E8%A7%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、什么是透明性？透明是指什么都能看见吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E3%80%81%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">3、机器字长、指令字长、存储字长的区别和联系是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">4、计算机体系结构和计算机组成的区别和联系是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%BE%97%E8%B6%8A%E5%BF%AB%E8%AF%B4%E6%98%8E%E6%9D%BA%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">5、基准程序执行得越快说明杺器的性能越好吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">二、数据的表示与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 数制与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 进位计数制及其相互转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-BCD%E7%A0%81%EF%BC%88Binary-Code-Decimal%E7%A0%81%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 BCD码（Binary-Code Decimal码）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 字符与字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4 校验码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 定点数的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">1、定点数和浮点数的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">2、无符号数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8E%9F%E7%A0%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">3、原码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%8F%8D%E7%A0%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">4、反码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%A1%A5%E7%A0%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">5、补码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E7%A7%BB%E7%A0%81"><span class="toc-number">2.2.6.</span> <span class="toc-text">6、移码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%BF%994%E7%A7%8D%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.7.</span> <span class="toc-text">7、原码、补码、反码和移码这4种编码表示的总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.8.</span> <span class="toc-text">8、定点数的移位运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-number">2.2.9.</span> <span class="toc-text">9、溢出判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">2.2.10.</span> <span class="toc-text">10、符号扩展</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 浮点数的表示与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">1、浮点数的表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">2、尾数的规格化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81IEEE-754-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">3、IEEE 754 浮点数标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.4.</span> <span class="toc-text">4、浮点数的表示与运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.5.</span> <span class="toc-text">5、电路的基本原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%EF%BC%88ALU%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 算数逻辑单元（ALU）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E7%A0%81%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">1、原码乘法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.2.</span> <span class="toc-text">2、补码乘法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.3.</span> <span class="toc-text">3、原码除法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.4.</span> <span class="toc-text">4、补码除法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.5.</span> <span class="toc-text">5、强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">2.4.6.</span> <span class="toc-text">6、数据的存储和排列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%A5%E8%A1%A8%E7%A4%BA%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">1、在计算机中，为什么要采用二进制来表示数据？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%AD%97%E9%95%BF%E8%B6%B3%E5%A4%9F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%83%BD%E5%A4%9F%E7%B2%BE%E7%A1%AE%E5%9C%B0%E8%A1%A8%E7%A4%BA%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%90%97%EF%BC%9F%E8%8B%A5%E4%B8%8D%E8%83%BD%EF%BC%8C%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">2.5.2.</span> <span class="toc-text">2、计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E9%95%BF%E7%9B%B8%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4%E4%B8%8E%E7%B2%BE%E5%BA%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">3、字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E7%A7%BB%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E9%98%B6%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">2.5.4.</span> <span class="toc-text">4、用移码表示浮点数的阶码有什么好处？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%EF%BC%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.6.1.</span> <span class="toc-text">1、如何表示一个数值数据？计算机中的数値数据都是二进制数吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%9C%A8%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%89%80%E5%AE%9A%E4%B9%89%E7%9A%84-unsigned-x2F-short-x2F-int-x2F-long-x2F-float-x2F-double%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E8%A1%A8%E7%A4%BA%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E7%A7%B0%E4%B8%BA%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E2%80%9C%E6%BA%A2%E5%87%BA%E2%80%9D%EF%BC%9F"><span class="toc-number">2.6.2.</span> <span class="toc-text">2、在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0%EF%BC%9F"><span class="toc-number">2.6.3.</span> <span class="toc-text">3、如何判断一个浮点数是否是规格化数？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E4%BA%8E%E4%BD%8D%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AE%9A%E7%82%B9%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%8F%AF%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%AA%E6%95%B0%E6%AF%94%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%AA%E6%95%B0%E5%A4%9A%E5%90%97%EF%BC%9F"><span class="toc-number">2.6.4.</span> <span class="toc-text">4、对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%88%8D%E5%85%A5%EF%BC%9F"><span class="toc-number">2.6.5.</span> <span class="toc-text">5、浮点数如何进行舍入？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%98%AF%E5%90%A6%E8%A6%81%E8%80%83%E8%99%91%E5%8E%9F%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.6.</span> <span class="toc-text">6、现代计算机中是否要考虑原码加减运算？如何实现?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E9%95%BF%E5%BA%A6%E4%B8%BAn-1%E7%9A%84%E5%AE%9A%E7%82%B9%E6%95%B0%EF%BC%8C%E6%8C%89%E7%85%A7%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.6.7.</span> <span class="toc-text">7、长度为n+1的定点数，按照不同的编码方式，表示的数值范围是多少？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E8%AE%BE%E9%98%B6%E7%A0%81%E5%92%8C%E5%B0%BE%E6%95%B0%E5%9D%87%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%EF%BC%8C%E9%98%B6%E7%A0%81%E9%83%A8%E5%88%86%E5%85%B1K-1%E4%BD%8D-%E5%90%AB1%E4%BD%8D%E9%98%B6%E7%AC%A6-%EF%BC%8C%E5%B0%BE%E6%95%B0%E9%83%A8%E5%88%86%E5%85%B1n-1%E4%BD%8D%EF%BC%88%E5%90%AB1%E4%BD%8D%E6%95%B0%E7%AC%A6%EF%BC%89%EF%BC%8C%E5%88%99%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.6.8.</span> <span class="toc-text">8、设阶码和尾数均用补码表示，阶码部分共K+1位(含1位阶符)，尾数部分共n+1位（含1位数符），则这样的浮点数的表示范围是多少？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">三、存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 存储器的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 存储器的性能指标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 存储器的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、存储器的层次化结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、存储器的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">3、主存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.4.</span> <span class="toc-text">4、存储器芯片的基本结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%AF%BB%E5%9D%80"><span class="toc-number">3.2.5.</span> <span class="toc-text">5、寻址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 半导体随机存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-SRAM%E5%92%8CDRAM"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 SRAM和DRAM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 只读存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%EF%BC%88%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 主存的基本组成（存储系统）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 主存储器与CPU的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 连接原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 主存容量的扩展</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 双端口RAM和多模块存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 双端口RAM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-2-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 多模块存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 多体并行存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-4-%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 高速缓冲存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-1-%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 程序访问的局部性原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-2-Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2 Cache的基本工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-3-Cache%E4%B8%AD%E4%B8%BB%E5%AD%98%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.6.3 Cache中主存块的替换算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 虚拟存储器的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-2-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 页式虚拟存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-3-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.7.3.</span> <span class="toc-text">3.7.3 段式虚拟存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-4-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.7.4.</span> <span class="toc-text">3.7.4 段页式虚拟存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-5-%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89"><span class="toc-number">3.7.5.</span> <span class="toc-text">3.7.5 快表（TLB）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-6-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECache%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.7.6.</span> <span class="toc-text">3.7.6 虚拟存储器与Cache的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E4%BD%95%E5%A4%84%EF%BC%9F%E4%B8%BA%E4%BD%95%E8%A6%81%E5%88%86%E8%BF%99%E4%BA%9B%E5%B1%82%E6%AC%A1%EF%BC%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%99%E4%BA%9B%E5%B1%82%E6%AC%A1%EF%BC%9F"><span class="toc-number">3.8.1.</span> <span class="toc-text">1、存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F%E5%92%8C%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.8.2.</span> <span class="toc-text">2、存取周期和存取时间有何区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9C%A8%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%BE%97%E5%A4%A7%E4%B8%80%E4%BA%9B%E5%A5%BD%E8%BF%98%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%BE%97%E5%B0%8F%E4%B8%80%E4%BA%9B%E5%A5%BD%EF%BC%9F"><span class="toc-number">3.8.3.</span> <span class="toc-text">3、在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4Ta%E5%B0%B1%E6%98%AF%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9FTm%E5%90%97%EF%BC%9F"><span class="toc-number">3.9.1.</span> <span class="toc-text">1、存取时间Ta就是存储周期Tm吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Cache%E8%A1%8C%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%91%BD%E4%B8%AD%E7%8E%87%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.9.2.</span> <span class="toc-text">2、Cache行的大小和命中率之间有什么关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8F%91%E7%94%9F%E5%8F%96%E6%8C%87%E4%BB%A4Cache%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.9.3.</span> <span class="toc-text">3、发生取指令Cache缺失的处理过程是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E4%BA%8E-Cache%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">3.9.4.</span> <span class="toc-text">4、关于 Cache的一些小知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">四、指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 指令的基本格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 指令寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 指令的寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 常见的数据寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 数据存放方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4 知识回顾与总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-CISC%E5%92%8CRISC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 CISC和RISC的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text">1、什么是指令？什么是指令系统？为什么要引入指令系统？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%8C%87%E4%BB%A4%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%EF%BC%9F%E6%AF%8F%E9%83%A8%E5%88%86%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%84%EF%BC%9F"><span class="toc-number">4.4.2.</span> <span class="toc-text">2、一般来说，指令分为哪些部分？每部分有什么用处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%A4%9A%E5%92%8C%E5%B0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">4.4.3.</span> <span class="toc-text">3、对于一个指令系统来说，寻址方式多和少有什么影响？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E8%BF%B0%E5%90%84%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">1、简述各常见指令寻址方式的特点和适用情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E5%8D%A0%E5%A4%9A%E4%B8%AA%E5%8D%95%E5%85%83%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%BB%99%E5%87%BA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">4.5.2.</span> <span class="toc-text">2、一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%A3%85%E5%85%A5-x2F-%E5%AD%98%E5%82%A8-Load-x2F-Store-%E5%9E%8B%E6%8C%87%E4%BB%A4%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">4.5.3.</span> <span class="toc-text">3、装入&#x2F;存储(Load&#x2F; Store)型指令有什么特点？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">五、中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9E%84%E9%80%A0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 CPU的功能和基本构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 CPU的基本功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 CPU的基本结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">1、运算器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.1.4.</span> <span class="toc-text">2、控制器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%93%E3%80%81%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">5.1.5.</span> <span class="toc-text">３、本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 指令周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 指令周期的数据流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3 指令执行方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">5.3.1.</span> <span class="toc-text">1、数据通路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF-CPU%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">2、数据通路-CPU内部单总线方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81CPU%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F-%E4%BE%8B%E9%A2%98"><span class="toc-number">5.3.3.</span> <span class="toc-text">3、CPU内部单总线方式-例题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.4.</span> <span class="toc-text">4、专用数据通路方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">5.3.5.</span> <span class="toc-text">5、本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 控制器的功能和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 控制器的结构和功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 硬布线控制器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 微程序控制器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-1-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 指令流水的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-2-%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 影响流水线的因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3 流水线的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-4-%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.4.</span> <span class="toc-text">5.5.4 超标量流水线的基本概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 异常和中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-1-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.6.1 异常和中断的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-2-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.6.2 异常和中断的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-3-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.6.3 异常和中断响应过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 多处理器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-1-SISD%E3%80%81SIMD%E3%80%81MIMD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.7.1 SISD、SIMD、MIMD的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-2-%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.2.</span> <span class="toc-text">5.7.2 硬件多线程的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-3-%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.3.</span> <span class="toc-text">5.7.3 多核处理器的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-4-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.4.</span> <span class="toc-text">5.7.4 共享内存多处理器的基本概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81CPU%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%EF%BC%9F%E5%88%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">5.8.1.</span> <span class="toc-text">1、CPU分为哪几部分？分别实现什么功能？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9D%87%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BB%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E4%B8%8A%E5%8C%BA%E5%88%86%E5%AE%83%E4%BB%AC%E6%98%AF%E6%8C%87%E4%BB%A4%E8%BF%98%E6%98%AF%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">5.8.2.</span> <span class="toc-text">2、指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E3%80%81%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%E5%92%8C%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">5.8.3.</span> <span class="toc-text">3、什么是指令周期、机器周期和时钟周期？它们之间有何关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E5%80%BC%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.8.4.</span> <span class="toc-text">4、指令周期是否有一个固定值？为什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%8C%87%E4%BB%A4%EF%BC%9F%E5%AE%83%E5%92%8C%E7%AC%AC4%E7%AB%A0%E8%B0%88%E5%88%B0%E7%9A%84%E6%8C%87%E4%BB%A4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">5.8.5.</span> <span class="toc-text">5、什么是微指令？它和第4章谈到的指令有什么关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%9F%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%8A%A0%E9%80%9F%E6%AF%94%EF%BC%9F"><span class="toc-number">5.8.6.</span> <span class="toc-text">6、什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B6%8A%E5%A4%9A%EF%BC%8C%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%B0%B1%E8%B6%8A%E9%AB%98%E3%80%82%E6%98%AF%E5%90%A6%E6%B5%81%E6%B0%B4%E6%AE%B5%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%B6%8A%E5%BF%AB%EF%BC%9F"><span class="toc-number">5.9.1.</span> <span class="toc-text">1、流水线越多，并行度就越高。是否流水段越多，指令执行越快？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%9C%89%E5%85%B3%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3%E3%80%81%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">5.9.2.</span> <span class="toc-text">2、有关指令相关、数据相关的几个概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BA%BF"><span class="toc-number">6.</span> <span class="toc-text">六、总线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 总线的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-%E6%80%BB%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 总线基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 总线的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3 总线的性能指标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 总线仲裁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 总线仲裁的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-%E9%9B%86%E4%B8%AD%E4%BB%B2%E8%A3%81%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 集中仲裁方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3-%E5%88%86%E5%B8%83%E4%BB%B2%E8%A3%81%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 分布仲裁方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AE%9A%E6%97%B6"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 总线操作和定时</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-%E6%80%BB%E7%BA%BF%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1 总线传输的四个阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-%E5%90%8C%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F%EF%BC%88%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2 同步定时方式（同步通信）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-3-%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3 异步定时方式（异步通信）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-4-%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4 半同步通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-5-%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1"><span class="toc-number">6.3.5.</span> <span class="toc-text">6.3.5 分离式通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">6.3.6.</span> <span class="toc-text">6.3.6 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 总线标准</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1 常见的总线标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-2-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2 系统总线标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-3-%E5%B1%80%E9%83%A8%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3 局部总线标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-4-%E8%AE%BE%E5%A4%87%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">6.4.4.</span> <span class="toc-text">6.4.4 设备总线标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-5-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">6.4.5.</span> <span class="toc-text">6.4.5 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">1、引入总线结构有什么好处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%BC%95%E5%85%A5%E6%80%BB%E7%BA%BF%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">6.5.2.</span> <span class="toc-text">2、引入总线会导致什么问题？如何解决？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BA%BF%E4%B8%8D%E8%83%BD%E6%97%A2%E9%87%87%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%88%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E9%80%9A%E4%BF%A1%E5%90%97%EF%BC%9F"><span class="toc-number">6.6.1.</span> <span class="toc-text">1、同一个总线不能既采用同步方式又采用异步方式通信吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BA%BF%E5%9C%A8%E6%9F%90%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E5%AF%B9%E4%B8%BB%E4%BB%8E%E8%AE%BE%E5%A4%87%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%90%97%EF%BC%9F"><span class="toc-number">6.6.2.</span> <span class="toc-text">2、一个总线在某一时刻可以有多对主从设备进行通信吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">七、输入&#x2F;输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-I-x2F-O%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 I&#x2F;O系统基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-1-%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1 输入&#x2F;输出系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-2-I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2 I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-3-%E8%A7%A3%E6%9E%90"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3 解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-4-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 外部设备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-1-%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 输入设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2 输出设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-3-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E8%BE%85%E5%AD%98%EF%BC%89"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3 外部存储器（辅存）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-%E8%A7%A3%E6%9E%90"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.2.4 解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-5-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">7.2.5.</span> <span class="toc-text">7.2.5 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-I-x2F-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-1-I-x2F-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 I&#x2F;O接口的功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-I-x2F-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 I&#x2F;O接口的基本结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3 接口与端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-4-I-x2F-O%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E7%BC%96%E5%9D%80"><span class="toc-number">7.3.4.</span> <span class="toc-text">7.3.4 I&#x2F;O端口及其编址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-5-I-x2F-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.5.</span> <span class="toc-text">7.3.5 I&#x2F;O接口的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-6-%E6%9C%AC%E8%8A%82%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">7.3.6.</span> <span class="toc-text">7.3.6 本节知识回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-I-x2F-O%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 I&#x2F;O方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-1-%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1 程序查询方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-2-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2 程序中断方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-3-DMA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3 DMA方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%9C%AC%E7%AB%A0%E6%8F%90%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 本章提出的问题与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81I-x2F-O%E8%AE%BE%E5%A4%87%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%90%84%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">7.5.1.</span> <span class="toc-text">1、I&#x2F;O设备有哪些编址方式？各有何特点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81CPU%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E5%BA%94%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">7.5.2.</span> <span class="toc-text">2、CPU响应中断应具备哪些条件？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 常见问题和易混淆知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E5%88%AB%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.6.1.</span> <span class="toc-text">1、中断响应优先级和中断处理优先级分别指什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD%E3%80%81%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E3%80%81%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">7.6.2.</span> <span class="toc-text">2、向量中断、中断向量、向量地址三个概念是什么关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E5%92%8C%E8%B0%83%E7%94%A8%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.6.3.</span> <span class="toc-text">3、程序中断和调用子程序有何区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81IO%E6%8C%87%E4%BB%A4%E5%92%8C%E9%80%9A%E9%81%93%E6%8C%87%E4%BB%A4%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.6.4.</span> <span class="toc-text">4、IO指令和通道指令有何区别？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理"/></a><div class="content"><a class="title" href="/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理">计算机组成原理</a><time datetime="2023-11-20T15:53:48.956Z" title="Created 2023-11-20 23:53:48">2023-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/16/Operating%20System/" title="Operating System"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Operating System"/></a><div class="content"><a class="title" href="/2023/11/16/Operating%20System/" title="Operating System">Operating System</a><time datetime="2023-11-16T15:21:57.803Z" title="Created 2023-11-16 23:21:57">2023-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 题库"/></a><div class="content"><a class="title" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库">Data Structure - 题库</a><time datetime="2023-11-14T13:59:04.475Z" title="Created 2023-11-14 21:59:04">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 王道"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道">Data Structure - 王道</a><time datetime="2023-11-12T15:05:01.134Z" title="Created 2023-11-12 23:05:01">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure Algorithm"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm">Data Structure Algorithm</a><time datetime="2023-11-12T13:02:28.408Z" title="Created 2023-11-12 21:02:28">2023-11-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>