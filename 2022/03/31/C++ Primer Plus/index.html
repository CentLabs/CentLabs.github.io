<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ Learning | CentLabs</title><meta name="keywords" content="c++"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二章  C++的学习为查看输出，必须在程序的最后加上一些代码： 12cin.get();&#x2F;&#x2F;读取下一次键击，因此上述语句让程序等待，直到按下了Enter键  C语言输入和输出如果已经使用过C语言进行编程，则看到cout函数（而不是printf（）函数）时可能会诧异。事实上C++能够使用printf（）、scanf（）和其他所有标准C输入和输出函数，只需要包含常规C语言的stdio.h文件。使用C">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Learning">
<meta property="og:url" content="https://centlabs.github.io/2022/03/31/C++%20Primer%20Plus/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="第二章  C++的学习为查看输出，必须在程序的最后加上一些代码： 12cin.get();&#x2F;&#x2F;读取下一次键击，因此上述语句让程序等待，直到按下了Enter键  C语言输入和输出如果已经使用过C语言进行编程，则看到cout函数（而不是printf（）函数）时可能会诧异。事实上C++能够使用printf（）、scanf（）和其他所有标准C输入和输出函数，只需要包含常规C语言的stdio.h文件。使用C">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-03-31T14:50:54.350Z">
<meta property="article:modified_time" content="2022-03-31T15:23:08.406Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2022/03/31/C++%20Primer%20Plus/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Learning',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-31 23:23:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ Learning</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-03-31T14:50:54.350Z" title="Created 2022-03-31 22:50:54">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-03-31T15:23:08.406Z" title="Updated 2022-03-31 23:23:08">2022-03-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ Learning"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第二章-C-的学习"><a href="#第二章-C-的学习" class="headerlink" title="第二章  C++的学习"></a>第二章  C++的学习</h3><p>为查看输出，必须在程序的最后加上一些代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.get();</span><br><span class="line">//读取下一次键击，因此上述语句让程序等待，直到按下了Enter键</span><br></pre></td></tr></table></figure>

<h5 id="C语言输入和输出"><a href="#C语言输入和输出" class="headerlink" title="C语言输入和输出"></a>C语言输入和输出</h5><p>如果已经使用过C语言进行编程，则看到cout函数（而不是printf（）函数）时可能会诧异。事实上C++能够使用printf（）、scanf（）和其他所有标准C输入和输出函数，只需要包含常规C语言的stdio.h文件。使用C++的输入工具，它们在C版本的基础上作出了很多改进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注释，由前缀//标识</span><br><span class="line">预处理器编译指令#include</span><br><span class="line">函数头：int main()</span><br><span class="line">编译指令 using namespace </span><br><span class="line">函数体，用&#123;和&#125;括起</span><br><span class="line">使用C++的cout工具显示消息的语句</span><br><span class="line">结束main()函数的return语句。</span><br></pre></td></tr></table></figure>

<h5 id="头文件命令的约定"><a href="#头文件命令的约定" class="headerlink" title="头文件命令的约定"></a>头文件命令的约定</h5><table>
<thead>
<tr>
<th>头文件类型</th>
<th>约定</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C++旧式风格</td>
<td>以.h结尾</td>
<td>iostream.h</td>
<td>C++程序可以使用</td>
</tr>
<tr>
<td>C旧式风格</td>
<td>以.h结尾</td>
<td>math.h</td>
<td>C、C++程序都可以使用</td>
</tr>
<tr>
<td>C++新式风格</td>
<td>没有扩展名</td>
<td>iostream</td>
<td>C++程序可以使用，使用namespace std</td>
</tr>
<tr>
<td>转换后的C</td>
<td>加上前缀c，没有扩展名</td>
<td>cmath</td>
<td>C++程序可以使用，可以使用不是C的特性</td>
</tr>
</tbody></table>
<h5 id="控制符endl"><a href="#控制符endl" class="headerlink" title="控制符endl"></a>控制符endl</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; endl；</span><br><span class="line">//endl是一个特殊的C++符号，表示一个重要的概念：重起一行。在输出流中插入endl将导致屏幕光标移到下一行开头。</span><br></pre></td></tr></table></figure>

<p>诸如endl等对于cout来说有特殊含义的特殊符号称为控制符（manipulator）。和cout一样，endl也是在头文件iostream中定义的，且位于名称空间std中。</p>
<p>打印字符串时，cout不会自动移动到下一行。第一条cout语句将光标留在输出字符串的后面。每条cout语句的输出从前一个输出的末尾开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;The Good,the&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Bad, &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;and the Ukulele&quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//The Good,the Bad,and the Ukulele</span></span><br></pre></td></tr></table></figure>

<h5 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h5><p>C++还提供了另一种在输出中指示换行的旧式方法：C语言符号\n</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;What&#x27;s next? \n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>\n被视为一个字符，名为换行符。</p>
<p>==显示字符串时，在字符串中包含换行符，而不是在末尾加上endl，可减少输入量==：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;pluto is a dwarf planet.\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pluto is a dwarf planet.&quot;</span>&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>另一方面，如果要生成一个空行，则两种方法的输入量相同，但对于大多数人而言，输入endl更方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="C-语句"><a href="#C-语句" class="headerlink" title="C++语句"></a>C++语句</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> carrots;</span><br><span class="line">	carrots = <span class="number">25</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;I have &quot;</span>;</span><br><span class="line">	cout &lt;&lt; carrots;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; carrots.&quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	carrots = carrots - <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Crunch,crunch.Now I have &quot;</span>&lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I have 25 carrots.</span><br><span class="line">Crunch,crunch.Now I have 24 carrots.</span><br></pre></td></tr></table></figure>

<h5 id="cout和printf（）"><a href="#cout和printf（）" class="headerlink" title="cout和printf（）"></a>cout和printf（）</h5><p>如果已经习惯了C语言的printf（），可能觉得cout看起来很奇怪。程序员甚至可能固执地坚持使用printf（）。但与使用所有转换说明的printf（）相比，cout的外观一点儿也不奇怪。更重要的是，cout还有明显的优点。它能够识别类型的功能表明，其设计更灵活、更好用。另外，它是可扩展的。也就是说，==可以重新定义&lt;&lt;运算符，使cout能够识别和显示所开发的新数据类型==。如果喜欢printf（）提供的细致的控制功能，可以使用更高级的cout来获得相同的效果。</p>
<h5 id="其他C-语句"><a href="#其他C-语句" class="headerlink" title="其他C++语句"></a>其他C++语句</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> carrots;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How many carrots do you have?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; carrots;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are two more. &quot;</span>;</span><br><span class="line">    carrots = carrots + <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now you have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">How many carrots <span class="keyword">do</span> you have?</span><br><span class="line"><span class="number">32</span></span><br><span class="line">Here are two more. Now you have <span class="number">34</span> carrots.</span><br></pre></td></tr></table></figure>

<p>程序调整：</p>
<p>如果您发现在以前的程序清单中需要添加cin.get()，则在这个程序清单中，需要添加两条cin.get()语句，这样才能在屏幕上看到输出。第一条cin.get()语句在您输入数字并按Enter键时读取输入，而第二条cin.get()语句让程序暂停，直到您按Enter键。</p>
<h5 id="使用cout进行拼接"><a href="#使用cout进行拼接" class="headerlink" title="使用cout进行拼接"></a>使用cout进行拼接</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Now you have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h5><p>==类是用户定义的一种数据类型==。要定义类，需要描述它能够表示什么信息和可对数据执行哪些操作。类之于对象就像类型之于变量。也就是说，类定义描述的是数据格式及其用法，而对象则是根据格式规范的实体。换句话说，如果说类就好比所有著名演员，则对象就好比某个著名的演员。</p>
<p>注意：==类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。==</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>由于函数用于创建C++程序的模块，对C++的OOP定义至关重要。</p>
<h5 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h5><p>有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，标准C/C++库包含一个名为sqrt（）的函数，它返回平方根。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line">x = <span class="built_in">sqrt</span>(<span class="number">6.25</span>); <span class="comment">//return the value 2.5 and assigns it to x</span></span><br></pre></td></tr></table></figure>

<p>表达式sqrt（6.25）将调用sqrt（）函数。表达式sqrt(6.25)被称为函数调用。</p>
<p>被调用的函数叫做被调用函数（called function），包含函数调用的函数叫做调用函数（calling function）。</p>
<p><strong>注意：C++程序应当为程序中使用的每个函数提供原型。</strong></p>
<p>在程序中使用sqrt（）时，也必须提供原型。可以用两种方法来实现：</p>
<ul>
<li>在源代码文件中输入函数原型；</li>
<li>包含头文件cmath（老系统为math.h），其中定义了原型。</li>
</ul>
<p>第二种方法更好，因为==头文件更有可能使原型正确==。对于C++库中的每个函数，都在一个或多个头文件中提供了原型。请通过手册或在线帮助查看函数描述来确定应使用哪个头文件。例如：sqrt（）函数的说明指出，应使用cmath头文件。（同样，可能必须使用老式的头文件math.h，它可用于C和C++程序中。）</p>
<p>不要混淆函数原型和函数定义。可以看出，原型只描述函数接口。也就是说，它描述的是发送给函数的信息和返回的信息。而定义中包含了函数的代码，如计算平方根的代码。</p>
<p>C和C++将库函数的这两项特性（原型和定义）分开了。==库文件中包含了函数的编译代码，而头文件中则包含了原型。==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>   <span class="comment">//or math.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the floor area,in square feet,of your home:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; area;</span><br><span class="line">    <span class="type">double</span> side;</span><br><span class="line">    side = <span class="built_in">sqrt</span>(area);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;That&#x27;s the equivalent of a square &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot; feet to the side.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How fascinating!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter the floor area,in square feet,of your home:</span><br><span class="line">1536</span><br><span class="line">That&#x27;s the equivalent of a square 39.1918 feet to the side.</span><br><span class="line">How fascinating!</span><br></pre></td></tr></table></figure>

<p>C++允许在程序 的任何地方声明新变量，因此sqrt.cpp在要使用side时才声明它。</p>
<p>==C++还允许在创建变量时对它进行赋值==:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> side = <span class="built_in">sqrt</span>(area);</span><br></pre></td></tr></table></figure>

<p>这个过程叫做<strong>初始化</strong>（initialization）,cin知道如何将输入流中的信息转换为double类型，cout知道如何将double类型插入到输出流中。这些对象都很智能化。</p>
<h5 id="函数变体"><a href="#函数变体" class="headerlink" title="函数变体"></a>函数变体</h5><p>有些函数需要多项信息。这些函数使用多个参数，参数之间用逗号分开。</p>
<p>例如，数学函数pow()接受两个参数，返回值为以第一个参数为底，第二个参数为指数的幂。</p>
<p>该函数的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>; <span class="comment">//prototype of a function with two arguments</span></span><br></pre></td></tr></table></figure>

<p>要计算5的8次方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">answer = <span class="built_in">pow</span>(<span class="number">5.0</span>,<span class="number">8.0</span>);</span><br></pre></td></tr></table></figure>

<p>另外一些函数不接受任何参数。例如，有一个C库（cstdlib或stdlib.h头文件相关的库）包含一个rand（）函数，该函数不接受任何参数，并返回一个随机整数。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//prototype of a function that takes no arguments</span></span><br></pre></td></tr></table></figure>

<p>关键字void明确指出，该函数不接受任何参数。如果省略void，让括号为空，则C++将其解释为一个不接受任何参数的隐式声明。</p>
<p>可以这样使用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myGuess = <span class="built_in">rand</span>();	<span class="comment">//function call with no arguments</span></span><br></pre></td></tr></table></figure>

<h5 id="用户定义函数"><a href="#用户定义函数" class="headerlink" title="用户定义函数"></a>用户定义函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simon</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//function protype for simon()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simon</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pick an integer: &quot;</span> ;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    cin &gt;&gt; count;</span><br><span class="line">    <span class="built_in">simon</span>(count);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simon</span><span class="params">(<span class="type">int</span> n)</span>	<span class="comment">//define the simon() function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Simon says touch yours toes &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;times.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simon says touch yours toes 3 times.</span><br><span class="line">Pick an integer: 512</span><br><span class="line">Simon says touch yours toes 512 times.</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<p><strong>函数格式</strong></p>
<p>simon()函数的定义与main()的定义采用的格式相同。首先，有一个函数头，然后是花括号中的函数体。可以把函数的格式统一为如下的情形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type functionname(argumentlist)</span><br><span class="line">&#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++不允许将函数定义嵌套在另一个函数定义中。每个函数定义都是独立的，所有函数的创建都是平等的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line"><span class="comment">//通常的约定是，退出值（返回值）为0则意味着程序运行成功，为非零则意味着存在问题。</span></span><br></pre></td></tr></table></figure>

<h5 id="有返回值的函数-1"><a href="#有返回值的函数-1" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stonetolb</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//function prototype</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> stone;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the weight in stone: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; stone;</span><br><span class="line">    <span class="type">int</span> pounds = <span class="built_in">stonetolb</span>(stone);</span><br><span class="line">    cout &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds. &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stonetolb</span><span class="params">(<span class="type">int</span> sts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14</span> * sts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter the weight in stone: 15</span><br><span class="line">15 stone = 210 pounds.</span><br></pre></td></tr></table></figure>

<p>如果返回表达式的值很麻烦，可以采取更复杂的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stonetolb</span><span class="params">(<span class="type">int</span> sts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pounds = <span class="number">14</span> * sts;</span><br><span class="line">    <span class="keyword">return</span> pounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，在可以使用一个简单常量的地方，都可以使用一个返回值类型与该常量相同的函数。例如：stonetolb()返回一个int值，这意味着可以这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> aunt = <span class="built_in">stonetolb</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> aunts = aunt + <span class="built_in">stonetolb</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Perdie weights &quot;</span> &lt;&lt; <span class="built_in">stonetolb</span>(<span class="number">16</span>) &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>这些例子表明，<strong>函数原型描述了函数接口，即函数如何与程序的其他部分交互。参数列表指出了何种信息将被传递给函数，函数类型指出了返回值的类型。</strong></p>
<h5 id="在多函数程序中使用using编译指令"><a href="#在多函数程序中使用using编译指令" class="headerlink" title="在多函数程序中使用using编译指令"></a>在多函数程序中使用using编译指令</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>这是因为每个函数都使用了cout，因此需要能够访问位于名称空间std中的cout定义。</p>
<p>让程序能够访问名称空间std的方法有很多种，下面是其中的4种：</p>
<ul>
<li><p>将<code>using namespace std;</code>放在函数定义之前，让文件中所有的函数都能够使用名称空间std中所有的元素。</p>
</li>
<li><p>将<code>using namespace std;</code>放在特定的函数定义中，让该函数能够使用名称空间std中的所有元素。</p>
</li>
<li><p>在特定的函数中使用类似<code>using std::cout;</code>这样的编译指令，而不是<code>using namespace std;</code>，让该函数能够指定的元素，如cout。</p>
</li>
<li><p>完全不使用编译指定using，而在需要使用名称空间std中的元素时，使用前缀<code>std::</code>,如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;I&#x27;m using cout and endl from the std namespace&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章  处理数据"></a>第三章  处理数据</h3><p>面向对象编程（OOP）的本质时设计并扩展自己的数据类型。设计自己的数据类型就是让自己类型与数据匹配。</p>
<h4 id="3-1-简单变量"><a href="#3-1-简单变量" class="headerlink" title="3.1 简单变量"></a>3.1 简单变量</h4><h5 id="变量名："><a href="#变量名：" class="headerlink" title="变量名："></a>变量名：</h5><p>C++提倡使用有一定含义的变量名，如果变量表示差旅费，应将其命名为cost_of_trip 或者 costOfTrip，而不要将其命名为x或cot。必须遵循几种简单的C++命名规则。</p>
<ul>
<li>在名称中只能使用字母字符、数字和下划线。</li>
<li>名称的第一个字符不能是数字。</li>
<li>区分大写字符与小写字符。</li>
<li>不能将C++关键字用作名称。</li>
<li>以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。</li>
<li>C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。</li>
</ul>
<p>倒数第二点与前面几点有些不同，因为使用像_time_stop 或  _Donut这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话说，不知道结果将会是什么。不出现编译器错误的原因是：这样的名称不是非法的，但是留给实现使用。全局名称指的是名称被声明的位置。</p>
<p>如果想用两个或者更多的单词组成一个名称，通常的做法是用下划线将单词分开，如 my_oninons；或者从第二个单词开始将每个单词的第一个字母大写，如 myEyeTooth。</p>
<h5 id="整型："><a href="#整型：" class="headerlink" title="整型："></a>整型：</h5><p>不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大，另外，有的类型（符号类型）可表示正值和负值，而有的类型（无符号类型）不能表示负值。</p>
<p>C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long ,其中其中每种类型都有符号版本和无符号版本因此总共有10种类型可供选择。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> score;	<span class="comment">//creates a type short integer variable</span></span><br><span class="line"><span class="type">int</span> temperature;	<span class="comment">//creates a type int integer variable</span></span><br><span class="line"><span class="type">long</span> position;	<span class="comment">//creates a type long integer variable</span></span><br></pre></td></tr></table></figure>

<p>想知道系统中整数的最大长度，可以在程序中使用C++ 工具来检查类型的长度。</p>
<p>==sizeof 运算符返回类型或变量的长度，单位字节==（运算符是内置的语言元素，对一个或多个数据进行运算，并生成一个值。例如，加号运算符【+】将两个值相加）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span>		<span class="comment">//use limits.h for older systems</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n_int = INT_MAX;	<span class="comment">//initialize n_int max int value</span></span><br><span class="line">    <span class="type">short</span> n_short = SHRT_MAX;	<span class="comment">//symbols defined in climits file</span></span><br><span class="line">    <span class="type">long</span> n_long = LONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n_llong = LLONG_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sizeof operator yields size of type or o variable</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> n_short &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> n_long &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long long is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> n_llong &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum values:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; n_int &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short: &quot;</span> &lt;&lt; n_short &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long: &quot;</span> &lt;&lt; n_long &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long long :&quot;</span> &lt;&lt; n_llong &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum int value = &quot;</span> &lt;&lt; INT_MIN &lt;&lt; endl&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BITS per byte = &quot;</span> &lt;&lt; CHAR_BIT &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int is 4 bytes.</span><br><span class="line">short is 2 bytes.</span><br><span class="line">long is 4 bytes.</span><br><span class="line">long long is 8 bytes.</span><br><span class="line"></span><br><span class="line">Maximum values:</span><br><span class="line">int: 2147483647</span><br><span class="line">short: 32767</span><br><span class="line">long: 2147483647</span><br><span class="line">long long :9223372036854775807</span><br><span class="line"></span><br><span class="line">Minimum int value = -2147483648</span><br><span class="line">BITS per byte = 8</span><br></pre></td></tr></table></figure>

<p>注意：如果您的系统不支持类型long long，应删除使用该类型的代码行。</p>
<p><strong>运算符sizeof 和 头文件 limits</strong></p>
<p>==可对类型名或变量名使用sizeof运算符==。对类型名（如 int）使用sizeof 运算符时，应将名称放在括号中；但对变量名（如 n_short）使用该运算符，括号时可选的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;int is&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;bytes.\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short is&quot;</span> &lt;&lt; <span class="keyword">sizeof</span> n_short &lt;&lt; <span class="string">&quot;bytes.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>climits文件中包含与下面类似的语句行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX 32767</span></span><br></pre></td></tr></table></figure>

<p>在C++编译过程中，首先将源代码传递给预处理器。在这里，#define和#include 一样，也是一个预处理器编译指令。该编译指令告诉预处理器：在程序中查找 INT_MAX，并将所有的INT_MAX 都替换为32767。因此#define 编译指令的工作方式与文本编辑器或字处理器中的全局搜索并替换命令相似。</p>
<p><strong>#define 编译指令是 C 语言留下来的，C++有一种更好的创建符号常量的方法（使用关键字const ），所以不会经常使用#define。</strong>然而，有些头文件，尤其是那些被设计成可用于C和C++中的头文件，必须使用#define。</p>
<p><strong>初始化</strong></p>
<p>初始化将赋值与声明合并在一起。例如，下面的语句声明了变量n_int,并将int的最大取值赋给它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n_int = INT_MAX;</span><br></pre></td></tr></table></figure>

<p>也可以使用字面值常量来初始化。可以将变量初始化为另一个变量，条件是后者已经定义过。</p>
<p>甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中所有的值都是已知的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> uncles = <span class="number">5</span>;		<span class="comment">//initialize uncles to 5</span></span><br><span class="line"><span class="type">int</span> aunts = uncles;		<span class="comment">//initialize aunts to 5</span></span><br><span class="line"><span class="type">int</span> chairs = aunts + uncles + <span class="number">4</span>;	<span class="comment">//initialize chairs to 14</span></span><br></pre></td></tr></table></figure>

<p><strong>C++11 初始化方式</strong></p>
<p>有一种初始化方式用于数组和结构，但在C++98 中，也可以用于单值变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hamburgers = &#123;<span class="number">24</span>&#125;;  <span class="comment">// set hamburgers to 24</span></span><br></pre></td></tr></table></figure>

<p>将大括号初始化器用于单值变量的情形还不多，但在C++11 标准使得这种情形更多了。首先，采用这种方式时，可以使用等号（=），也可以不使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> emus&#123;<span class="number">7</span>&#125;;	<span class="comment">//set emus to 7</span></span><br><span class="line"><span class="type">int</span> rheas = &#123;<span class="number">12</span>&#125;; 	<span class="comment">//set rheas to 12</span></span><br></pre></td></tr></table></figure>

<p>其次，<strong>大括号内可以不包含任何东西。在这种情况下，变量将初始化为零。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rocs = &#123;&#125;;	<span class="comment">// set rocs to 0</span></span><br><span class="line"><span class="type">int</span> psychics&#123;&#125;;		<span class="comment">//set psychics to 0</span></span><br></pre></td></tr></table></figure>

<h5 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h5><p>整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。</p>
<p>例如，如果short表示的范围为-32768 到 +32767 ，则无符号版本的表示范围为 0 ~ 65535.当然，仅当数值不会为负时才应使用无符号类型。</p>
<p>要创建无符号版本的基本整型，只需使用关键字unsigned 来修改声明即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> change;	<span class="comment">//unsigned short type</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rovert;	<span class="comment">//unsigned int type</span></span><br><span class="line"><span class="type">unsigned</span> quarterback;	<span class="comment">//also unsigned int </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> gone;		<span class="comment">//unsigned long type</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> lang_lang;	<span class="comment">//unsigned long long type</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>unsigned 本身是 unsigned int 的缩写</strong>。</p>
<p>看一看预处理器语句 #define</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZERO 0	<span class="comment">//makes ZERO symbol for 0 value</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span> <span class="comment">//defines INT_MAX as largest int value</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> sam = SHRT_MAX;	<span class="comment">//initialize a variable to max value</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sue = sam;	<span class="comment">//okay if variable sam already defined</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="string">&quot; dollars and Sue has &quot;</span> &lt;&lt; sue;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; dollars deposited.&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;Add $1 to each account.&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Now &quot;</span>;</span><br><span class="line">    sam = sam + <span class="number">1</span>;</span><br><span class="line">    sue = sue + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="string">&quot; dollars and Sue has &quot;</span> &lt;&lt; sue;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; dollars deposited.\nPoor Sam!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sam = ZERO;</span><br><span class="line">    sue = ZERO;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="string">&quot; dollars and Sue has &quot;</span> &lt;&lt; sue;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; dollars deposited.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Take $1 from each account.&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Now &quot;</span>;</span><br><span class="line">    sam = sam <span class="number">-1</span>;</span><br><span class="line">    sue = sue <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="string">&quot; dollars and Sue has &quot;</span> &lt;&lt; sue;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; dollars deposited.&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Lucky Sue!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sam has 32767 dollars and Sue has 32767 dollars deposited.</span><br><span class="line">Add $1 to each account.</span><br><span class="line">Now Sam has -32768 dollars and Sue has 32768 dollars deposited.</span><br><span class="line">Poor Sam!</span><br><span class="line">Sam has 0 dollars and Sue has 0 dollars deposited.</span><br><span class="line">Take $1 from each account.</span><br><span class="line">Now Sam has -1 dollars and Sue has 65535 dollars deposited.</span><br><span class="line">Lucky Sue!</span><br></pre></td></tr></table></figure>

<h5 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> chest = <span class="number">42</span>;		<span class="comment">// decimal integer literal</span></span><br><span class="line">    <span class="type">int</span> waist = <span class="number">0x42</span>;	<span class="comment">// hexadecimal integer literal</span></span><br><span class="line">    <span class="type">int</span> inseam = <span class="number">042</span>;  	<span class="comment">// octal integer literal</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Monsieur cuts a striking figure!\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;chest = &quot;</span> &lt;&lt; chest &lt;&lt; <span class="string">&quot;(42 in decimal)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;waist = &quot;</span> &lt;&lt; waist &lt;&lt; <span class="string">&quot;(0x42 in hex)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inseam = &quot;</span> &lt;&lt; inseam &lt;&lt; <span class="string">&quot;(042 in octal)\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Monsieur cuts a striking figure!</span><br><span class="line">chest = 42(42 in decimal)</span><br><span class="line">waist = 66(0x42 in hex)</span><br><span class="line">inseam = 34(042 in octal)</span><br></pre></td></tr></table></figure>

<p><strong>控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> chest = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> waist = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> inseam = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Monsieur cuts a striking figure!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;chest = &quot;</span> &lt;&lt; chest &lt;&lt; <span class="string">&quot;(decimal for 42)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex;	<span class="comment">//manipulator for changing number base</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;waist = &quot;</span> &lt;&lt; waist &lt;&lt; <span class="string">&quot;(hexadecimal for 42)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; oct;	<span class="comment">//manipulator for changing number base</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inseam = &quot;</span> &lt;&lt; inseam &lt;&lt; <span class="string">&quot;(octal for 42)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Monsieur cuts a striking figure!</span><br><span class="line">chest = 42(decimal for 42)</span><br><span class="line">waist = 2a(hexadecimal for 42)</span><br><span class="line">inseam = 52(octal for 42)</span><br></pre></td></tr></table></figure>

<p>诸如<code>cout &lt;&lt; hex;</code> 等代码不会在屏幕上显示任何内容，而只是修改cout显示整数的方式。</p>
<p>因此，控制符hex实际上是一条消息，告诉cout采取何种行为。</p>
<h5 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="C++如何确定常量的类型"></a>C++如何确定常量的类型</h5><p>程序的声明将特定的整数变量的类型告诉了C++编译器，但编译器是如何知道常量的类型呢？假设在程序中使用常量表示一个数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Year = &quot;</span> &lt;&lt; <span class="number">1492</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>程序将把1492存储为int、long还是其他整型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储int），否则C++将整型常量存储为int类型。</p>
<h5 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;	<span class="comment">//declare a char variable</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hola!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thank you for the &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; character.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter a character:</span><br><span class="line">M</span><br><span class="line">Hola!Thank you for the M character.</span><br></pre></td></tr></table></figure>

<p>有趣的是，程序中输入的是M，而不是对应的字符编码77。另外，程序将打印M,而不是77.</p>
<p>通过查看内存可知，77是存储在变量ch中的值，这种神奇的力量不是来自char类型，而是来自cin和cout，这些工具为您完成了转换工作。</p>
<p>输入时，cin将键盘输入的M转换为77；输出时，cout将值77转换为所显示的字符M；cin和cout的行为都是由变量类型引导的。</p>
<p><strong>cout.put()函数</strong></p>
<p>程序引入了cout的一项特性：cout.put()函数，该函数显示一个字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;M&#x27;</span>;	<span class="comment">//assign ASCII code for M to ch</span></span><br><span class="line">    <span class="type">int</span> i = ch; 	<span class="comment">//store same code in and int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The ASCII code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add one to the character code:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ch = ch + <span class="number">1</span>;	<span class="comment">//change character  code in ch</span></span><br><span class="line">    i = ch;		<span class="comment">//save new character code in i</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The ASCII code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//using the cout.put() member function to dispaly a char</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Displaying char ch using cout.put(ch):&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">put</span>(ch);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//using cout.put() to display a char constant</span></span><br><span class="line">    cout.<span class="built_in">put</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Done&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The ASCII code for M is 77</span><br><span class="line">Add one to the character code:</span><br><span class="line">The ASCII code for N is 78</span><br><span class="line">Displaying char ch using cout.put(ch):N!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>C++将字符表示为整数提供了方便，使得操纵字符值很容易。不必使用笨重的转换函数在字符和ASCII码之间来回转换。</p>
<p>即使通过键盘输入的数字也将被视为字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line"><span class="comment">//如果您输入5并按回车键，则读取字符“5”，并将其对应的字符编码（ASCII 编码 53）存储到变量ch中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//如果您输入5并按回车键，则读取字符“5”，并将其转换为相应的数字值5，并存储到变量n中。</span></span><br></pre></td></tr></table></figure>

<h5 id="char字面值"><a href="#char字面值" class="headerlink" title="char字面值"></a>char字面值</h5><p>在C++中，书写字符常量的方式有多种，对于常规字符（如字母、标点符号和数字），最简单的方法是<strong>将字符用单引号括起</strong>。这种表示法代表的是字符的数值编码。</p>
<p>例如：ASCII系统中的对应情况如下：</p>
<ul>
<li>‘A’为65，即字符A的ASCII码</li>
<li>‘a’为97，即字符a的ASCII码</li>
<li>‘5’为53，即数字5 的ASCII码</li>
<li>‘’为32，即空格字符的ASCII码</li>
<li>‘!’为33，即惊叹号的ASCII码</li>
</ul>
<p>有些字符不能直接通过键盘输入到程序中。例如，按回车键不能使字符包含换行符。</p>
<p>C++提供了一种特殊的表示方法：转义序列。</p>
<p>转义序列\n表示换行符。\a表示振铃字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> alarm = <span class="string">&#x27;\a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; alarm &lt;&lt; <span class="string">&quot;Don&#x27;t do that again!\a\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Ben \&quot;Buggsie\&quot; Hacker \n was here!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一行输出如下：</span></span><br><span class="line">Ben <span class="string">&quot;Buggsie&quot;</span> Hacker</span><br><span class="line">was here!</span><br></pre></td></tr></table></figure>

<p><strong>C++转义序列的编码</strong></p>
<table>
<thead>
<tr>
<th>字符名称</th>
<th>ASCII符号</th>
<th>C++代码</th>
<th>十进制ASCII码</th>
<th>十六进制ASCII码</th>
</tr>
</thead>
<tbody><tr>
<td>换行符</td>
<td>NL(LF)</td>
<td>\n</td>
<td>10</td>
<td>0xA</td>
</tr>
<tr>
<td>水平制表符</td>
<td>HT</td>
<td>\t</td>
<td>9</td>
<td>0x9</td>
</tr>
<tr>
<td>垂直制表符</td>
<td>VT</td>
<td>\v</td>
<td>11</td>
<td>0xB</td>
</tr>
<tr>
<td>退格</td>
<td>BS</td>
<td>\b</td>
<td>8</td>
<td>0x8</td>
</tr>
<tr>
<td>回车</td>
<td>CR</td>
<td>\r</td>
<td>13</td>
<td>0xD</td>
</tr>
<tr>
<td>振铃</td>
<td>BEL</td>
<td>\a</td>
<td>7</td>
<td>0x7</td>
</tr>
<tr>
<td>反斜杠</td>
<td>\</td>
<td>\\</td>
<td>92</td>
<td>0x5C</td>
</tr>
<tr>
<td>问号</td>
<td>?</td>
<td>?</td>
<td>63</td>
<td>0x3F</td>
</tr>
<tr>
<td>单引号</td>
<td>‘</td>
<td>\ ‘</td>
<td>39</td>
<td>0x27</td>
</tr>
<tr>
<td>双引号</td>
<td>“</td>
<td>\ “</td>
<td>34</td>
<td>0x22</td>
</tr>
</tbody></table>
<p>注意：应该像处理常规字符（如Q）那样处理转义序列（如\n）。也就是说，==将它们作为字符常量时，应用单引号括起；将它们放在字符串中时，不要使用单引号。==</p>
<p>换行符可替代endl，用于在输出中重起一行。可以义字符常量表示法（’\n’）或字符串方式（”n”）使用换行符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; endl;	<span class="comment">//using the endl manipulator</span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;	<span class="comment">//using a character constant</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;	<span class="comment">//using a string</span></span><br></pre></td></tr></table></figure>

<p><strong>可以将换行符嵌入到较长的字符串中，这通常比使用endl方便</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; <span class="string">&quot;What next?&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Enter a number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n\n What next? \n Enter a number: \n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>显示数字时，使用endl比输入”\n”或’\n’更容易点，但显示字符串时，在字符串末尾添加一个换行符所需的输入量要少一些：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; x &lt;&lt; endl;	<span class="comment">//easier than cout &lt;&lt; X &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Dr. X. \n&quot;</span>;	<span class="comment">//easier than cout &lt;&lt; &quot;The Dr.X.&quot; &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<p>Houdini曾经在只使用转义序列的情况下，绘制了一副哈得逊河图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\aOperation \&quot;HyperHype\&quot; is now activated!\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your agent code:_________\b\b\b\b\b\b\b\b&quot;</span>;</span><br><span class="line">    <span class="type">long</span> code;</span><br><span class="line">    cin &gt;&gt; code;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\aYou entered &quot;</span> &lt;&lt; code &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\aCode verified! Proceed with Plan Z3!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="signed-char-和-unsigned-char"><a href="#signed-char-和-unsigned-char" class="headerlink" title="signed char 和 unsigned char"></a>signed char 和 unsigned char</h5><p>与int 不同的是，char 在默认情况下既不是没有符号，也不是有符号，是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。</p>
<p>如果char有某种特定的行为对您来说非常重要，则可以显示地将类型设置为signed char或 unsigned char：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fodo;	<span class="comment">//may be signed, may be unsigned</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bar;	<span class="comment">//definitely unsigned</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> snark;	<span class="comment">//definitely signed</span></span><br></pre></td></tr></table></figure>

<p>unsigned char类型的表示范围通常为0 ~ 255，而signed char 的表示范围为 -128 ~ 127。</p>
<h5 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h5><p>ANSI/ISO C++标准添加了一种名叫bool的新类型（对C++来说是新的）。在计算中，布尔变量的值可以是true或false。</p>
<p>==C++将非零值解释为true，将零解释为false。==</p>
<p>可以使用bool类型来表示真（true）和假（false）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_ready = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字面值true 和false 都可以通过提升转换为int类型，true被转换为1，而false被转换为0；</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="literal">true</span>;		<span class="comment">// ans assigned 1</span></span><br><span class="line"><span class="type">int</span> promise = <span class="literal">false</span>;	<span class="comment">// promise assigned 0</span></span><br></pre></td></tr></table></figure>

<p>另外，任何数字值或指针值都可以被隐式转换（即不用显示强制转换）为bool值。<strong>任何非零值都被转换为true，而零被转换为false。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> start = <span class="number">-100</span>;	<span class="comment">// start assigned true</span></span><br><span class="line"><span class="type">bool</span> stop = <span class="number">0</span>;		<span class="comment">// stop assigned false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-const-限定符"><a href="#3-2-const-限定符" class="headerlink" title="3.2 const 限定符"></a>3.2 const 限定符</h4><p>常量的符号名称指出了常量表示的内容。另外，如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可。</p>
<p>前面有介绍过#define语句的说明，C++有一种更好的处理符号常量的方法，这种方法就是==使用const关键字来修改变量声明和初始化==。</p>
<p>例如：假设需要一个表示一年中月份数的符号常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;	<span class="comment">//MOnths is symbolic constant for 12</span></span><br></pre></td></tr></table></figure>

<p>常量被初始化后，其值就被固定了，编译器将不允许再修改该常量的值。</p>
<p><strong>关键字const叫做限定符，因为它限定了声明的含义。</strong></p>
<p>一种常见的做法是将名称的首字母大写，已提醒您Months是个常量，有助于区分常量和变量。另一种约定是将整个名称大写，使用#define 创建常量时通常使用这种约定。</p>
<p>创建常量的通用格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> type name = value;</span><br></pre></td></tr></table></figure>

<p>注意：应在声明中对const进行初始化。下面的代码不好：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> toes;	<span class="comment">//value of toes undefined at this point</span></span><br><span class="line">toes = <span class="number">10</span>;	<span class="comment">// tool late!</span></span><br></pre></td></tr></table></figure>

<p>如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。</p>
<p>提示：<strong>如果打算使用#define来定义符号常量，请不要这样做，而应使用const。</strong></p>
<h4 id="3-3-浮点数"><a href="#3-3-浮点数" class="headerlink" title="3.3 浮点数"></a>3.3 浮点数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::fixed,ios_base::floatfield); <span class="comment">//fixed-point</span></span><br><span class="line">    <span class="type">float</span> tub = <span class="number">10.0</span> / <span class="number">3.0</span>;	<span class="comment">//good to about 6 places</span></span><br><span class="line">    <span class="type">double</span> mint = <span class="number">10.0</span> / <span class="number">3.0</span>;	<span class="comment">//	good to about 15 places</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> million = <span class="number">1.0e6</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tub = &quot;</span> &lt;&lt; tub;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, a million tubs = &quot;</span> &lt;&lt; million * tub;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,\n and ten million tubs = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="number">10</span> * million * tub &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mint = &quot;</span> &lt;&lt; mint &lt;&lt; <span class="string">&quot; and a million mints = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; million * mint &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tub = 3.333333, a million tubs = 3333333.250000,</span><br><span class="line">and ten million tubs = 33333332.000000</span><br><span class="line">mint = 3.333333 and a million mints = 3333333.333333</span><br></pre></td></tr></table></figure>

<h5 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h5><p>==在默认情况下，浮点常量都属于double类型。==如果希望常量为float类型，请使用f或者F后缀。</p>
<p>对于long double类型，可使用l或者L后缀（由于l看起来像数字1，因此L是更好的选择）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.234f</span>	<span class="comment">//a float constant</span></span><br><span class="line"><span class="number">2.45E20</span>F	<span class="comment">// a float constant</span></span><br><span class="line"><span class="number">2.345324E28</span>		<span class="comment">//a double constant</span></span><br><span class="line"><span class="number">2.2L</span>	<span class="comment">// a long double constant</span></span><br></pre></td></tr></table></figure>

<h5 id="浮点数的优缺点"><a href="#浮点数的优缺点" class="headerlink" title="浮点数的优缺点"></a>浮点数的优缺点</h5><p>与整数相比，浮点数有两大点。首先，它们可以表示整数之间的值；其次，由于有缩放因子，它们可以表示的范围大得多。另一方面，浮点运算的速度通常比整数运算慢，且精度将降低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.34E+22</span>f;</span><br><span class="line">    <span class="type">float</span> b = a + <span class="number">1.0f</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b - a = &quot;</span> &lt;&lt; b-a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有些基于ANSI C 之前的编译器的老式C++实现不支持浮点数常量后缀f。如果出现这样的问题，可用2.34E+22代替 2.34E+22f，用（float）1.0 代替 1.0f。</p>
<h4 id="3-4-C-算术运算符"><a href="#3-4-C-算术运算符" class="headerlink" title="3.4 C++算术运算符"></a>3.4 C++算术运算符</h4><h5 id="除法分支"><a href="#除法分支" class="headerlink" title="除法分支"></a>除法分支</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::fixed,ios_base::floatfield);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Integer division: 9/5 = &quot;</span> &lt;&lt; <span class="number">9</span> / <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Floating-point division: 9.0/5.0 = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="number">9.0</span> / <span class="number">5.0</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mixed division: 9.0 / 5 = &quot;</span> &lt;&lt; <span class="number">9.0</span> / <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double constants: 1e7/9.0 = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="number">1.e7</span> / <span class="number">9.0</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float constants: 1e7f / 9.0f = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="number">1.e7</span>f / <span class="number">9.0f</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer division: 9/5 = 1</span><br><span class="line">Floating-point division: 9.0/5.0 = 1.800000</span><br><span class="line">Mixed division: 9.0 / 5 = 1.800000</span><br><span class="line">double constants: 1e7/9.0 = 1111111.111111</span><br><span class="line">float constants: 1e7f / 9.0f = 1111111.125000</span><br></pre></td></tr></table></figure>

<p>可以用（float）1.e7 / (float)9.0 代替 1.e7f / 9.0f。</p>
<p>实际上，对不同类型进行运算时，C++将把它们全部转换为同一类型。</p>
<p>如果两个操作符都是double类型，则结果为double类型；如果两个操作符都是float类型，则结果为float类型。记住，<strong>浮点常量在默认情况下为double类型</strong>。</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> auks,bats,coots;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//the following statement adds the value as double </span></span><br><span class="line">    <span class="comment">//then coverts the result to int</span></span><br><span class="line">    auks = <span class="number">19.9</span> + <span class="number">11.9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//these statements add values as int </span></span><br><span class="line">    bats = (<span class="type">int</span>)<span class="number">19.99</span> + (<span class="type">int</span>)<span class="number">11.99</span>; 	<span class="comment">// old C syntax</span></span><br><span class="line">    coots = <span class="built_in">int</span> (<span class="number">19.99</span>) + <span class="built_in">int</span> (<span class="number">11.99</span>);	<span class="comment">// new C++ syntax</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;auks = &quot;</span> &lt;&lt; auks &lt;&lt; <span class="string">&quot;, bats = &quot;</span> &lt;&lt; bats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,coots = &quot;</span> &lt;&lt; coots &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; is &quot;</span>;	<span class="comment">//print as char</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(ch) &lt;&lt; endl;	<span class="comment">//print as int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes,the code is &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ch) &lt;&lt; endl;	<span class="comment">//using static_cast</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auks = 31, bats = 30,coots = 30</span><br><span class="line">The code for Z is 90</span><br><span class="line">Yes,the code is 90</span><br></pre></td></tr></table></figure>

<h5 id="C-11-中的auto声明"><a href="#C-11-中的auto声明" class="headerlink" title="C++11 中的auto声明"></a>C++11 中的auto声明</h5><p>C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。auto时一个C语言关键字，但很少使用。</p>
<p>==如果使用关键字auto，而不指明变量的类型，编译器将把变量的类型设置成与初始值相同。==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">100</span>;	<span class="comment">// n is int</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1.5</span>;	<span class="comment">// x is double</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">1.3e12</span>L;	<span class="comment">// y is long double</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。</p>
<p>整型从最小到最大依次是：bool、char、signed  char、unsigned char 、short 、unsigned short 、int 、unsigned int、long 、unsigned long 以及C++新增的long long 和 unsigned long long。</p>
<h3 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章  复合类型"></a>第四章  复合类型</h3><h4 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h4><p>数组（array）是一种数据格式，能够存储多个同类型的值。</p>
<p>例如，数组可以存储60个int类型的值、12个short值（这些值表示每个月的天数）或365个float值（这些值指出一年中每天在食物方面的开销）。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。</p>
<p>要创建数组，可使用声明语句。数组声明应指出以下三点：</p>
<ul>
<li>存储在每个元素中的值的类型；</li>
<li>数组名；</li>
<li>数组中的元素数。</li>
</ul>
<p>在C++中，可以通过修改简单变量的声明，添加中括号（其中包括元素数目）来完成数组声明。例如：声明创建一个名为months的数组，该数组有12个元素，每个元素都可以存储一个short类型的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> months[<span class="number">12</span>];	<span class="comment">//create array of 12 short</span></span><br></pre></td></tr></table></figure>

<p>事实上，可将数组中的每个元素看作是一个简单变量。</p>
<p>数组声明的通用格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize];</span><br></pre></td></tr></table></figure>

<p>表达式arraySize 指定元素数组，它必须是整型常数（如10）或 const值，也可以是常量表达式（8 * sizeof(int)）,即其中所有的值在编译时都是 已知的。具体来说，arraySize不能是变量，变量的值是在程序运行时设置的。然而，可以使用new运算符来避开这种限制。</p>
<p>数组之所以被称为复合类型，是因为它是使用其他类型来创建的。不能仅仅将某种东西声明为数组，它必须是特定类型的数组。没有通用的数组类型，但存在很多特定的数组类型，如char数组或者long数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> loans[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>loans 的类型不是“数组”，而是“float数组”。这强调了loans数组是使用float类型创建的。</p>
<p>数组的很多用途都是基于这样的一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。<strong>C++数组从0开始编号</strong>。C++使用带索引的方括号表示法来指定数组元素。</p>
<p>注意：最后一个元素的索引比数组长度小1。因此，数组声明能够使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yams[<span class="number">3</span>];	<span class="comment">// creates array with three elements</span></span><br><span class="line">    yams[<span class="number">0</span>] = <span class="number">7</span>;	<span class="comment">// assign value to first element</span></span><br><span class="line">    yams[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">    yams[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> yamcosts[<span class="number">3</span>] = &#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">5</span>&#125;;	<span class="comment">//create,initialize array</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total yams = &quot;</span> ;</span><br><span class="line">    cout &lt;&lt; yams[<span class="number">0</span>] + yams[<span class="number">1</span>] + yams[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The package with &quot;</span> &lt;&lt; yams[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; yams costs&quot;</span>;</span><br><span class="line">    cout &lt;&lt; yamcosts[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; cents per yam.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> total = yams[<span class="number">0</span>] * yamcosts[<span class="number">0</span>] + yams[<span class="number">1</span>] * yamcosts[<span class="number">1</span>];</span><br><span class="line">    total = total + yams[<span class="number">2</span>] * yamcosts[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The total yam expense is &quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot; cents.\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nSize of yams array = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> yams;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of one element = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> yams[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Total yams = 21</span><br><span class="line">The package with 8 yams costs30 cents per yam.</span><br><span class="line">The total yam expense is 410 cents.</span><br><span class="line"></span><br><span class="line">Size of yams array = 12 bytes.</span><br><span class="line">Size of one element = 4 bytes.</span><br></pre></td></tr></table></figure>

<h5 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h5><p>只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;	<span class="comment">// okay</span></span><br><span class="line"><span class="type">int</span> hand[<span class="number">4</span>];	<span class="comment">// okay</span></span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;	<span class="comment">// not allowed</span></span><br><span class="line">hand = cards;	<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure>

<p>然而，可以使用下标分别给数组中的元素赋值。</p>
<p>初始化数组时，提供的值可以少于数组的元素数目。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> hotelTips[<span class="number">5</span>] = &#123;<span class="number">5.0</span>,<span class="number">2.5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0.因此，将数组中所有的元素都初始化为0非常简单：只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> totals[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0。</p>
<p>如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> things[] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器将使things数组包含4个元素。</p>
<h5 id="C-11-数组初始化方法"><a href="#C-11-数组初始化方法" class="headerlink" title="C++11 数组初始化方法"></a>C++11 数组初始化方法</h5><p>C++11中的列表初始化新增了一些功能。</p>
<p>首先，初始化数组时，可省略等号（=）；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">4</span>] &#123;<span class="number">1.2e4</span>,<span class="number">1.6e4</span>,<span class="number">1.1e4</span>,<span class="number">1.7e4</span>&#125;;	<span class="comment">//okay with c++11 </span></span><br></pre></td></tr></table></figure>

<p>其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> counts[<span class="number">10</span>] = &#123;&#125;;	<span class="comment">// all elements set to 0</span></span><br><span class="line"><span class="type">float</span> balances[<span class="number">100</span>] &#123;&#125;;		<span class="comment">// all elements set to 0</span></span><br></pre></td></tr></table></figure>

<p>第三，列表初始化禁止缩窄转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> plifs[] = &#123;<span class="number">25</span>,<span class="number">92</span>,<span class="number">3.0</span>&#125;; <span class="comment">// not allowed</span></span><br><span class="line"><span class="type">char</span> slifs[<span class="number">4</span>] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="number">1122011</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">//not allowed</span></span><br><span class="line"><span class="type">char</span> tlifs[<span class="number">4</span>] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="number">112</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">// allowed</span></span><br></pre></td></tr></table></figure>

<p>第一条语句不能通过编译，因为将浮点数转换为整型是缩窄操作，即使浮点数的小数点后面为零。</p>
<p>第二条语句也不能通过编译，因为1122011超出了char变量的取值范围。</p>
<p>第三条语句可通过编译，因为虽然112是一个int值，但它在char变量的取值范围内。</p>
<p>C++标准模板库（STL）提供了一种数组替代品：模板类vector，而C++11新增了模板类array。</p>
<h4 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h4><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为C-风格字符串（C-style string）。另一种是基于string类库的方法。</p>
<p><strong>存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中</strong>，其中每个字符都位于自己的数组元素中。字符串提供了一种存储文本信息的便捷方式，如提供给用户的消息（“请告诉我您的瑞士银行账号”）或来自用户的响应（“您肯定在开玩笑”）。</p>
<p>C-风格字符串具有一种特殊的性质：以空字符（null character）结尾，空字符被写作\0，其中ASCII码为0，用来标记字符串的结尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dog[<span class="number">8</span>] = &#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;&#x27;,&#x27;</span>I<span class="number">&#x27;</span>,<span class="string">&#x27;I&#x27;</span>&#125;;	<span class="comment">// not a string</span></span><br><span class="line"><span class="type">char</span> cat[<span class="number">8</span>] = &#123;<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">// a string</span></span><br></pre></td></tr></table></figure>

<p>这两个数组都是char数组，但只有第二个数组是字符串。</p>
<p>在cat数组中使用了大量的单引号，且必须加上空字符。但有一种更好的将字符数组初始化为字符串的方法：只需使用一个用引号括起的字符串即可，这种字符串被称为字符串常量（string constant）或是字符串字面值（string literal）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> bird[<span class="number">11</span>] = <span class="string">&quot;Mr. Cheeps&quot;</span>;	<span class="comment">// the \0 is understood</span></span><br><span class="line"><span class="type">char</span> fish[] = <span class="string">&quot;Bubbles&quot;</span>;	<span class="comment">// let the compier count</span></span><br></pre></td></tr></table></figure>

<p><strong>用引号括起的字符串隐式地包括结尾的空字符，因此不用显示地包括它。</strong>另外，各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符。</p>
<p>让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。</p>
<p>C++对字符串长度没有限制。</p>
<p>警告：==在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。==</p>
<p>注意：字符串常量（使用双引号）不能与字符常量（使用单引号）互换。字符常量（如’S’）是字符串编码的简写表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shirt_size = <span class="string">&#x27;S&#x27;</span>;	<span class="comment">// this is fine</span></span><br></pre></td></tr></table></figure>

<p>但”S”不是字符常量，它表示的是两个字符（字符S和\0）组成的字符串。”S”实际上表示的是字符串所在的内存地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shirt_size = <span class="string">&quot;S&quot;</span>;	<span class="comment">//illegal type mismatch</span></span><br></pre></td></tr></table></figure>

<p>由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法。</p>
<h5 id="拼接字符串常量"><a href="#拼接字符串常量" class="headerlink" title="拼接字符串常量"></a>拼接字符串常量</h5><p>有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起来的字符串合并为一个。事实上，任何两个由空白（空格、制表符和换行符）分割的字符串常量都将自动拼接成一个。因此，下面所有的输出语句都是等效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;I&#x27;d give my right arm to be&quot;</span> <span class="string">&quot; a great violinist.\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I&#x27;d give my right arm to be a great violinist.\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I&#x27;d give my right ar&quot;</span></span><br><span class="line"><span class="string">&quot;m to be a great violinist.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符串将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。</p>
<h5 id="在数组中使用字符串"><a href="#在数组中使用字符串" class="headerlink" title="在数组中使用字符串"></a>在数组中使用字符串</h5><p>要将字符串存储到数组中，最常有的方法有两种：将数组初始化为字符串常量、将键盘或文件输入读入到数组中。</p>
<p>下面程序演示了这两种方法，它将一个数组初始化为用引号括起来的字符串，并将使用cin将一个输入字符串放到另一个数组中。该程序还使用了标准C语言库函数strlen（）来确定字符串的长度。标准头文件cstring（老式实现为string.h）提供了该函数以及很多与字符串相关的其他函数的声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>		<span class="comment">// for the strlen() function</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Size = <span class="number">15</span>;</span><br><span class="line">    <span class="type">char</span> name1[Size];		<span class="comment">// empty array</span></span><br><span class="line">    <span class="type">char</span> name2[Size] = <span class="string">&quot;C++owboy&quot;</span>;	<span class="comment">// initialized array</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Howdy! I&#x27;m &quot;</span> &lt;&lt; name2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! What&#x27;s your name?\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; name1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Well, &quot;</span> &lt;&lt; name1 &lt;&lt; <span class="string">&quot;,your name has &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(name1) &lt;&lt; <span class="string">&quot; letters and is stored\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in an array of &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(name1) &lt;&lt; <span class="string">&quot;bytes.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your initial is &quot;</span> &lt;&lt; name1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    name2[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">// 使用 \0 截短字符串</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are the first 3 characters of my name: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; name2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Howdy! I&#x27;m C++owboy! What&#x27;s your name?</span><br><span class="line">Basicman</span><br><span class="line">Well, Basicman,your name has 8 letters and is stored</span><br><span class="line">in an array of 15bytes.</span><br><span class="line">Your initial is B.</span><br><span class="line">Here are the first 3 characters of my name: C++</span><br></pre></td></tr></table></figure>

<p>sizeof运算符指出整个数组的长度：15字节，但是strlen()函数返回的是存储在数组中的字符串的长度。</p>
<h5 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> name[ArSize];</span><br><span class="line">    <span class="type">char</span> dessert[ArSize];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your name:\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your favorite dessert:\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; dessert;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have some dellicious &quot;</span> &lt;&lt; dessert;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter your name:</span><br><span class="line">Alistair Dreeb</span><br><span class="line">Enter your favorite dessert:</span><br><span class="line">I have some dellicious Dreeb for you, Alistair.</span><br></pre></td></tr></table></figure>

<p>我们甚至还没有对”输入甜点的提示” 作出反应，程序便把它显示出来了，然后立即显示最后一行。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置。这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。</p>
<p>这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它放到了name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜素用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将其放到dessert数组中。</p>
<h5 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h5><p>每次读取一个单词通常不是最好的选择。例如，假设程序要求用户输入城市名，用户输入New York或Sao Paulo。您希望程序读取并存储完整的城市名，而不仅仅是New或Sao。要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。具体地说，需要采用面向行而不是面向单词的方法。幸运的是，istream中的类（如cin）提供了一些面向行的类成员函数：<strong>getline()和get()<strong>。</strong>这两个函数都读取一行输入，直到到达换行符</strong>。然而，<strong>随后getline()将丢弃换行符，而get()将换行符保留在输入序列中</strong>。</p>
<p><strong>面向行的输入：getline（）</strong></p>
<p>getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。通常要调用这种方法，可以使用==cin.getline()==。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符。余下的空间用于存储自动在结尾处添加的空字符。getline()成员函数在读取指定数目的字符或遇到换行符时停止读取。</p>
<p>例如，假设要使用getline()将姓名读入到一个包含20个元素的name数组中。可以这样调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>这将把一行读入到name数组中，如果这行包含的字符不超过19个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> name[ArSize];</span><br><span class="line">    <span class="type">char</span> dessert[ArSize];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your name:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(name,ArSize);	<span class="comment">//reads through newline</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your favorite dessert:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(dessert,ArSize);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have some dellicious &quot;</span> &lt;&lt; dessert;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enter your name:</span><br><span class="line">Dirk Hammernose</span><br><span class="line">Enter your favorite dessert:</span><br><span class="line">Radish Torte</span><br><span class="line">I have some dellicious Radish Torte for you, Dirk Hammernose.</span><br></pre></td></tr></table></figure>

<p>getline()函数每次读取一行，它通过换行符来确定行尾，但不保存换行符。相反，在存储字符串时，它用空字符来替换换行符。</p>
<p><strong>面向行的输入：get（）</strong></p>
<p>istream 类有另一个名为 get() 的成员函数，该函数有几种变体。其中一种变体的工作方式与getline()类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name,ArSize);	<span class="comment">// read first line</span></span><br><span class="line">cin.<span class="built_in">get</span>();			<span class="comment">// read newline</span></span><br><span class="line">cin.<span class="built_in">get</span>(dessert,ArSize);	<span class="comment">// read second line</span></span><br></pre></td></tr></table></figure>

<p>另一种使用get（）的方式是将两个类成员函数拼接起来（合并）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name,ArSize).<span class="built_in">get</span>();		<span class="comment">// concatenate member functions</span></span><br></pre></td></tr></table></figure>

<p>之所以可以这样做，是由于cin.get(name,ArSize) 返回一个cin对象，该对象随后将被用来调用get()函数。同样，下面的语句将把输入中的连续的两行分别读入到数组name1 和 name2 中，其效果与两次调用cin.getline()相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name1,ArSize).<span class="built_in">getline</span>(name2,ArSize);</span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> name[ArSize];</span><br><span class="line">    <span class="type">char</span> dessert[ArSize];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your name:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(name,ArSize).<span class="built_in">get</span>();	<span class="comment">//read string, newline</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your favorite dessert:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(dessert,ArSize).<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have some dellicious &quot;</span> &lt;&lt; dessert;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enter your name:</span><br><span class="line">Mai Parfait</span><br><span class="line">Enter your favorite dessert:</span><br><span class="line">Chocolate Mousse</span><br><span class="line">I have some dellicious Chocolate Mousse for you, Mai Parfait.</span><br></pre></td></tr></table></figure>

<p>为什么要使用get()，而不是getline()呢？首先，老式实现没有getline()，其次，get()使输入更仔细。例如：假设用get()将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已经填满呢？查看下一个输入字符，如果是换行符，说明已经读取了整行；否则，说明该行中还有其他的输入。</p>
<p>总之，getline()使用起来简单一些，但是get()使得检查错误更简单些。可以用其中的任何一个来读取一行输入。</p>
<p><strong>空行和其他问题</strong></p>
<p>当getline()或get()读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取。但当前的做法是，当get()读取空行后将设置失效位。这意味着接下来的输入将被阻断，但可以使用<code>cin.clear();</code>来恢复输入。</p>
<p>另一个潜在的问题是，输入字符串可能比分配的空间长，如果输入行包含的字符数比指定的多，则getline()和get()将把余下的字符留在输入队列中,getline()还会设置失效位，并关闭后面的输入。</p>
<h5 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;What year was your house built?\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;What is its street address?\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> address[<span class="number">80</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(address,<span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Year built: &quot;</span> &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What year was your house built?</span><br><span class="line">1966</span><br><span class="line">What is its street address?</span><br><span class="line">Year built: 1966</span><br><span class="line">Address:</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<p>用户根本没有输入地址的机会。问题在于，当cin读取年份，将回车键生成的换行符留在了输入队列中。后面的cin.getline()看到换行符后，将认为是一个空行，并将一个字符串赋给address数组。</p>
<p>解决方法：在读取地址之前先读取并丢弃换行符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; year;</span><br><span class="line">cin.<span class="built_in">get</span>();	<span class="comment">// or cin.get(ch);</span></span><br></pre></td></tr></table></figure>

<p>或者利用表达式cin&gt;&gt;year返回cin对象，将调用拼接起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cin &gt;&gt; year).<span class="built_in">get</span>();	<span class="comment">// or (cin &gt;&gt; year).get(ch);</span></span><br></pre></td></tr></table></figure>

<p>C++程序常使用指针（而不是数组）来处理字符串。</p>
<h4 id="4-3-string-类"><a href="#4-3-string-类" class="headerlink" title="4.3 string 类"></a>4.3 string 类</h4><p>ISO/ANSI C++98 标准通过添加string 类扩展了C++库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。</p>
<p>string 类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。</p>
<p>要使用string 类，必须在程序中包含头文件string。string 类位于名称空间std中，因此必须提供一条using 编译指令，或者使用 std::string 来引用它。</p>
<p>sting 类定义隐藏了字符串的数组性质，能够像处理普通变量那样处理字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> 	<span class="comment">// make string class available</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> charr1[<span class="number">20</span>];	<span class="comment">// create an empty array</span></span><br><span class="line">    <span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>;	<span class="comment">// create an initialized array</span></span><br><span class="line">    string str1;		<span class="comment">// create an empty string object</span></span><br><span class="line">    string str2 = <span class="string">&quot;panther&quot;</span>;	<span class="comment">// create an initialized string</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a kind of feline: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; charr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter another kind of feline: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are some felines:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; charr1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str2 &lt;&lt; endl;		<span class="comment">// use cout for output</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; The third letter in &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">        &lt;&lt; charr2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; The third letter in &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; is &quot;</span> </span><br><span class="line">        &lt;&lt; str2[<span class="number">2</span>] &lt;&lt; endl;		<span class="comment">//use array notation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enter a kind of feline: ocelot</span><br><span class="line">Enter another kind of feline: tiger</span><br><span class="line">Here are some felines:</span><br><span class="line">ocelot jaguar tiger panther</span><br><span class="line">The third letter in jaguar is g</span><br><span class="line">The third letter in panther is n</span><br></pre></td></tr></table></figure>

<p>string 对象 和 字符数组之间的主要区别是：</p>
<p>可以将 string 对象声明为简单变量，而不是数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1;		<span class="comment">// create an empty  string object</span></span><br><span class="line">string str2 = <span class="string">&quot;panther&quot;</span>;	<span class="comment">// create an initialized string</span></span><br></pre></td></tr></table></figure>

<p><strong>类设计让程序能够自动处理string 的大小</strong>。例如：</p>
<p>str1 的声明创建一个长度为0的string 对象，但程序将输入读取到str1 中时，将自动调整str1 的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; str1 ;		<span class="comment">// str1 resized to fit input</span></span><br></pre></td></tr></table></figure>

<p>这使得与数组相比，使用string 对象更方便，也更安全。</p>
<p>从理论上，<strong>可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体</strong>。</p>
<p><strong>C++11 字符串初始化</strong></p>
<p>C++11 也允许将列表初始化用于C-风格字符串和string对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> first_date[] = &#123;<span class="string">&quot;Le Chapon Dodu&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> second_date][] &#123;<span class="string">&quot;The Elegant Plate&quot;</span>&#125;;</span><br><span class="line">string third_date = &#123;<span class="string">&quot;The Bread Bowl&quot;</span>&#125;;</span><br><span class="line">string fourth_date &#123;<span class="string">&quot;Hank&#x27;s Fine Eats&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>赋值、拼接和附加</strong></p>
<p>使用 string 类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，但<strong>可以将一个string对象赋给另一个string对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charr1[<span class="number">20</span>];	<span class="comment">// create an empty array</span></span><br><span class="line"><span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>;	<span class="comment">// create an initialized array</span></span><br><span class="line">string str1;		<span class="comment">// create an empty string object</span></span><br><span class="line">string str2 = <span class="string">&quot;panther&quot;</span>;	<span class="comment">// create an initialized string</span></span><br><span class="line">charr1 = charr2;		<span class="comment">// invalid,no array assignment</span></span><br><span class="line">str1 = str2;	<span class="comment">// valid,object assignment ok</span></span><br></pre></td></tr></table></figure>

<p>string 类简化了字符串合并操作。可以使用运算符+将两个string 对象合并起来，还可以使用运算符+=将字符串附加到string 对象的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str3;</span><br><span class="line">str3 = str1 + str2;		<span class="comment">// assign str3 the joined strings</span></span><br><span class="line">str1 += str2;		<span class="comment">// add str2 to the end of str1</span></span><br></pre></td></tr></table></figure>

<p>可以将C-风格字符串或string对象与string 对象相加，或者将它们附加到string 对象的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;penguin&quot;</span>;</span><br><span class="line">    string s2,s3;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can assign one string object to another: s2 = s1\n&quot;</span>;</span><br><span class="line">    s2 = s1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;,s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can assign a C-style string to a string object.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 = \&quot;buzzard\&quot;\n&quot;</span>;</span><br><span class="line">    s2 = <span class="string">&quot;buzzard&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can concatenate strings: s3 = s1 + s2\n&quot;</span>;</span><br><span class="line">    s3 = s1 + s2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can append strings.\n&quot;</span>;</span><br><span class="line">    s1 += s2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 += s2  yields s1 =  &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">    s2 += <span class="string">&quot; for a day &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 += \&quot; for a day\&quot; yields s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">You can assign one string object to another: s2 = s1</span><br><span class="line">s1: penguin,s2: penguin</span><br><span class="line">You can assign a C-style string to a string object.</span><br><span class="line">s2 = &quot;buzzard&quot;</span><br><span class="line">s2: buzzard</span><br><span class="line">You can concatenate strings: s3 = s1 + s2</span><br><span class="line">s3: penguinbuzzard</span><br><span class="line">You can append strings.</span><br><span class="line">s1 += s2  yields s1 =  penguinbuzzard</span><br><span class="line">s2 += &quot; for a day&quot; yields s2 = buzzard for a day</span><br></pre></td></tr></table></figure>

<p><strong>string 类的其他操作</strong></p>
<p>在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。对于C-风格字符串，程序员使用C语言库中的函数来完成这些任务。头文件 cstring（以前为string.h） 提供了这些函数。</p>
<p>例如：可以使用函数strcpy（）将字符串复制到字符数组中，使用函数strcat（）将字符串附加到字符组末尾：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr1,charr2);	<span class="comment">// copy charr2 to charr1</span></span><br><span class="line"><span class="built_in">strcat</span>(charr1,charr2);	<span class="comment">// append contents of charr2 to charr1</span></span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>		<span class="comment">// make string class available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>		<span class="comment">// C-style string library</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> charr1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2 = <span class="string">&quot;panther&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// assignment for string objects and character arrays</span></span><br><span class="line">    str1 = str2;			<span class="comment">// copy str2 to str1</span></span><br><span class="line">    <span class="built_in">strcpy</span>(charr1,charr2);	<span class="comment">//copy charr2 to charr1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// appending for string objects and character ayyats</span></span><br><span class="line">    str1 += <span class="string">&quot; paste&quot;</span>;		<span class="comment">//add paste to end of str1</span></span><br><span class="line">    <span class="built_in">strcat</span>(charr1,<span class="string">&quot;juice&quot;</span>);	<span class="comment">//add juice to end of charr1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finding the length of a string object and a C-style string</span></span><br><span class="line">    <span class="type">int</span> len1 = str1.<span class="built_in">size</span>();		<span class="comment">// obtain length of str1</span></span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(charr1);	<span class="comment">// obtain length of charr1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The string &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; contains &quot;</span></span><br><span class="line">        &lt;&lt; len1 &lt;&lt; <span class="string">&quot; characters.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; The string &quot;</span> &lt;&lt; charr1 &lt;&lt; <span class="string">&quot; contains &quot;</span></span><br><span class="line">        &lt;&lt; len2 &lt;&lt; <span class="string">&quot; characters.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The string panther paste contains 13 characters.</span><br><span class="line">The string jaguarjuice contains 11 characters.</span><br></pre></td></tr></table></figure>

<p>使用C-风格字符串时，需要使用的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr3,charr1);		<span class="comment">//c语言风格：字符串复制（拷贝）函数</span></span><br><span class="line"><span class="built_in">strcat</span>(charr3,charr2);		<span class="comment">//C语言风格：字符串连接（拼接）</span></span><br></pre></td></tr></table></figure>

<p>另外，使用字符数组时，总是存在目标数组过小，无法存储指定信息的危险：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">10</span>] = <span class="string">&quot;house&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(site,<span class="string">&quot; of pancakes&quot;</span>);	<span class="comment">// memory problem</span></span><br></pre></td></tr></table></figure>

<p>函数strcat()试图将全部12 个字符复制到数组site中，这将覆盖相邻的内存。这有可能导致程序终止，或者程序继续运行，但数据被损坏。</p>
<p>string 类具有自动调整大小的功能，从而能够避免这种问题的发生。C函数库确实提供了与strcat()和strcpy()类似的函数：strncat()函数和strncpy()函数。它们能接受指出目标数组最大长度的第三个参数，因此更为安全。</p>
<p>两种确定字符串中字符数的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len1 = str1.<span class="built_in">size</span>();		<span class="comment">// obtain length of str1</span></span><br><span class="line"><span class="type">int</span> len2 = <span class="built_in">strlen</span>(charr1);	<span class="comment">// obtain length of charr1</span></span><br></pre></td></tr></table></figure>

<p>函数strlen()是一个常规函数，它接受了一个C-风格字符串作为参数，并返回该字符串包含的字符数。函数size()的功能基本上与此相同，但句法不同；str1不是被用作函数参数，而是位于函数名之前，它们之间用句点连接。</p>
<p>这种句法表明，str1 是一个对象，而size()是一个类方法。<strong>方法是一个函数，只能通过其所属类的对象进行调用</strong>。在这里，str1 是一个string对象，而size()是string类的一个方法。</p>
<p>总之，<strong>C函数使用参数来指出要使用哪个字符串，而C++string类对象使用对象名和句点运算符来指出要使用哪个字符串</strong>。</p>
<h5 id="string-类I-O"><a href="#string-类I-O" class="headerlink" title="string 类I/O"></a>string 类I/O</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>			<span class="comment">//C++ style,make string class available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>			<span class="comment">//C-style string library</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> charr[<span class="number">20</span>];			<span class="comment">// C-style</span></span><br><span class="line">    string str;			<span class="comment">// C++ Style</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in charr before input:&quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">strlen</span>(charr) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in str before input:&quot;</span></span><br><span class="line">        &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a line of text:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(charr,<span class="number">20</span>);		<span class="comment">// indicate maximum length</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; charr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter another line of text:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);	<span class="comment">// cin now an argument; no length specifier</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in charr after input: &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">strlen</span>(charr) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in str after input: &quot;</span></span><br><span class="line">        &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Length of string in charr before input:1</span><br><span class="line">Length of string in str before input:0</span><br><span class="line">Enter a line of text:</span><br><span class="line">peanut butter</span><br><span class="line">You entered: peanut butter</span><br><span class="line">Enter another line of text:</span><br><span class="line">blueberry jam</span><br><span class="line">You entered: blueberry jam</span><br><span class="line">Length of string in charr after input: 13</span><br><span class="line">Length of string in str after input: 13</span><br></pre></td></tr></table></figure>

<p>在用户输入之前，str 中的 字符串长度为0.这是因为未被初始化的string对象的长度被自动设置为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(charr,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>这种句点表示法表明，函数getline()是istream类的一个类的方法（之前所说的，cin是一个istream对象）。第一个参数是目标数组，第二个参数是数组长度。getline()使用它来避免超越数组的边界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>

<p>这里没有使用句点表示法，这表明这个getline()不是类方法。它将cin作为参数，指出到哪里取查找输入。另外，也没有指出字符串长度的参数，因此string对象将根据字符串的长度自动调整自己的大小。</p>
<h4 id="4-4-结构简介"><a href="#4-4-结构简介" class="headerlink" title="4.4 结构简介"></a>4.4 结构简介</h4><p>C++中的结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，这使得能够将有关信息放在一个结构中，从而将数据的表示合并到一起。</p>
<p>结构也是C++OOP堡垒（类）的基石，结构的学习会离C++的核心OOP更近。</p>
<p><strong>结构是用户定义的类型，而结构声明定义了这种类型的数据属性</strong>。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步，首先，定义结构描述：它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）。</p>
<p>例如：假设Bloataire公司要创建一种类型来描述其生产线上充气产品的成员。具体地说，这种类型应存储产品名称、容量和售价。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span>		<span class="comment">// structure declaration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];		<span class="comment">// 结构的成员</span></span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;		</span><br><span class="line">&#125;;  <span class="comment">// 结束结构声明</span></span><br></pre></td></tr></table></figure>

<p><strong>关键字struct</strong>表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称，因此<strong>新类型的名称为inflatable</strong>。这样，便可以创建char或int类型的变量那样创建inflatable类型的变量了。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。列表中的每一项都被称为<strong>结构成员</strong>。</p>
<p>定义结构后，便可以创建类型的变量了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inflatable hat;		<span class="comment">// hat is a structure variable of type inflatable</span></span><br><span class="line">inflatable woople_cushion;	<span class="comment">// type inflatable variable</span></span><br><span class="line">inflatable mainframe;	<span class="comment">// type inflatable variable</span></span><br></pre></td></tr></table></figure>

<p>如果熟悉C语言中的结构，则可能注意到：==C++允许在声明结构变量时省略关键字 struct==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span> goose;	<span class="comment">// keywora struct required in C</span></span><br><span class="line">inflatable vincent;		<span class="comment">// keywora struct not required in C++</span></span><br></pre></td></tr></table></figure>

<p>在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，<strong>结构声明定义了一种新类型</strong>。在C++中，省略struct 不会错。</p>
<p>由于hat的类型为inflatable，因此可以==使用成员运算符（.）来访问各个成员==。例如：hat.volume指的是结构的volume成员，hat.price 指的是price成员。同样，vincent.price是vincent变量的price成员。总之，<strong>通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样</strong>。</p>
<p>由于price成员被声明为double类型，因此hat.price 和vincent.price 相当于是double类型的变量，可以像使用常规double变量那样来使用它们。总之，hat是一个结构，而hat.price是一个double变量。</p>
<p>访问类成员函数（如cin.getline()）的方式是从访问结构成员变量（如 vincent.price ）的方式衍生而来的。</p>
<p><strong>在程序中使用结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span>		<span class="comment">// structure declaration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inflatable guest = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Glorious Gloria&quot;</span>,		<span class="comment">// name value</span></span><br><span class="line">        <span class="number">1.88</span>,					<span class="comment">// volume value</span></span><br><span class="line">        <span class="number">29.9</span>					<span class="comment">// price value</span></span><br><span class="line">    &#125;;		<span class="comment">// guest is a structure variable of type inflatable</span></span><br><span class="line">    <span class="comment">// It&#x27;s initialized to the indicated values</span></span><br><span class="line">    </span><br><span class="line">    inflatable pal =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Audacious Arthur&quot;</span>,</span><br><span class="line">        <span class="number">3.12</span>,</span><br><span class="line">        <span class="number">32.99</span></span><br><span class="line">    &#125;;	<span class="comment">// pal is a second variable of type inflatable</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> some implementations require using</span></span><br><span class="line">    <span class="comment">// static inflatable guest = </span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Expand your guest list with &quot;</span> &lt;&lt; guest.name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; pal.name &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can have both for $&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guest.price + pal.price &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expand your guest list with Glorious Gloria and Audacious Arthur!</span><br><span class="line">You can have both for $62.89!</span><br></pre></td></tr></table></figure>

<p>程序说明：</p>
<p>结构声明的位置很重要。对于structur.cpp而言，有两种选择，可以将声明放在main()函数中，紧跟在开始括号的后面。另一种选择是将声明放到main()的前面，这里采用的便是这种方式，<strong>位于函数外面的声明被称为外部声明</strong>。</p>
<p>对于这个程序来说，两种选择之间没有实际区别，但是对于那些包含两个或更多的程序来说，差别很大。<strong>外部声明可以被其后面的任何函数使用</strong>，而内部声明只能被该声明所属的函数使用。<strong>通常应使用外部声明</strong>，<strong>这样所有函数都可以使用这种类型的结构</strong>。</p>
<p>变量也可以在函数内部和外部定义，外部变量由所有的函数共享。<strong>C++不提倡使用外部变量，但提倡使用外部结构声明</strong>。另外，在外部声明符号常量通常更合理。</p>
<p>请注意初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inflatable guest =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Glorious Gloria&quot;</span>,		<span class="comment">// name value</span></span><br><span class="line">    <span class="number">1.88</span>,					<span class="comment">// volume value</span></span><br><span class="line">    <span class="number">29.9</span>					<span class="comment">// price value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。在该程序中，每个值占一行，但也可以将它们全部放在同一行中。只是应用逗号将其分开：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable guest =&#123;<span class="string">&quot;Glorious Gloria&quot;</span>,<span class="number">1.88</span>,<span class="number">29.9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以将结构的每个成员都初始化为适当类型的数据。例如：name成员是一个字符数组，因此可以将其初始化为一个字符串。</p>
<p><strong>可将每个结构成员看作是相应类型的变量</strong>，因此，pal.price是一个double变量，而pal.name是一个char数组。当程序使用cout显示pal.name时，将把该成员显示为字符串。另外，由于pal.name是一个字符数组，因此可以用下标来访问其中的各个字符。例如：pal.name[0]是字符A。不过pal[0]没有意义，因为pal是一个结构，而不是数组。</p>
<p><strong>C++11 结构初始化</strong></p>
<p>与数组一样，C++11 也支持将列表初始化用于结构，切等号（=）是可选的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable duck &#123;<span class="string">&quot;Daphne&quot;</span>,<span class="number">0.12</span>,<span class="number">9.98</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>其次，如果大括号内未包含任何东西，各个成员都将被设置为零。例如：下面的声明导致mayor.volume和mayor.price 被设置为零，且mayor.name的每个字节都将被设置为零：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable mayor &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，不允许缩窄转换。</p>
<p><strong>结构可以将string 类作为成员吗？</strong></p>
<p>可以将成员name指定为string对象而不是字符数组吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span>		<span class="comment">// structure definition</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>答案是肯定的，只要使用的编译器支持对string对象作为成员的结构进行初始化。</p>
<p>一定要让结构定义能够访问名称空间std。为此，可将编译指令using移到结构定义之前；也可以像前面那样，将name的类型声明为std::string。</p>
<p><strong>其他结构属性</strong></p>
<p>C++使用用户定义的类型与内置类型尽可能相似。例如：可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将 结构赋给另一个同类型的结构，这样结构中的每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值（memberwise assignment）。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inflatable bouquet =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;sunflowers&quot;</span>,</span><br><span class="line">        <span class="number">0.20</span>,</span><br><span class="line">        <span class="number">12.49</span></span><br><span class="line">    &#125;;</span><br><span class="line">    inflatable choice;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bouquet: &quot;</span> &lt;&lt; bouquet.name &lt;&lt; <span class="string">&quot;for $&quot;</span>;</span><br><span class="line">    cout &lt;&lt; bouquet.price &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    choice = bouquet;	<span class="comment">// assign one structure to another</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;choice: &quot;</span> &lt;&lt; choice.name &lt;&lt; <span class="string">&quot; for $&quot;</span>;</span><br><span class="line">    cout &lt;&lt; choice.price &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bouquet: sunflowersfor $12.49</span><br><span class="line">choice: sunflowers for $12.49</span><br></pre></td></tr></table></figure>

<p>从中可以看出，成员赋值是有效的，因为choice结构的成员值与bouquet结构中存储的值相同。</p>
<p>==可以同时完成定义结构和创建结构变量的工作==。为此，只需将变量名放在结束括号的后面即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">perks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key_number;</span><br><span class="line">    <span class="type">char</span> car[<span class="number">12</span>];</span><br><span class="line">&#125;mr_smith.ms_jones;			<span class="comment">// two perks variables</span></span><br></pre></td></tr></table></figure>

<p>甚至可以初始化以这种方式创建的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">perks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key_number;</span><br><span class="line">    <span class="type">char</span> car[<span class="number">12</span>];</span><br><span class="line">&#125;mr_glitz = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span>,			<span class="comment">// value for mr_glitz.key_number member</span></span><br><span class="line">    <span class="string">&quot;Packard&quot;</span>	<span class="comment">// value for mr_glitz.car member</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而，<strong>将结构定义和变量声明分开，可以使程序更易于阅读和理解。</strong></p>
<p>还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一种这种类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 		<span class="comment">// no tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;		<span class="comment">// 2 members</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;position;		<span class="comment">// a structure variable</span></span><br></pre></td></tr></table></figure>

<p>这样创建一个名为position的结构变量。可以使用成员运算符来访问它的成员（如：position.x），但这种类型没有名称，因此以后无法创建这种类型的变量。（一般不推荐）</p>
<h5 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h5><p>inflatable 结构包含一个数组（name）。也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。例如：要创建一个包含100个inflatable结构的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable gifts[<span class="number">100</span>];   <span class="comment">// array of 100 inflatable structures</span></span><br></pre></td></tr></table></figure>

<p>这样，gifts将是一个inflatable数组，其中的每个元素（如gifts[0]或gifts[99]）都是inflatable对象，可以与成员运算符一起使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; gifts[<span class="number">0</span>].volume;			<span class="comment">// use volume member of first struct</span></span><br><span class="line">cout &lt;&lt; gifts[<span class="number">99</span>].price &lt;&lt; endl;<span class="comment">// display price member of last struct</span></span><br></pre></td></tr></table></figure>

<p>记住，gifts本身是一个数组，而不是结构，因此像gifts.price这样的表述是无效的。</p>
<p>要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，因此可以使用结构初始化的方式来提供它的值。</p>
<p>因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inflatable gueests[<span class="number">2</span>] = 		<span class="comment">//initializing an array of structs</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Bambi&quot;</span>,<span class="number">0.5</span>,<span class="number">21.99</span>&#125;,		<span class="comment">// first structure in array</span></span><br><span class="line">    &#123;<span class="string">&quot;Godzilla&quot;</span>,<span class="number">2000</span>,<span class="number">565.99</span>&#125;	<span class="comment">// next structure in array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inflatable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inflatable guests[<span class="number">2</span>] = 		<span class="comment">//initializing an array of structs</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Bambi&quot;</span>,<span class="number">0.5</span>,<span class="number">21.99</span>&#125;,		<span class="comment">// first structure in array</span></span><br><span class="line">        &#123;<span class="string">&quot;Godzilla&quot;</span>,<span class="number">2000</span>,<span class="number">565.99</span>&#125;	<span class="comment">// next structure in array</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The guests &quot;</span> &lt;&lt; guests[<span class="number">0</span>].name &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; guests[<span class="number">1</span>].name</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\nhave a combined volume of &quot;</span></span><br><span class="line">        &lt;&lt; guests[<span class="number">0</span>].volume + guests[<span class="number">1</span>].volume &lt;&lt; <span class="string">&quot; cubic feet.\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The guests Bambi and Godzilla</span><br><span class="line">have a combined volume of 2000.5 cubic feet.</span><br></pre></td></tr></table></figure>

<h5 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h5><p>与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">torgle_register</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> SN : <span class="number">4</span>;	<span class="comment">// 4 bits for SN value</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">4</span>;	<span class="comment">// 4 bits unused</span></span><br><span class="line">    <span class="type">bool</span> goodIn : <span class="number">1</span>;	<span class="comment">// valid input (1 bit)</span></span><br><span class="line">    <span class="type">bool</span> goodTorgle : <span class="number">1</span>;	<span class="comment">// successful torgling</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torgle_register tr = &#123;<span class="number">14</span>,_true,<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(tr.goodIN)</span><br></pre></td></tr></table></figure>

<p>位字段通常用在低级编程中。</p>
<h4 id="4-5-共用体"><a href="#4-5-共用体" class="headerlink" title="4.5 共用体"></a>4.5 共用体</h4><p>共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，==结构可以同时存储int、long和double，共用体只能存储int、long或double==。共用体的句法与结构相似，但含义不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">one4all</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> int_val;</span><br><span class="line">    <span class="type">long</span> long_val;</span><br><span class="line">    <span class="type">double</span> double_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用one4all变量来存储int、long或double，条件是在不同的时间进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one4all pail;</span><br><span class="line">pail.int_val = <span class="number">15</span>; 			<span class="comment">// store an int</span></span><br><span class="line">cout &lt;&lt; pail.int_val;		</span><br><span class="line">pail.double_val = <span class="number">1.38</span>;		<span class="comment">// store a double , int value is lost</span></span><br><span class="line">cout &lt;&lt; pail.double_val;</span><br></pre></td></tr></table></figure>

<p>因此，pail有时可以是int变量，而有时又可以是double变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间存储最大的成员，所以，共用体的长度为其最大成员的长度。</p>
<p>共用体的用途之一是：当数据项使用两种或者更多种格式（但不会同时使用）时，可节省空间。例如：假设管理一个小商品目录，其中有一些商品的ID为整数，而另一些的ID为字符串，在这种情况下，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> brand[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">id</span>		<span class="comment">// format depends on widget type</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> id_num;		<span class="comment">// type 1 widgets</span></span><br><span class="line">        <span class="type">char</span> id_char[<span class="number">20</span>];	<span class="comment">// other widgets</span></span><br><span class="line">    &#125;id_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">widget prize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prize.type == <span class="number">1</span>)</span><br><span class="line">    cin &gt;&gt; prize.id_val.id_num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cin &gt;&gt; prize.id_val.id_char;</span><br></pre></td></tr></table></figure>

<p>匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量。显然，==每次只有一个成员是当前的成员：==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> brand[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="keyword">union</span> 		<span class="comment">// anonymous union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> id_num;		<span class="comment">// type 1 widgets</span></span><br><span class="line">        <span class="type">char</span> id_char[<span class="number">20</span>];	<span class="comment">// other widgets</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">widget prize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prize.type == <span class="number">1</span>)</span><br><span class="line">    cin &gt;&gt; prize.id_num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cin &gt;&gt; prize.id_char;</span><br></pre></td></tr></table></figure>

<p>由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。</p>
<p>共用体常用于（但并非只能用于）节省内存。</p>
<h4 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h4><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">spectrum</span> &#123;red,orange,yellow,green,bule,violet,indigo,ultraviolet&#125;;</span><br></pre></td></tr></table></figure>

<p>这条语句完成两项工作：</p>
<ul>
<li>让spectrum成为新类型的名称：spectrum被称为枚举（enumeration）,就像struct变量被称为结构一样。</li>
<li>将red,orange,yellow等作为符号常量，它们对应的整数值0~7。这些常量叫作枚举量（enumerator）。</li>
</ul>
<p>在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值来覆盖默认值。</p>
<p>可以用枚举名来声明这种类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spectrum band;		<span class="comment">// band a variable of type spectrum</span></span><br></pre></td></tr></table></figure>

<p>枚举变量具有一些特殊的属性。</p>
<p>在不进行强制类型转换的情况下，<strong>只能将定义枚举时使用的枚举量赋值给这种枚举的变量</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">band = blue;	<span class="comment">// valid,blue is an enumerator</span></span><br><span class="line">band = <span class="number">2000</span>;	<span class="comment">// invalid, 2000 not an enumerator</span></span><br></pre></td></tr></table></figure>

<p>因此，spectrum变量受到限制，只有8个可能的值。如果试图将一个非法值赋给它，则有些编译器将出现编译器错误，而另一些则发出警告。为获得最大限度的可移植性，应将把非enum值赋给enum变量视为错误。</p>
<p>对于枚举，只定义了赋值运算符。具体来说，没有为枚举定义算术运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">band = orange;		<span class="comment">// valid</span></span><br><span class="line">++band;				<span class="comment">// not valid</span></span><br><span class="line">band = orange + red;	<span class="comment">// not valid,but a little tricky</span></span><br></pre></td></tr></table></figure>

<p><strong>枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> color = blue;	<span class="comment">// valid,spectrum type promoted to int</span></span><br><span class="line">band = <span class="number">3</span>;		<span class="comment">// invalid,int not converted to spectrum</span></span><br><span class="line">color = <span class="number">3</span> + red;	<span class="comment">// valid,red converted to int</span></span><br></pre></td></tr></table></figure>

<p>枚举的规则相当的严格。实际上，枚举更常被用来定义相关的符号常量，而不是新类型。例如：可以用枚举来定义switch语句中使用的符号常量。如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red,orange,yellow,green,bule,violet,indigo,ultraviolet&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>设置枚举量的值</strong><br>可以使用赋值运算符来显式地设置枚举量的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">bits</span>&#123;one = <span class="number">1</span>, two = <span class="number">2</span>, four = <span class="number">4</span>, eight = <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>指定的值必须是整数，也可以只显式地定义其中一些枚举量的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">bigstep</span>&#123;first,second = <span class="number">100</span>,third&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1.因此，third的值为101。</p>
<p>最后，可以创建多个值相同的枚举量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;zero,null = <span class="number">0</span>,one,numero_uno = <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，zero和null都为0，one和numero_uno都为1。</p>
<h5 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h5><p>最初，对于枚举来说，只有声明中指出的那些值是有效的，然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围（range），通过强制类型转换，==可以将取值范围中的任何数值赋给枚举变量，即使这个值不是枚举值==。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">bits</span>&#123;one = <span class="number">1</span>, two = <span class="number">2</span>, four = <span class="number">4</span>, eight = <span class="number">8</span>&#125;;</span><br><span class="line">bits myflag;</span><br></pre></td></tr></table></figure>

<p>则下面写法是合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myflag = <span class="built_in">bits</span>(<span class="number">6</span>);	<span class="comment">// valid,because 6 is in bits range</span></span><br></pre></td></tr></table></figure>

<p>其中6不是枚举值，但是它位于枚举定义的取值范围内。</p>
<p>取值范围的定义如下：首先，要找出上限，需要指定枚举量的最大值。找到这个最大值的、最小值的2的幂，将它减去1，得到的便是取值范围的上限。</p>
<p>例如：前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。</p>
<p>要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。</p>
<p>例如：如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。</p>
<p>选择用多少空间来存储枚举由编译器决定。</p>
<h4 id="4-7-指针和自由存储空间"><a href="#4-7-指针和自由存储空间" class="headerlink" title="4.7 指针和自由存储空间"></a>4.7 指针和自由存储空间</h4><p>指针是一个变量，其存储的值是地址，而不是值本身。</p>
<p>在学习指针之前，先了解如何找到常规变量的地址。只需对变量应用地址运算符（&amp;），就可以获得它的位置。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> donuts = <span class="number">6</span>;</span><br><span class="line">    <span class="type">double</span> cups = <span class="number">4.5</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;donuts value = &quot;</span> &lt;&lt; donuts;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; and donuts address = &quot;</span> &lt;&lt; &amp;donuts &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cups value = &quot;</span> &lt;&lt; cups;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; and cups address = &quot;</span> &lt;&lt; &amp;cups &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">donuts value = 6 and donuts address = 0x61fe1c</span><br><span class="line">cups value = 4.5 and cups address = 0x61fe10</span><br></pre></td></tr></table></figure>

<p>显示地址时，该实现的cout使用十六进制表示法，因为这是常用于描述内存的表示法。</p>
<p>使用常规变量时，值是指定的量，而地址为派生量。</p>
<p>处理存储数据的新策略刚好相反，<strong>将地址视为指定的量，而将值视为派生量。一种特殊类型的变量——指针，用于存储值的地址</strong>。因此，==指针名表示的是地址==。<code>*</code>运算符被称为间接值（indirect value）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值。</p>
<p>例如：假设manly是一个指针，则manly表示的是一个地址，而<code>*manly</code>表示存储在该地址处的值。**<code>*manly</code>与常规int变量等级**。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> updates = <span class="number">6</span>;		<span class="comment">// declare a variable</span></span><br><span class="line">    <span class="type">int</span> * p_updates;		<span class="comment">// declare pointer to an int</span></span><br><span class="line">    p_updates = &amp;updates;	<span class="comment">// assign address of int to pointer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//express values two ways</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Values: updates = &quot;</span> &lt;&lt; updates;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, *p_updates = &quot;</span> &lt;&lt; *p_updates &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// express address two ways</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Addresses:&amp;updates = &quot;</span> &lt;&lt; &amp;updates;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,p_updates = &quot;</span> &lt;&lt; p_updates &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use pointer to change value</span></span><br><span class="line">    *p_updates = *p_updates + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now updates = &quot;</span> &lt;&lt; updates &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Values: updates = 6, *p_updates = 6</span><br><span class="line">Addresses:&amp;updates = 0x61fe14,p_updates = 0x61fe14</span><br><span class="line">Now updates = 7</span><br></pre></td></tr></table></figure>

<p>从中可知，int变量updates 和指针变量p_updates只不过是同一枚银币的两面。变量updates表示值，并使用&amp;运算符来获得地址；而变量p_updates表示地址，并使用<code>*</code>运算符来获得值。由于p_updates指向updates，因此<code>*p_updates</code>和updates完全等价。可以像使用int变量那样使用 <code>*p_updates</code>。甚至可以将值赋给 <code>*p_updates</code>。<strong>这样做将修改指向的值，即updates</strong>。</p>
<h5 id="声明和初始化指针"><a href="#声明和初始化指针" class="headerlink" title="声明和初始化指针"></a>声明和初始化指针</h5><p>计算机需要跟踪指针指向的值的类型。例如：char的地址与double的地址，看上去没什么两样，但char和double使用的字节数是不同的，它们存储值时使用的内部格式也是不同的。因此，==指针声明必须指定指针指向的数据的类型。==</p>
<p> 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p_updates;</span><br></pre></td></tr></table></figure>

<p>这表明，<code>*p_updates</code> 的类型为int。由于<code>*运算符</code>被用于指针，因此p_updates 变量本身必须是指针。</p>
<p>我们说p_updates指向int类型，还可以说p_updates的类型是指向int的指针，或<code>int*</code>。</p>
<p>可以这样说，p_updates是指针（地址），而<code>*p_updates</code>是int，而不是指针。</p>
<p>注意：<code>*运算符</code>==两边的空格是可选的==。传统上，C程序员使用这种格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr;</span><br></pre></td></tr></table></figure>

<p>这强调 <code>*ptr</code> 是一个int类型的值。而很多C++程序员使用这种格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr;</span><br></pre></td></tr></table></figure>

<p>这强调的是：<code>int*</code>是一种类型——指向int的指针。</p>
<p><strong>在哪里添加空格对于编译器来说没有任何区别</strong>，甚至可以这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*ptr;</span><br></pre></td></tr></table></figure>

<p>但要知道的是，下面的声明创建一个指针（p1）和一个int变量（p2）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1,p2;</span><br></pre></td></tr></table></figure>

<p>==对每个指针变量名，都需要使用一个<code>*</code>==</p>
<p><strong>注意：在C++中，<code>int*</code> 是一种复合类型，是指向int的指针。</strong></p>
<p>可以用同样的句法来声明指向其他类型的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> * tax_ptr;	<span class="comment">// tax_ptr points to type double</span></span><br><span class="line"><span class="type">char</span> * str;		<span class="comment">// str points to type char</span></span><br></pre></td></tr></table></figure>

<p>由于已将tax_ptr声明为一个指向double的指针，因此编译器知道<code>*tax_ptr</code> 是一个double 类型的值。也就是说，它知道<code>*tax_ptr</code>是一个以浮点数格式存储的值，这个值（在大多数系统上）占据8个字节。指针变量不仅仅是指针，而且是指向特定类型的指针。tax_ptr的类型是指向double的指针（或<code>double *</code> 类型），str是指向char的指针类型（或<code>char*</code>）。尽管它们都是指针，却是不同类型的指针。和数组一样，指针都是基于其他类型的。</p>
<p>虽然tax_ptr和str指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的。也就是说，char的地址和double的地址长度相同。这就好比1016可能是超市的街道地址，而1024可以是小村庄的街道地址一样。<strong>地址的长度或值既不能指示关于变量的长度或类型的任何信息</strong>，也不能指示该地址上有什么建筑物。</p>
<p>一般来说，地址需要2个还是4个字节，取决于计算机系统。</p>
<p><strong>可以在声明语句中初始化指针</strong>，在这种情况下，==被初始化的是指针，而不是它指向的值==。也就是说，下面的语句将pt（而不是<code>*pt</code>）的值设置为 &amp;higgens:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> higgens = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> higgens = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> * pt = &amp;higgens;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of higgens = &quot;</span> &lt;&lt; higgens</span><br><span class="line">        &lt;&lt; <span class="string">&quot;; Address of higgens = &quot;</span> &lt;&lt; &amp;higgens &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of *pt = &quot;</span> &lt;&lt; *pt</span><br><span class="line">        &lt;&lt; <span class="string">&quot;; Value of pt = &quot;</span> &lt;&lt; pt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of higgens = 5; Address of higgens = 0x61fe14</span><br><span class="line">Value of *pt = 5; Value of pt = 0x61fe14</span><br></pre></td></tr></table></figure>

<p>从中可知，程序将pt（而不是 <code>*pt</code>）初始化为higgens的地址。（<strong>每个人的系统上，显示的地址可能不同，显示格式也可能不同</strong>）</p>
<h5 id="指针的危险"><a href="#指针的危险" class="headerlink" title="指针的危险"></a>指针的危险</h5><p>==危险更容易发生在那些使用指针不仔细的人身上==。极其重要的一点是：在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> * fellow;		<span class="comment">// create a pointer to long</span></span><br><span class="line">*fellow = <span class="number">223323</span>;	<span class="comment">// place a value in never-never land</span></span><br></pre></td></tr></table></figure>

<p>fellow 确实是一个指针，但是它指向哪里呢？上述代码没有将地址赋给fellow。那么223323将被放在哪里呢？根本不知道。由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。</p>
<p><strong>警告：一定要在对指针应用解除<code>引用运算符（*）</code>之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律</strong>。</p>
<h5 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h5><p>指针不是整型的，虽然计算机通常把地址当作整数来处理。从概念上看，指针与数组是截然不同的类型。整数是可以执行加、减、除等运算的数字，而==指针描述的是位置==，<strong>将两个地址相乘没有任何意义</strong>。从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pt;</span><br><span class="line">pt = <span class="number">0xB8000000</span>;		<span class="comment">// type mismatch</span></span><br></pre></td></tr></table></figure>

<p>在这里，左边是指向int的指针，因此可以把它赋给地址，但右边是一个整数。0xB8000000是老式计算机系统中视频内存的组合段偏移地址，但这条语句并没有告诉程序，这个数字就是一个地址。在C99标准发布之前，C语言允许这样赋值。但C++在类型一致方面的要求更严格，编译器将显示一条错误消息，通告类型不匹配。<strong>要将数字值作为地址来使用，应通过强制类型转换将数字转换适当的地址类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pt;</span><br><span class="line">pt = (<span class="type">int</span> *)<span class="number">0xB8000000</span>;		<span class="comment">// type now match</span></span><br></pre></td></tr></table></figure>

<p>这样，赋值语句的两边都是整数的地址，因此这样赋值有效。</p>
<p>注意：pt是int值的地址并不意味着pt本身的类型是int。例如：在有些平台中，int类型是个2字节值，而地址是个4字节值。</p>
<h5 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h5><p>对指针的工作方式有一定的了解后，再看看它如何实现在程序运行时分配内存。前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc（）来分配内存；在C++中仍可以这样做，但C++还有更好的方法——new运算符。</p>
<p>在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>new int告诉程序，需要适合存储int的内存。new 运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而<code>*pn</code>是存储在那里的值。将这种方法与将变量的地址赋给指针进行比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> higgens;</span><br><span class="line"><span class="type">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下（pn和pt）下，都是将一个int变量的地址赋给了指针。在第二种情况下，可以通过名称higgens来访问该int，在第一种情况下，则只能通过该指针进行访问。</p>
<p><strong>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName;</span><br></pre></td></tr></table></figure>

<p>需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nights = <span class="number">1001</span>;</span><br><span class="line">    <span class="type">int</span> * pt = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *pt = <span class="number">1001</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nights value = &quot;</span>;</span><br><span class="line">    cout &lt;&lt; nights &lt;&lt; <span class="string">&quot;:location &quot;</span> &lt;&lt; &amp;nights &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; *pt &lt;&lt; <span class="string">&quot; : location = &quot;</span> &lt;&lt; pt &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> * pd = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">    *pd = <span class="number">10000001.0</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *pd &lt;&lt; <span class="string">&quot;:location = &quot;</span> &lt;&lt; pd &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;location of pointer pd: &quot;</span> &lt;&lt; &amp;pd &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of pt = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(pt);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;: size of *pt = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(*pt) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of pd = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> pd;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;: size of *pd = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(*pd) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nights value = 1001:location 0x61fe14</span><br><span class="line">int  value = 1001 : location = 0xea1870</span><br><span class="line">double value = 1e+007:location = 0xea1890</span><br><span class="line">location of pointer pd: 0x61fe08</span><br><span class="line">size of pt = 8: size of *pt = 4</span><br><span class="line">size of pd = 8: size of *pd = 8</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2022/03/31/C++%20Primer%20Plus/">https://centlabs.github.io/2022/03/31/C++%20Primer%20Plus/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/01/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E6%88%91%E4%BB%AC/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">同一个世界，同一个疫情</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/30/Qt%205%20%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%9E%E4%BE%8B/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Qt 5 模板库、工具类及控件</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-C-%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">第二章  C++的学习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.0.1.</span> <span class="toc-text">C语言输入和输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">头文件命令的约定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6endl"><span class="toc-number">1.0.3.</span> <span class="toc-text">控制符endl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E7%AC%A6"><span class="toc-number">1.0.4.</span> <span class="toc-text">换行符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.0.5.</span> <span class="toc-text">C++语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cout%E5%92%8Cprintf%EF%BC%88%EF%BC%89"><span class="toc-number">1.0.6.</span> <span class="toc-text">cout和printf（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96C-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.0.7.</span> <span class="toc-text">其他C++语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.0.8.</span> <span class="toc-text">使用cout进行拼接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.0.9.</span> <span class="toc-text">类简介</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">有返回值的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%98%E4%BD%93"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数变体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">用户定义函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.1.4.</span> <span class="toc-text">有返回值的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%A4%9A%E5%87%BD%E6%95%B0%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8using%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.5.</span> <span class="toc-text">在多函数程序中使用using编译指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">第三章  处理数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 简单变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">变量名：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">整型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">无符号类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">2.1.4.</span> <span class="toc-text">整型字面值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%B8%B8%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">C++如何确定常量的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#char-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.6.</span> <span class="toc-text">char 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#char%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">2.1.7.</span> <span class="toc-text">char字面值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signed-char-%E5%92%8C-unsigned-char"><span class="toc-number">2.1.8.</span> <span class="toc-text">signed char 和 unsigned char</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.9.</span> <span class="toc-text">bool类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 const 限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">浮点常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">浮点数的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 C++算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E5%88%86%E6%94%AF"><span class="toc-number">2.4.1.</span> <span class="toc-text">除法分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.2.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-11-%E4%B8%AD%E7%9A%84auto%E5%A3%B0%E6%98%8E"><span class="toc-number">2.4.3.</span> <span class="toc-text">C++11 中的auto声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第四章  复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-11-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">C++11 数组初始化方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">拼接字符串常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.2.</span> <span class="toc-text">在数组中使用字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">3.2.3.</span> <span class="toc-text">字符串的输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text">每次读取一行字符串输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97"><span class="toc-number">3.2.5.</span> <span class="toc-text">混合输入字符串和数字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-string-%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 string 类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string-%E7%B1%BBI-O"><span class="toc-number">3.3.1.</span> <span class="toc-text">string 类I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 结构简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">结构数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">3.4.2.</span> <span class="toc-text">结构中的位字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">3.5.</span> <span class="toc-text">4.5 共用体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.6.</span> <span class="toc-text">4.6 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">3.6.1.</span> <span class="toc-text">枚举的取值范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E6%8C%87%E9%92%88%E5%92%8C%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">3.7.</span> <span class="toc-text">4.7 指针和自由存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88"><span class="toc-number">3.7.1.</span> <span class="toc-text">声明和初始化指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-number">3.7.2.</span> <span class="toc-text">指针的危险</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E5%AD%97"><span class="toc-number">3.7.3.</span> <span class="toc-text">指针和数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.7.4.</span> <span class="toc-text">使用new来分配内存</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E6%88%91%E4%BB%AC/" title="同一个世界，同一个疫情"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="同一个世界，同一个疫情"/></a><div class="content"><a class="title" href="/2022/04/01/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E6%88%91%E4%BB%AC/" title="同一个世界，同一个疫情">同一个世界，同一个疫情</a><time datetime="2022-04-01T15:43:24.955Z" title="Created 2022-04-01 23:43:24">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Learning"/></a><div class="content"><a class="title" href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning">C++ Learning</a><time datetime="2022-03-31T14:50:54.350Z" title="Created 2022-03-31 22:50:54">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/30/Qt%205%20%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%9E%E4%BE%8B/" title="Qt 5 模板库、工具类及控件"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt 5 模板库、工具类及控件"/></a><div class="content"><a class="title" href="/2022/03/30/Qt%205%20%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%9E%E4%BE%8B/" title="Qt 5 模板库、工具类及控件">Qt 5 模板库、工具类及控件</a><time datetime="2022-03-30T09:03:06.304Z" title="Created 2022-03-30 17:03:06">2022-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/26/ACM/" title="Coding"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Coding"/></a><div class="content"><a class="title" href="/2022/03/26/ACM/" title="Coding">Coding</a><time datetime="2022-03-26T15:48:18.173Z" title="Created 2022-03-26 23:48:18">2022-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" title="Shell 脚本语言"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shell 脚本语言"/></a><div class="content"><a class="title" href="/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" title="Shell 脚本语言">Shell 脚本语言</a><time datetime="2022-03-25T09:28:51.206Z" title="Created 2022-03-25 17:28:51">2022-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>