<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Shell 脚本语言 | CentLabs</title><meta name="keywords" content="Linux,Shell"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Shell 脚本语言 Shell简介1）Shell在计算机语言中，Shell是指一种命令行解释器，是为用户和操作系统之间通信提供的一种接口它接受来自用户输入的命令，并将其转换为一系列的系统调用送到内核执行，并将结果输出给用户。 目前RedHat和CentOS发行版中默认安装了多种Shell，可以使用如下命令来确认系统中可用的Shell是什么版本： 1234567[root@localhost ~]">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell 脚本语言">
<meta property="og:url" content="https://centlabs.github.io/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="Shell 脚本语言 Shell简介1）Shell在计算机语言中，Shell是指一种命令行解释器，是为用户和操作系统之间通信提供的一种接口它接受来自用户输入的命令，并将其转换为一系列的系统调用送到内核执行，并将结果输出给用户。 目前RedHat和CentOS发行版中默认安装了多种Shell，可以使用如下命令来确认系统中可用的Shell是什么版本： 1234567[root@localhost ~]">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-03-25T09:28:51.206Z">
<meta property="article:modified_time" content="2022-04-23T09:35:46.186Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shell 脚本语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-23 17:35:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shell 脚本语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-03-25T09:28:51.206Z" title="Created 2022-03-25 17:28:51">2022-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-23T09:35:46.186Z" title="Updated 2022-04-23 17:35:46">2022-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shell 脚本语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Shell-脚本语言"><a href="#Shell-脚本语言" class="headerlink" title="Shell 脚本语言"></a>Shell 脚本语言</h3><ol>
<li><h4 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h4><h5 id="1）Shell"><a href="#1）Shell" class="headerlink" title="1）Shell"></a>1）Shell</h5><p>在计算机语言中，Shell是指一种命令行解释器，是为用户和操作系统之间通信提供的一种接口它接受来自用户输入的命令，并将其转换为一系列的系统调用送到内核执行，并将结果输出给用户。</p>
<p>目前RedHat和CentOS发行版中默认安装了多种Shell，可以使用如下命令来确认系统中可用的Shell是什么版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # cat /etc/Shells</span><br><span class="line">/bin/sh #Bourne Shell </span><br><span class="line">/bin/bash #Bourne again Shell </span><br><span class="line">/sbin/nologin # 非登录Shell </span><br><span class="line">/bin/tcsh #tC Shell </span><br><span class="line">/bin/csh #C Shell </span><br><span class="line">/bin/ksh #Korn Shell</span><br></pre></td></tr></table></figure>

<p><strong>目前众多的Linux系统默认采用Bash Shell</strong></p>
<h5 id="2）Bourne-Shell"><a href="#2）Bourne-Shell" class="headerlink" title="2）Bourne Shell"></a>2）Bourne Shell</h5><p>是第一个重要的Shell，发布于1977年，作为UNIX 7的默认Shell，在系统中的位置是/bin/sh。目前大多数的UNIX和Linux系统还保留着这个/bin/sh，或者将其连接到其他Shell上，比如 RedHat和CentOS就是将这个文件作为一个连接文件连接到Bash Shell上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /bin/sh </span><br><span class="line">lrwxrwxrwx 1 root root 4 Feb 26 21:14 /bin/sh -&gt; bash</span><br></pre></td></tr></table></figure>

<h5 id="3）Shell-功能"><a href="#3）Shell-功能" class="headerlink" title="3）Shell 功能"></a>3）Shell 功能</h5><p>当一台系统运行起来时，内核（kernel）会被调入内存中运行，由内核执行所有底层的工作，它会将所有应用程序及用户的操作翻译成CPU的基本指 令，并将其送至处理器。这些过程听起来非常复 杂，而且实际上也确实是非常底层和技术化的。为 了对用户屏蔽这些复杂的技术细节，同时也是为了保护内核不会因用户直接操作而受到损害，有必要 在内核之上创建一个层，该层就是一个“壳”，也就是Shell名称的由来。 </p>
<p>Bash Shell有两种工作模式，分别是互动模式和脚本模式。所谓互动模式就是由系统管理人员直接通过键盘输入命令，并等待其执行完毕后再执行下一条命令；而另一种模式是设计出一个脚本文件， 将所有需要执行的命令写在该文件中，由BashShell读取并执行。</p>
</li>
<li><h4 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat HelloWorld.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">This Line is a comment</span> </span><br><span class="line">echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<p>一个Shell脚本永远是以“#!”开头的，这是一个脚本开始的标记，它是在告诉系统执行这个文件需要使用某个解释器，后面的/bin/bash就是指明了解释器的具体位置。</p>
<p>第二行同样是以“#”开头的，但是这里是一个注解。脚本中所有以“#”开头的都是注解（当然以“#!”开头的除外）。</p>
<h5 id="1）运行脚本"><a href="#1）运行脚本" class="headerlink" title="1）运行脚本"></a>1）运行脚本</h5><p>第一种就是在该脚本所在的目录中直接bash这个脚本。实际上，如果使用这种方式来运行脚本，该脚本中的第一行“#!/bin/bash”就可以不需要了，因为直接bash一个文件就是指定了使用Bash Shell来解释脚本内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bash HelloWorld.sh </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>第二种方式是给该脚本加上可执行权限，然后使用“./”来运行，它代表运行的是当前目录下的HelloWorld.sh脚本，如果采用这种方式而脚本没有可执行权限则会报错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod +x HelloWorld.sh </span><br><span class="line">[root@localhost ~]# ./HelloWorld.sh </span><br><span class="line">Hello World</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果脚本没有可执行权限，则会报权限错误</span> </span><br><span class="line">[root@localhost ~]# ./HelloWorld.sh</span><br><span class="line">-bash: ./HelloWorld.sh: Permission denied</span><br></pre></td></tr></table></figure>

<p>如果希望该脚本能成为默认的系统命令，简单地将该脚本复制到任一系统$PATH变量所包含的目录中，同时赋予可执行权限，下次运行的时候只需要直接输入该命令即可。也支持用Tab键补全命令。下例就是将其复制到了/bin目录，并执行该脚本的情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod +x HelloWorld.sh </span><br><span class="line">[root@localhost ~]# mv HelloWorld.sh /bin/ </span><br><span class="line">[root@localhost ~]# HelloWorld.sh</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h5 id="2）Shell-脚本的排错"><a href="#2）Shell-脚本的排错" class="headerlink" title="2）Shell 脚本的排错"></a>2）Shell 脚本的排错</h5><p>Shell脚本在执行时出错是很常见的，最简单的原因无外乎脚本在编写的过程中出现了语法错误或 者不小心输错了命令等。找出脚本中的错误是很重要的能力。假设在之前的脚本中，不小心把echo命令写成了ehco，那么执行的效果如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bash HelloWorld.sh </span><br><span class="line">HelloWorld.sh: line 2: ehco: command not found</span><br></pre></td></tr></table></figure>

<p>从报错信息很容易了解到，出错的原因是“命令不存在”。重新编辑这个文件修改成echo就可以了。如果只是语法上的错误或命令错误还是比较容易辨别的，但往往一些逻辑或算法错误不容易发 现，因为它的语法正确且本身并不会造成程序运行出错。比如说下面的脚本，本来是想连续10次做某些操作的，结果却迟迟没有任何输出。仔细观察一下就知道，其实是陷入了死循环。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat BadLoop.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash <span class="keyword">for</span> ((i=10;i&gt;0;i=i+1))</span></span><br><span class="line">do </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">do</span> something here</span> </span><br><span class="line">one</span><br></pre></td></tr></table></figure>

<p>如果在循环中间的代码块中加入了echo语句，那就容易发现问题了。也就是说，在排查错误时，==使用echo命令有助于观察代码执行的情况==。假设在 上面的脚本中使用echo，再次运行脚本时会注意 到脚本在不断地打印输出，这样就可以发现异常了。如果遇到确实需要执行很多次循环的代码段，由于每次循环的过程都很快，可能来不及观察就进入了下一次循环，那么可以加入sleep命令降低单次循环的速度，比如使用sleep 2这样的命令，单次循 环至少会耗时两秒，这就有足够的时间观察循环的过程了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">for((i=10;i&gt;0;i=i+1)) </span><br><span class="line">do </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">do</span> something here</span></span><br><span class="line">    echo &quot;i=$i&quot;; </span><br><span class="line">    sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>为了更清晰地看到脚本运行的过程，还可以借助-x参数来观察脚本的运行情况。比如在下面的代 码段中，从输出可以看到变量i的值一直在向上增 加，永远满足x&gt;0的条件，所以这是一个死循环。只需要将原来代码中的i=i+1改成i=i-1就可以了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bash -x BadLoop.sh </span><br><span class="line">+ (( i=10 )) </span><br><span class="line">+ (( i&gt;0 ))</span><br><span class="line">+ echo i=10 </span><br><span class="line">i=10</span><br><span class="line">+ sleep 2 </span><br><span class="line">+ (( i=i+1 )) </span><br><span class="line">+ (( i&gt;0 ))</span><br><span class="line">+ echo i=11</span><br><span class="line">i=11</span><br><span class="line">+ sleep 2 </span><br><span class="line">+ (( i=i+1 )) </span><br><span class="line">+ (( i&gt;0 )) </span><br><span class="line">+ echo i=12 </span><br><span class="line">i=12</span><br><span class="line">+ sleep 2 </span><br><span class="line">[Ctrl+c] </span><br><span class="line">停止脚本</span><br></pre></td></tr></table></figure></li>
<li><h4 id="Shell的内建命令"><a href="#Shell的内建命令" class="headerlink" title="Shell的内建命令"></a>Shell的内建命令</h4><p>所谓Shell内建命令，就是由Bash自身提供的命令，而不是文件系统中的某个可执行文件。例如，用于进入或者切换目录的cd命令，虽然我们一直在 使用它，但如果不加以注意很难意识到它与普通命 令的性质是不一样的：该命令并不是某个外部文件，只要在Shell中你就一定可以运行这个命令。打个比方，就像使用语言互相沟通是人类与生俱来的 能力，但是我们有时却需要使用移动电话来进行远 距离的沟通，那么人类本身具备的语言能力就 是“内建”的能力，而移动电话却是一个外部的工具。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span> 命令并不是一个可执行文件</span></span><br><span class="line">[root@localhost ~]# which cd </span><br><span class="line">/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:/usr/ local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">more 命令是一个可执行文件，文件位置为/bin/more</span> </span><br><span class="line">[root@localhost ~]# which more</span><br><span class="line">/bin/more</span><br></pre></td></tr></table></figure>

<h5 id="1）如何确定内建命令：type"><a href="#1）如何确定内建命令：type" class="headerlink" title="1）如何确定内建命令：type"></a>1）如何确定内建命令：type</h5><p>不要试图用脑子记住所有的命令，这不可能也不需要。判断一个命令是不是内建命令只需要借助于命令type即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span> 命令是个内建命令</span> </span><br><span class="line">[root@localhost ~]# type cd </span><br><span class="line">cd is a Shell builtin </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig 命令不是内建命令，而是一个外部文件</span> </span><br><span class="line">[root@localhost ~]# type ifconfig</span><br><span class="line">ifconfig is /sbin/ifconfig</span><br></pre></td></tr></table></figure>

<h5 id="2）执行程序：“-”（点号）"><a href="#2）执行程序：“-”（点号）" class="headerlink" title="2）执行程序：“.”（点号）"></a>2）执行程序：“.”（点号）</h5><p>点号用于执行某个脚本，甚至脚本没有可执行权限也可以运行。有时候在测试运行某个脚本时可 能并不想为此修改脚本权限，这时候就可以使用“.”来运行脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果脚本没有可执行权限，则会报权限错误</span> </span><br><span class="line">[root@localhost ~]# ./HelloWorld.sh </span><br><span class="line">-bash: ./HelloWorld.sh: Permission denied </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用点号执行没有加执行权限的脚本可以正常运行</span> </span><br><span class="line">[root@localhost ~]# . ./HelloWorld.sh </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>与点号类似，source命令也可读取并在当前环境中执行脚本，同时还可返回脚本中最后一个命令的返回状态；如果没有返回值则返回0，代表执行成功；如果未找到指定的脚本则返回false。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# source HelloWorld.sh </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h5 id="3）别名：alias"><a href="#3）别名：alias" class="headerlink" title="3）别名：alias"></a>3）别名：alias</h5><p>alias可用于创建命令的别名，若直接输入该命令且不带任何参数，则列出当前用户使用了别名的命令。应该就能理解类似ll这样的命令为什么与ls-l的效果是一样的。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# alias </span><br><span class="line">alias cp=&#x27;cp -i&#x27; </span><br><span class="line">alias l.=&#x27;ls -d .* --color=tty&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=tty&#x27; </span><br><span class="line">alias ls=&#x27;ls --color=tty&#x27; </span><br><span class="line">alias mv=&#x27;mv -i&#x27; </span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias which=&#x27;alias | /usr/bin/which --tty-only --read- alias --show-dot --show-tilde&#x27;</span><br></pre></td></tr></table></figure>

<p>使用alias可以自定义别名，比如说一般的关机命令是shutdown-h now，写起来比较长，这时可以重新定义一个关机命令，以后就方便多了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# alias myShutdown=&#x27;shutdown -h now&#x27;</span><br></pre></td></tr></table></figure>

<p>注意，这样定义alias只能在当前Shell环境中有效，换句话说，重新登录后这个别名就消失了。为 了确保永远生效，可以将该条目写到用户家目录中的.bashrc文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat .bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line">alias rm=&#x27;rm -i&#x27; </span><br><span class="line">alias cp=&#x27;cp -i&#x27; </span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自定义关机命令的别名</span> </span><br><span class="line">myShutdown=&#x27;shutdown -h now&#x27; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span> </span><br><span class="line">if [ -f /etc/bashrc ]; then </span><br><span class="line">		. /etc/bashrc </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="4）删除别名：unalias"><a href="#4）删除别名：unalias" class="headerlink" title="4）删除别名：unalias"></a>4）删除别名：unalias</h5><p>该命令用于删除当前Shell环境中的别名。有两种使用方法，第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。第二种用法是在命令后接-a参数，删除当前Shell环境中所有的别名。同样，这两种方法都是在当前Shell环境中生效的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除ll 别名</span></span><br><span class="line">[root@e-bai ~]# unalias ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再运行该命令时，报找不到该命令的错误。说明该别名被删除了</span> </span><br><span class="line">[root@e-bai ~]# ll </span><br><span class="line">-bash: ll: command not found</span><br></pre></td></tr></table></figure>

<h5 id="5）任务前后台切换：bg、fg、jobs"><a href="#5）任务前后台切换：bg、fg、jobs" class="headerlink" title="5）任务前后台切换：bg、fg、jobs"></a>5）任务前后台切换：bg、fg、jobs</h5><p>该命令用于将任务放置后台运行，一般会与Ctrl+z、fg、&amp;符号联合使用。典型的使用场景是运行比较耗时的任务。比如打包某个占用较大空间的目录，若在前台执行，在任务完成前将会一直占用当前的终端，而导致无法执行其他任务，此时就应该将这类任务放置后台。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zcf usr.tgz /usr</span><br><span class="line">tar: Removing leading `/&#x27; from member names </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始打包</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">占用前台导致无法运行其他任务，此处用Ctrl+z 组合键暂停前台任务 [1]+ Stopped tar -zcf usr.tgz /usr</span> </span><br><span class="line">[root@localhost ~]# jobs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看暂停的任务，刚刚的tar 任务编号为1 [1]+ Stopped tar -zcf usr.tgz /usr</span> </span><br><span class="line">[root@localhost ~]# bg 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把tar 任务放置后台继续运行 [1]+ tar -zcf usr.tgz /usr &amp;</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tar 任务继续运行了</span> </span><br><span class="line">[root@localhost ~]# fg 1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">fg</span> 把后台任务调至前台运行 tar -zcf usr.tgz /usr</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果预知某个任务耗时很久，可以一开始就将命令放入后台运行</span> </span><br><span class="line">[root@localhost ~]# tar -zcf usr.tgz /usr &amp;</span><br></pre></td></tr></table></figure>

<h5 id="6）声明变量：declare、typeset"><a href="#6）声明变量：declare、typeset" class="headerlink" title="6）声明变量：declare、typeset"></a>6）声明变量：declare、typeset</h5><p>这两个命令都是用来声明变量的，作用完全相同。很多语法严谨的语言（比如C语言）对变量的声明都是有严格要求的：变量的使用原则是必须在使用前声明、声明时必须说明变量类型，而Shell脚 本中对变量声明的要求并不高，因为Shell弱化了变 量的类概念，所以Shell又被称为弱类型编程语言，声明变量时并不需要指明类型。不过，若使用 declare命令，可以用-i参数声明整型变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明变量i_num01 ，其值为1</span> </span><br><span class="line">[root@localhost ~]# i_num01=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明变量f_num01 ，其值为3.14</span> </span><br><span class="line">[root@localhost ~]# f_num01=3.14 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明变量str01 ，其值为HelloWorld</span> </span><br><span class="line">[root@localhost ~]# str01=&quot;HelloWorld&quot; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="built_in">declare</span> 声明整型变量i_num02 ，其值为1</span> </span><br><span class="line">[root@localhost ~]# declare -i i_num02=1</span><br></pre></td></tr></table></figure>

<p>使用-r声明变量为只读</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# declare -r readonly=100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">声明只读变量</span> </span><br><span class="line">[root@localhost ~]# readonly=200 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">试图改变变量值 -bash: <span class="built_in">readonly</span>: <span class="built_in">readonly</span> variable</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错，提示尝试修改只读变量</span></span><br></pre></td></tr></table></figure>

<p>使用-a声明变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# declare - a arr=&#x27;([0]=&quot;a&quot; [1]=&quot;b&quot; [2]=&quot;c&quot;)&#x27; </span><br><span class="line">[root@localhost ~]# echo $&#123;arr[0]&#125;</span><br><span class="line">a</span><br><span class="line">[root@localhost ~]# echo $&#123;arr[1]&#125;</span><br><span class="line">b</span><br><span class="line">[root@localhost ~]# echo $&#123;arr[2]&#125; </span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>使用-F、-f显示脚本中定义的函数和函数体</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建脚本fun.sh ，内容如下</span></span><br><span class="line">[root@localhost ~]# cat fun.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">func_1() </span><br><span class="line">&#123;</span><br><span class="line">	echo &quot;Funciotn 1&quot; </span><br><span class="line">&#125;</span><br><span class="line">func_2() </span><br><span class="line">&#123; </span><br><span class="line">	echo &quot;Function 2&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;declare -F:&quot; </span><br><span class="line">declare -F</span><br><span class="line">echo </span><br><span class="line">echo &quot;declare -f:&quot;</span><br><span class="line">declare -f</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行该脚本的输出效果如下</span> </span><br><span class="line">[root@localhost ~]# bash fun.sh </span><br><span class="line">declare -F: </span><br><span class="line">declare -f func_1 </span><br><span class="line">declare -f func_2 </span><br><span class="line">declare -f: </span><br><span class="line">func_1 () </span><br><span class="line">&#123; </span><br><span class="line">	echo &quot;Funciotn 1&quot; </span><br><span class="line">&#125;</span><br><span class="line">func_2 () </span><br><span class="line">&#123;</span><br><span class="line">	echo &quot;Function 2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7）打印字符：echo"><a href="#7）打印字符：echo" class="headerlink" title="7）打印字符：echo"></a>7）打印字符：echo</h5><p>echo用于打印字符，典型用法是使用echo命令并跟上使用双引号括起的内容（即需要打印的内容），该命令会打印出引号中的内容，并在最后默认加上换行符。使用-n参数可以不打印换行符。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;Hello World&quot; </span><br><span class="line">Hello World </span><br><span class="line">[root@localhost ~]# </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令提示符出现在新的一行</span> </span><br><span class="line">[root@localhost ~]# echo -n &quot;Hello World&quot; </span><br><span class="line">Hello World</span><br><span class="line">[root@localhost ~]# </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令提示符在同一行</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，echo命令会隐藏-e参数（禁止解释打印反斜杠转义的字符）。比如“\n”代表新的一行，如果尝试使用echo输出新的一行，在不加参数的情况下只会将“\n”当作普通的字符，若要打印转义字符，则需要通过使用-e参数来允许。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 默认禁止打印反斜杠转义的字符</span></span><br><span class="line">[root@localhost ~]# echo &quot;\n&quot; </span><br><span class="line">\n </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只是把“\n ”当做普通的字符</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为了允许打印转义字符，需要使用-e 参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面的输出有两行，第一行是输出的新行，第二行是默认的换行符</span> </span><br><span class="line">[root@localhost ~]# echo -e &quot;\n&quot; </span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<h5 id="8）跳出循环：break"><a href="#8）跳出循环：break" class="headerlink" title="8）跳出循环：break"></a>8）跳出循环：break</h5><p>从一个循环（for、while、until或者select）中退 出。break后可以跟一个数字n，代表跳出n层循环， n必须大于1，如果n比当前循环层数还要大，则跳出所有循环。下面的脚本演示了使用break和break 2的区别（运行前请将对应的注释符去掉）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建演示脚本break_01.sh</span> </span><br><span class="line">[root@localhost ~]# cat break_01.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">for I in A B C D </span><br><span class="line">do </span><br><span class="line">	echo -n &quot;$I:&quot; </span><br><span class="line">	for J in `seq 10` </span><br><span class="line">		do </span><br><span class="line">			if [ $J -eq 5 ]; then</span><br><span class="line">					break </span><br><span class="line">					#break 2 </span><br><span class="line">			fi</span><br><span class="line">			echo -n &quot; $J&quot; </span><br><span class="line">		done </span><br><span class="line">	echo </span><br><span class="line">done </span><br><span class="line">echo </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断当J 值为5 时，<span class="built_in">break</span> 的输出结果（循环运行了4 次）</span></span><br><span class="line">[root@localhost ~]# bash break_01.sh </span><br><span class="line">A: 1 2 3 4</span><br><span class="line">B: 1 2 3 4 </span><br><span class="line">C: 1 2 3 4 </span><br><span class="line">D: 1 2 3 4 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断当J 值为5 时，<span class="built_in">break</span> 2 的输出结果（仅运行了1 次循环便终止了）</span> </span><br><span class="line">[root@localhost ~]# bash break_01.sh</span><br><span class="line">A: 1 2 3 4</span><br></pre></td></tr></table></figure>

<h5 id="9）循环控制：continue"><a href="#9）循环控制：continue" class="headerlink" title="9）循环控制：continue"></a>9）循环控制：continue</h5><p>停止当前循环，并执行外层循环（for、while、 until或者select）的下一次循环。continue后可以跟 上一个数字n，代表跳至外部第n层循环。n必须大于1，如果n比当前循环层数还要大，将跳至最外层的循环。下面的脚本演示了使用continue和continue </p>
<p>2的区别（运行前请将对应的注释符去掉）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建演示脚本continue_01.sh</span> </span><br><span class="line">[root@localhost ~]# cat continue_01.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">for I in A B C D</span><br><span class="line">do </span><br><span class="line">	echo -n &quot;$I:&quot; </span><br><span class="line">	for J in `seq 10` </span><br><span class="line">		do </span><br><span class="line">			if [ $J -eq 5 ]; then </span><br><span class="line">				continue </span><br><span class="line">				#continue 2 </span><br><span class="line">			fi</span><br><span class="line">			echo -n &quot; $J&quot; </span><br><span class="line">		done </span><br><span class="line">	echo </span><br><span class="line">done </span><br><span class="line">echo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断当J 值为5 时，<span class="built_in">continue</span> 的输出结果</span> </span><br><span class="line">[root@localhost ~]# bash continue_01.sh</span><br><span class="line">A: 1 2 3 4 6 7 8 9 10 </span><br><span class="line">B: 1 2 3 4 6 7 8 9 10</span><br><span class="line">C: 1 2 3 4 6 7 8 9 10</span><br><span class="line">D: 1 2 3 4 6 7 8 9 10 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断当J 值为5 时，<span class="built_in">continue</span> 2 的输出结果</span> </span><br><span class="line">[root@localhost ~]# bash continue_01.sh</span><br><span class="line">A: 1 2 3 4B: 1 2 3 4C: 1 2 3 4D: 1 2 3 4</span><br></pre></td></tr></table></figure>

<h5 id="10）将所跟的参数作为Shell的输入，并执行产生的命令：eval"><a href="#10）将所跟的参数作为Shell的输入，并执行产生的命令：eval" class="headerlink" title="10）将所跟的参数作为Shell的输入，并执行产生的命令：eval"></a>10）将所跟的参数作为Shell的输入，并执行产生的命令：eval</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">eval</span> 用法例一：将字符串解析成命令执行</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义cmd 为一个字符串，该字符串为“<span class="built_in">ls</span> -l /etc/passwd ”</span></span><br><span class="line">[root@localhost ~]# cmd=&quot;ls -l /etc/passwd&quot; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果使用<span class="built_in">eval</span> ，则会将之前的字符串解析为命令并执行</span></span><br><span class="line">[root@localhost ~]# eval $cmd </span><br><span class="line">-rw-r--r-- 1 root root 1638 Mar 3 00:43 /etc/passwd </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">eval</span> 用法例二：程序运行中根据某个变量确定实际的变量名 [</span></span><br><span class="line">root@localhost ~]# name1=john </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量name1</span> </span><br><span class="line">[root@localhost ~]# name2=wang </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量name2</span> </span><br><span class="line">[root@localhost ~]# num=1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用该变量确定真实的变量名name<span class="variable">$num</span></span> </span><br><span class="line">[root@localhost ~]# eval echo &quot;$&quot;name$num </span><br><span class="line">John</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">eval</span> 用法例三：将某个变量的值当做另一个变量名并给其赋值</span> </span><br><span class="line">[root@localhost ~]# name1=john </span><br><span class="line">[root@localhost ~]# name2=wang </span><br><span class="line">[root@localhost ~]# eval $name1=&quot;$name2&quot; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等价于john=<span class="string">&quot;wang&quot;</span></span> </span><br><span class="line">[root@localhost ~]# echo $john </span><br><span class="line">wang</span><br></pre></td></tr></table></figure>

<h5 id="11）执行命令来取代当前的Shell：exec"><a href="#11）执行命令来取代当前的Shell：exec" class="headerlink" title="11）执行命令来取代当前的Shell：exec"></a>11）执行命令来取代当前的Shell：exec</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出系统中所有以.conf 结尾的文件</span></span><br><span class="line">[root@localhost ~]# find / -name &quot;*.conf&quot; -exec ls -l &#123;&#125; \; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除系统中所有临时文件</span> </span><br><span class="line">find / -name &quot;*.tmp&quot; -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h5 id="12）使变量能被子Shell识别：export"><a href="#12）使变量能被子Shell识别：export" class="headerlink" title="12）使变量能被子Shell识别：export"></a>12）使变量能被子Shell识别：export</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建export.sh 脚本</span></span><br><span class="line">[root@localhost ~]# cat export.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">echo $var </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接执行这个脚本，由于变量var 在脚本中并没有定义，所以其值是空，脚本输出确实什么也没有</span></span><br><span class="line">[root@localhost ~]# bash export.sh </span><br><span class="line">[root@localhost ~]#</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">无任何输出</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">现在在当前Shell 中创建变量var ，并赋值为100 ，并尝试输出该值</span> </span><br><span class="line">[root@localhost ~]# var=100</span><br><span class="line">[root@localhost ~]# echo $var </span><br><span class="line">100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确实变量var被赋值了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于这里的var和子Shell中的var都是局部变量，所以如果现在再运行子Shell ，依然会打印出空值</span> </span><br><span class="line">[root@localhost ~]# bash export.sh</span><br><span class="line">[root@localhost ~]# </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无任何输出</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是如果在定义变量的时候使用了<span class="built_in">export</span> 就不一样了，子Shell 可以读取该变量</span> </span><br><span class="line">[root@localhost ~]# export var=100</span><br><span class="line">[root@localhost ~]# bash export.sh </span><br><span class="line">100 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里读取到了父Shell的变量var值</span></span><br></pre></td></tr></table></figure>

<h5 id="13）发送信号给指定PID或进程：kill"><a href="#13）发送信号给指定PID或进程：kill" class="headerlink" title="13）发送信号给指定PID或进程：kill"></a>13）发送信号给指定PID或进程：kill</h5><p>Linux是一个多任务的操作系统，系统上经常同时运行着多个进程。我们需要知道如何控制这些进程。Linux操作系统包括3种不同类型的进程，第一种是交互进程，这是由一个Shell启动的进程，既可以在前台运行，也可以在后台运行；第二种是批处 理进程，与终端没有联系，是一个进程序列；第三 种是监控进程，也称系统守护进程，它们往往在系 统启动时启动，并保持在后台运行。 </p>
<p>kill命令用来终止进程，其工作的原理是向系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。比如用ps命令可以看到许多进程，有时需要使用kill中止某些进程来提高系统资源。该命令可以向某个PID或进程发送信号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [ -s signal | -p ] [ -a ] [ - - ] pid ... </span><br><span class="line">[root@localhost ~]# kill -l [ signal ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-s: 指定要发送的信号，信号可以是信号名或是信号数值</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-p: 只打印出进程的PID ，并不真的发送信号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-l: 指定信号的名称列表</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid: 进程的ID号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">signal: 信号</span></span><br></pre></td></tr></table></figure>

<h5 id="14）整数运算：let"><a href="#14）整数运算：let" class="headerlink" title="14）整数运算：let"></a>14）整数运算：let</h5><p>let是Shell内建的整数运算命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">let</span> 使用范例</span> </span><br><span class="line">let I=2+2 ---&gt;I=4 </span><br><span class="line">let J=5-2 ---&gt;J=3 </span><br><span class="line">let K=2*5 ---&gt;K=10 </span><br><span class="line">let L=15/7 ---&gt;L=2 （整数计算，所以计算结果也是整数）</span><br><span class="line">let M=15%7 ---&gt;M=1 （求余） </span><br><span class="line">let N=2**3 ---&gt;N=8 （代表2 的3 次方） </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">let</span> 也支持类C 的计算方式</span> </span><br><span class="line">let i++ （i 自增1 ）</span><br><span class="line">let i-- （i 自减1 ）</span><br><span class="line">let i+=10 （i 值等于i 增加10 ）</span><br><span class="line">let i-=10 （i 值等于i 减少10 ）</span><br><span class="line">let i*=10 （i 值等于i 乘以10 ）</span><br><span class="line">let i/=10 （i 值等于i 除以10 ）</span><br><span class="line">let i%=10 （i 值等于i 模10 ）</span><br></pre></td></tr></table></figure>

<h5 id="15）显示当前工作目录：pwd"><a href="#15）显示当前工作目录：pwd" class="headerlink" title="15）显示当前工作目录：pwd"></a>15）显示当前工作目录：pwd</h5><p>pwd命令会打印当前工作目录的绝对路径名。如果使用-P选项，打印出的路径名中不会包含符号连接。如果使用了-L选项，打印出的路径中可以包含符号连接。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行<span class="built_in">pwd</span> 可以显示当前所在目录的绝对路径</span> </span><br><span class="line">[root@localhost ~]# pwd </span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">变量OLDPWD记录了上一次工作目录，如果你从登录系统之后一直没有改变工作目录，则 OLDPWD 为空</span></span><br><span class="line">[root@localhost ~]# echo $OLDPWD </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里为空</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">变量PWD 记录了当前的工作目录，它与<span class="built_in">pwd</span> 命令运行结果是一致的</span> </span><br><span class="line">[root@localhost ~]# echo $PWD </span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/tmp 目录</span></span><br><span class="line">[root@localhost ~]# cd /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这时OLDPWD 记录了上一次工作目录/root ，所以此处输出为/root</span> </span><br><span class="line">[root@localhost ~]# echo $OLDPWD </span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面将演示-P 和-L 参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先确定/var/mail 目录其实是一个软连接</span> </span><br><span class="line">[root@localhost ~]# ls -l /var/mail </span><br><span class="line">lrwxrwxrwx 1 root root 10 Nov 27 17:54 /var/mail - &gt; spool/mail </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/var/mail 目录</span></span><br><span class="line">[root@localhost ~]# cd /var/mail </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用-L 参数和不加参数的<span class="built_in">pwd</span> 命令输出结果是一样的</span></span><br><span class="line">[root@localhost mail]# pwd -L </span><br><span class="line">/var/mail </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用-P 参数则显示出真实的路径，而不是软链接</span> </span><br><span class="line">[root@localhost mail]# pwd -P </span><br><span class="line">/var/spool/mail</span><br></pre></td></tr></table></figure>

<h5 id="16）声明局部变量：local"><a href="#16）声明局部变量：local" class="headerlink" title="16）声明局部变量：local"></a>16）声明局部变量：local</h5><p>该命令用于在脚本中声明局部变量，典型的用法是用于函数体内，其作用域也在声明该变量的函 数体中。如果试图在函数外使用local声明变量，则会提示错误。 </p>
<h5 id="17）从标准输入读取一行到变量：read"><a href="#17）从标准输入读取一行到变量：read" class="headerlink" title="17）从标准输入读取一行到变量：read"></a>17）从标准输入读取一行到变量：read</h5><p>有时候开发的脚本必须具有交互性，也就是在运行过程中依赖人工输入才能继续。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据输入的箱数计算一共有多少瓶啤酒</span> </span><br><span class="line">[root@localhost ~]# cat read.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">declare N </span><br><span class="line">echo &quot;12 bottles of beer in a box&quot; </span><br><span class="line">echo -n &quot;How many box do you want:&quot; </span><br><span class="line">read N</span><br><span class="line">echo &quot;$((N*12)) bottle in total&quot; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行效果</span> </span><br><span class="line">[root@localhost ~]# bash read.sh </span><br><span class="line">12 bottles of beer in a box </span><br><span class="line">How many box do you want:10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里输入数字</span> </span><br><span class="line">120 bottle in total</span><br></pre></td></tr></table></figure>

<h5 id="18）定义函数返回值：return"><a href="#18）定义函数返回值：return" class="headerlink" title="18）定义函数返回值：return"></a>18）定义函数返回值：return</h5><p>典型的用于函数中，常见用法是return n，其中n是一个指定的数字，使函数以指定值退出。如果没有指定n值，则返回状态是函数体中执行的最后一个命令的退出状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat return.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义了一个函数fun_01 ，该函数简单地返回1</span> </span><br><span class="line">function fun_01 </span><br><span class="line">&#123; </span><br><span class="line">	return 1 </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用该函数 fun_01</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看之前函数的返回值</span> </span><br><span class="line">echo $?</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实际运行一下这个脚本的效果</span> </span><br><span class="line">[root@localhost ~]# bash return.sh </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="19）向左移动位置参数：shift"><a href="#19）向左移动位置参数：shift" class="headerlink" title="19）向左移动位置参数：shift"></a>19）向左移动位置参数：shift</h5><p>要想搞清楚shift的用法，首先需要了解脚本“位置参数”的概念。假设一个脚本在运行时可以接受参数，那么从左到右第一个参数被记作<code>$1</code>，第二个参数为<code>$2</code>，以此类推，第n个参数为<code>$N</code>。所有参数记作$@或$*，参数的总个数记作<code>$#</code>，而脚本本身 记作<code>$0</code>。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过该脚本了解<span class="variable">$0</span> 、<span class="variable">$1</span> 、<span class="variable">$2</span> 、<span class="variable">$3</span> 、<span class="variable">$@</span>、<span class="variable">$#</span> 等符号的含义</span> </span><br><span class="line">[root@localhost ~]# cat shift_01.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">echo &quot;This script&#x27;s name is:$0&quot; </span><br><span class="line">echo &quot;The First parameter is:$1&quot; </span><br><span class="line">echo &quot;The Second parameter is:$2&quot; </span><br><span class="line">echo &quot;The Third parameter is:$3&quot; </span><br><span class="line">echo &quot;All of the parameters are $@&quot; </span><br><span class="line">echo &quot;Count of parameter is:$#&quot; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行该脚本的效果</span></span><br><span class="line">[root@localhost ~]# bash shift_01.sh 1 2 3 </span><br><span class="line">This script&#x27;s name is:shift_01.sh </span><br><span class="line">The First parameter is:1 </span><br><span class="line">The Second parameter is:2 </span><br><span class="line">The Third parameter is:3 </span><br><span class="line">All of the parameters are 1 2 3 </span><br><span class="line">Count of parameter is:3</span><br></pre></td></tr></table></figure>

<p>shift命令可以对脚本的参数做“偏移”操作。假设脚本有A、B、C这3个参数，那么<code>$1</code>为A，<code>$2</code>为B， <code>$3</code>为C；shift一次后，<code>$1</code>为B，<code>$2</code>为C；再次shift后 <code>$1</code>为C。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过阅读该脚本了解<span class="built_in">shift</span> 命令的作用</span> </span><br><span class="line">[root@localhost ~]# cat shift_02.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">until [ -z &quot;$1&quot; ] </span><br><span class="line">do </span><br><span class="line">	echo &quot;$@ &quot; </span><br><span class="line">	shift</span><br><span class="line">Done </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行该脚本，使用A B C 这3 个参数</span> </span><br><span class="line">[root@localhost ~]# bash shift_02.sh A B C </span><br><span class="line">A B C</span><br><span class="line">B C </span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h5 id="20）测试表达式：test"><a href="#20）测试表达式：test" class="headerlink" title="20）测试表达式：test"></a>20）测试表达式：test</h5><p>该命令用于测试表达式EXPRESSION的值，根据测试结果返回0（测试失败）或1（测试成功）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# test EXPRESSION</span><br></pre></td></tr></table></figure></li>
<li><h4 id="Shell版本"><a href="#Shell版本" class="headerlink" title="Shell版本"></a>Shell版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认系统中使用的Shell 是bash</span></span><br><span class="line">[root@localhost ~]# echo $SHELL </span><br><span class="line">/bin/bash </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中Bash Shell 的版本（方法一）</span> </span><br><span class="line">[root@localhost ~]# bash --version </span><br><span class="line">GNU bash, version 3.2.25(1)-release (i686-redhat-linux-gnu) Copyright (C) 2005 Free Software Foundation, Inc. </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中Bash Shell 的版本（方法二）</span> </span><br><span class="line">[root@localhost ~]# echo $BASH_VERSION </span><br><span class="line">3.2.25(1)-release</span><br></pre></td></tr></table></figure></li>
<li><h4 id="Shell编程基础"><a href="#Shell编程基础" class="headerlink" title="Shell编程基础"></a>Shell编程基础</h4><h5 id="1）变量"><a href="#1）变量" class="headerlink" title="1）变量"></a>1）变量</h5><p>​        从变量的实质来说，变量名是指向一片用于存储数据的 内存空间。变量有局部变量、环境变量之分。Shell 变量是一种弱类型的变量，也就是说在声明变量时并不需要指定其变量类型，而且也不需要遵循C语言中“先声明再使用”的规定，任何时候只要想用就 可以用。在脚本中，往往需要使用变量来存储有用信息，比如文件名、路径名、数值等，通过这些变量可以控制脚本的运行行为。</p>
<p>​        局部变量就是指在某个Shell中生效的变量，对其他Shell来说无效，而且会随着当前Shell的消失而消失，局部变量的作用域被限定在声明它们的Shell中，可以使用local内建命令来“显式”的声明局部变量，但仅限于函数内使用。</p>
<p>​        环境变量通常又称“全局变量”，以区别于局部变量。在Shell脚本中，变量默认就是全局的，无论 在脚本的任何位置声明，但是为了让子Shell继承当 前Shell的变量，则可以使用export内建命令将其导出为环境变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# export VAR=value</span><br></pre></td></tr></table></figure>

<p>其中，VAR是变量的名字，value为值，使用等号相连，==注意等号两端没有空格==。</p>
<p><strong>变量：EUID</strong> </p>
<p>记录当前用户的UID。当前的用户是root，所以该值应该为0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $EUID</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>变量：FUNCNAME</strong> </p>
<p>在用户函数体内部，记录当前函数体的函数名。创建funcname.sh文件，内容如下（运行该脚本后注意查看脚本的输出）:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat funcname.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">funcname() </span><br><span class="line">&#123; </span><br><span class="line">	echo $FUNCNAME </span><br><span class="line">&#125;</span><br><span class="line">funcname </span><br><span class="line">[root@localhost ~]# bash funcname.sh </span><br><span class="line">funcname</span><br></pre></td></tr></table></figure>

<p><strong>变量：HISTCMD</strong> </p>
<p>记录下一条命令在history命令中的编号。如果运行history命令查看到history中一共记录了1016条已经执行过的命令，则下面一条命令的编号将是1018（因为本次history为第1017条命令）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# history </span><br><span class="line">......( 略去内容)...... </span><br><span class="line">1016 history</span><br><span class="line">[root@localhost ~]# echo $HISTCMD </span><br><span class="line">1018</span><br></pre></td></tr></table></figure>

<p><strong>变量：HISTFILE</strong> </p>
<p>记录history命令记录文件的位置。运行history命令将打印出已经运行过的命令列表，即便重启机器之后还能保存以前的命令记录。但这是如何做到的呢？其实history只不过是找到$HISTFILE所指定的命令记录文件，并将其打印出来。一般默认每个用户的家目录下都有一个.bash_history文件，用于记录该用户运行过的命令历史记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $HISTFILE </span><br><span class="line">/root/.bash_history</span><br></pre></td></tr></table></figure>

<p><strong>变量：OLDPWD</strong></p>
<p>记录之前目录，这个值是什么由之前所在的那个目录决定。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/mnt 目录</span></span><br><span class="line">[root@localhost ~]# cd /mnt </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/root 目录</span></span><br><span class="line">[root@localhost mnt]# cd </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看看之前在哪个目录</span> </span><br><span class="line">[root@localhost ~]# echo $OLDPWD</span><br><span class="line">/mnt</span><br></pre></td></tr></table></figure>

<h5 id="2-变量赋值和取值"><a href="#2-变量赋值和取值" class="headerlink" title="2)变量赋值和取值"></a>2)变量赋值和取值</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义变量：变量名=变量值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意点一：变量名和变量值之间用等号紧紧相连，之间没有任何空格</span> </span><br><span class="line">[root@localhost ~]# name=john </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不注意，等号任何一边出现空格就会出错</span> </span><br><span class="line">[root@localhost ~]# name = john </span><br><span class="line">-bash: name: command not found </span><br><span class="line">[root@localhost ~]# name=&quot;john&quot; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样也是可以的</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意点二：当变量中有空格时必须用引号括起，否则会出现错误</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中的引号可以是双引号，也可以是单引号</span> </span><br><span class="line">[root@localhost ~]# name=&quot;john wang&quot; </span><br><span class="line">[root@localhost ~]# name=john wang </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-bash: wang: <span class="built_in">command</span> not found</span></span><br></pre></td></tr></table></figure>

<p>变量的取值也很简单，只需要在变量名前加上 <code>$</code>符号既可，严谨一点的写法是<code>$&#123;&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $name</span><br><span class="line">john wang</span><br><span class="line">[root@localhost ~]# echo $&#123;name&#125;</span><br><span class="line">john wang </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="variable">$&#123;&#125;</span> 获取变量值是一种相对比较保险的方式</span></span><br><span class="line">[root@localhost ~]# name=&quot;sue &quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里本是想打印名字，后面跟Hello 的，但Shell 试图将nameHello 解释为一个变量。 从Shell 语法来说，也确实应该将nameHello 解释为变量</span> </span><br><span class="line">[root@localhost ~]# echo $nameHello</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为变量nameHello 未声明，所以值为空</span></span><br><span class="line">[root@localhost ~]# echo $&#123;name&#125;Hello </span><br><span class="line">sue Hello</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意点三：如果变量值引用的是其他变量，则必须使用双引号。因为单引号会阻止 Shell 解释特殊字符$</span></span><br><span class="line">[root@localhost ~]# name=john </span><br><span class="line">[root@localhost ~]# name1=&quot;$name&quot; </span><br><span class="line">[root@localhost ~]# echo $name1 </span><br><span class="line">john </span><br><span class="line">[root@localhost ~]# name1=&#x27;$name&#x27; </span><br><span class="line">[root@localhost ~]# echo $name1 </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name</span></span><br></pre></td></tr></table></figure>

<p>由于Shell具有“弱变量”的特性，因此即便在没有预先声明变量的时候也是可以引用的，而且没有 任何报错或者提醒，这可能会造成脚本中引用不正 确的变量，从而导致脚本异常，但是却很难找出原因。在这种情况下，可以设置脚本运行时必须遵循“先声明再使用”的原则，这样一旦脚本中出现使用未声明的变量的情况则立刻报错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $unDefinedVar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为该变量未声明，所以值为空，但没有任何报错 <span class="comment">#设置变量必须先声明再使用</span></span></span><br><span class="line">[root@localhost ~]# shopt -s -o nounset </span><br><span class="line">[root@localhost ~]# echo $unDefinedVar</span><br><span class="line">-bash: unDefinedVar: unbound variable</span><br></pre></td></tr></table></figure>

<h5 id="3）取消变量"><a href="#3）取消变量" class="headerlink" title="3）取消变量"></a>3）取消变量</h5><p>取消变量指的是将变量从内存中释放，使用的命令是unset，后面跟变量名。函数也是可以被取消的，所以unset后面还可以跟上函数名以取消函数。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取消变量</span> </span><br><span class="line">[root@localhost ~]# name=john</span><br><span class="line">[root@localhost ~]# echo $name </span><br><span class="line">john </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时变量有值</span></span><br><span class="line">[root@localhost ~]# unset name</span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量中已经没有内容了</span></span><br><span class="line">[root@localhost ~]# </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取消函数</span> </span><br><span class="line">unset_function()</span><br><span class="line">&#123; </span><br><span class="line">	echo &quot;Hello World&quot; </span><br><span class="line">&#125;</span><br><span class="line">unset unset_function </span><br><span class="line">unset_function </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于函数已被取消，这里调用会出错</span></span><br></pre></td></tr></table></figure>

<h5 id="4）特殊变量"><a href="#4）特殊变量" class="headerlink" title="4）特殊变量"></a>4）特殊变量</h5><p>Shell中还有一些预先定义的特殊只读变量，它们的值只有在脚本运行时才能确定。首先是“位置参数”，位置参数的命名简单直接，比如，脚本本身为<code>$0</code>，第一个参数为<code>$1</code>，第二个参数为<code>$2</code>，第三个为<code>$3</code>，以此类推。当位置参数的个数大于9时，需要用<code>$&#123;&#125;</code>括起来标识，比如说第10个位置参数应该记为<code>$&#123;10&#125;</code>。另外，<code>$#</code>表示脚本参数的个数总 和，<code>$@或$*</code>表示脚本的所有参数。下面的示例脚本使用了这些特殊的位置参数，请注意不同位置参数的输出。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat posion.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">echo &quot;This script&#x27;s name is: $0&quot; </span><br><span class="line">echo &quot;$# parameters in total&quot; </span><br><span class="line">echo &quot;All parameters list as: $@&quot;</span><br><span class="line">echo &quot;The first parameter is $1&quot; </span><br><span class="line">echo &quot;The second parameter is $2&quot; </span><br><span class="line">echo &quot;The third parameter is $3&quot; </span><br><span class="line">[root@localhost ~]# bash posion.sh para1 para2 para3 This script&#x27;s name is: posion.sh 3 parameters in total All parameters list as: para1 para2 para3 The first parameter is para1 The second parameter is para2 The third parameter is para3</span><br></pre></td></tr></table></figure>

<p><strong>脚本或命令返回值：$?</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入错误的命令时的返回值</span></span><br><span class="line">[root@localhost ~]# ifconfi </span><br><span class="line">-bash: ifconfi: command not found </span><br><span class="line">[root@localhost ~]# echo $? </span><br><span class="line">127</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">尝试ping 主机ping 不通时的返回值</span> </span><br><span class="line">[root@localhost ~]# ping 192.168.61.100 -c 1 </span><br><span class="line">PING 192.168.61.100 (192.168.61.100) 56(84) bytes of data. From 192.168.61.131 icmp_seq=1 Destination Host Unreachable --- 192.168.61.100 ping statistics --- 1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms</span><br><span class="line">[root@localhost ~]# echo $? </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="5）数组"><a href="#5）数组" class="headerlink" title="5）数组"></a>5）数组</h5><ol>
<li><p><strong>数组定义：</strong></p>
<p>数组的定义方法如下：用declare命令定义数组Array，并将第一个元素赋值为0，第二个元素赋值 为1，其下标（也就是索引）则分别是0和1（记住 数组的索引是从0开始计数的），然后打印出第一个元素的值。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义名为Array 的索引数组</span> </span><br><span class="line">[root@localhost ~]# declare -a Array</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的下标从0 开始计数，定义了第一个元素值为0 ，第二个元素值为1</span> </span><br><span class="line">[root@localhost ~]# Array[0]=0</span><br><span class="line">[root@localhost ~]# Array[1]=1</span><br></pre></td></tr></table></figure>

<p>如果说数组Array的前两个元素“类型相同”（严格意义上这么说是不对的），那么第三个元素就显得“另类”了：赋值为一个字符串。这又一次验证了 Shell变量是弱类型的，这在很多语言中是不可能的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# Array[2]=&quot;HelloWorld&quot;</span><br></pre></td></tr></table></figure>

<p>和其他变量一样，Shell中对于数组变量的声明也非常宽松，而且随时都可以根据需要增加变量中的元素。相比其他语言，Shell的数据更为灵活。在 很多语言中，一旦对数组进行了初始化就不能再改变大小了。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组还可以在创建的同时赋值</span></span><br><span class="line">[root@localhost ~]# declare -a Name=(&#x27;john&#x27; &#x27;sue&#x27;) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加元素</span> </span><br><span class="line">[root@localhost ~]# Name[2]=&#x27;wang&#x27; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更简单的创建数组的方式——不使用<span class="built_in">declare</span> 关键字</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[root@localhost ~]<span class="comment"># Name=(&#x27;john&#x27; &#x27;sue&#x27;)</span></span></span><br></pre></td></tr></table></figure>

<p>还可以给特定的元素赋值。下面的示例就是只对第四个、第六个、第八个元素进行赋值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">跳号赋值</span> </span><br><span class="line">[root@localhost ~]# Score=([3]=3 [5]=5 [7]=7)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组操作 ：</strong></p>
<p><strong>数组取值</strong>：知道了如何定义数组和赋值元素后，下面就要了解数组的一些常见操作。最简单的操作就是数组取值，其格式为：${数组名[索引]}。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取数组第一个元素的值</span> </span><br><span class="line">[root@localhost ~]# echo $&#123;Array[0]&#125; </span><br><span class="line">0</span><br><span class="line">[root@localhost ~]# echo $&#123;Array[2]&#125; </span><br><span class="line">HelloWorld </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印数组中的元素值</span> </span><br><span class="line">[root@localhost ~]# echo $&#123;Name[0]&#125; </span><br><span class="line">john </span><br><span class="line">[root@localhost ~]# echo $&#123;Name[1]&#125; </span><br><span class="line">sue</span><br></pre></td></tr></table></figure>

<p>指定索引只能列举单个元素，要是想一次性取出所有元素的值，可以采取以下两种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $&#123;Array[@]&#125; </span><br><span class="line">0 1 HelloWorld </span><br><span class="line">[root@localhost ~]# echo $&#123;Array[*]&#125;</span><br><span class="line">0 1 HelloWorld</span><br></pre></td></tr></table></figure>

<p><strong>数组长度</strong>：即数组元素个数。利用“@”或“* ”字符，可以将数组扩展成列表，然后使 用“#”来获取数组元素的个数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $&#123;#Array[@]&#125;</span><br><span class="line">3</span><br><span class="line">[root@localhost ~]# echo $&#123;#Array[*]&#125; </span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>如果某个元素是字符串，还可以通过指定索引的方式获得该元素的长度。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $&#123;#Array[2]&#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p><strong>数组截取</strong>：可以截取某个元素的一部分，对象可以是整个数组或某个元素。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取出数组的第一、第二个元素</span> </span><br><span class="line">[root@localhost ~]# echo $&#123;Array[@]:1:2&#125; </span><br><span class="line">1 HelloWorld</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取出第二个元素从第0 个字符开始连续5 个字符</span></span><br><span class="line">[root@localhost ~]# echo $&#123;Array[2]:0:5&#125;</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p><strong>连接数组</strong>：将若干个数组进行拼接操作。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# Conn=($&#123;Array[@]&#125; $&#123;Name[@]&#125;) </span><br><span class="line">[root@localhost ~]# echo $&#123;Conn[@]&#125; </span><br><span class="line">0 1 HelloWorld john sue</span><br></pre></td></tr></table></figure>

<p><strong>替换元素</strong>：将数组内某个元素的值替换成其他值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# Array=($&#123;Array[@]/HelloWorld/HelloJohn&#125;) </span><br><span class="line">[root@localhost ~]# echo $&#123;Array[@]&#125;</span><br><span class="line">0 1 HelloJohn</span><br></pre></td></tr></table></figure>

<p><strong>取消数组或元素</strong>：和取消一般变量一样，取消一个数组的方式也使用unset命令。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取消数组中的一个元素</span> </span><br><span class="line">[root@localhost ~]# unset Array[1]</span><br><span class="line">[root@localhost ~]# echo $&#123;Array[@]&#125; </span><br><span class="line">0 HelloJohn</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取消整个数组</span></span><br><span class="line">[root@localhost ~]# unset Array</span><br><span class="line">[root@localhost ~]# echo $&#123;Array[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本行打印为空，说明Array 已经被取消了</span></span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="6-只读变量"><a href="#6-只读变量" class="headerlink" title="6) 只读变量"></a>6) 只读变量</h5><p>只读变量又称常量，是通过readonly内建命令创建的变量。这种变量在声明时就要求赋值，并且之 后无法修改，这和之前讲到的使用declare-r声明只读变量的效果是一致的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明只读变量RO 并赋值为100</span> </span><br><span class="line">[root@localhost ~]# readonly RO=100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此处尝试修改RO 的值，Shell 会报错</span> </span><br><span class="line">[root@localhost ~]# RO=200</span><br><span class="line">-bash: RO: readonly variable</span><br></pre></td></tr></table></figure>

<h5 id="7-转义和引用"><a href="#7-转义和引用" class="headerlink" title="7) 转义和引用"></a>7) 转义和引用</h5><p>Shell中有两类字符，一类是普通字符，在Shell中除了本身的字面意思外没有其他特殊意义，即普 通纯文本（literal）；另一类即元字符（meta），是 Shell的保留字符，在Shell中有着特殊意义。这在很多时候会造成麻烦：比如说想要在程序中用美元符 打印商品的价格，但是这个符号一般被解析成提取 变量的值。为了消除这些特殊字符的功能，就必须对其进行转义和引用。</p>
<ul>
<li><strong>转义</strong> </li>
</ul>
<p>转义是指使用转义符引用单个字符，从而使其表达单纯的字符的字面含义。Shell中的转义符是反 斜线“\”，使用转义符的目的是使转义符后面的字符单纯地作为字符出现，而不解释其特殊的含义。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">试图打印“<span class="variable">$Dollar</span> ”字符串的错误演示</span></span><br><span class="line">[root@localhost ~]# echo $Dollar</span><br><span class="line"><span class="meta prompt_">---&gt; </span><span class="language-bash">此处打印为空，因为Shell 尝试打印出变量Dollar 的值，但是这个变量并没有声明，所以打印空行</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用转义字符转义$ 字符</span></span><br><span class="line">[root@localhost ~]# echo \$Dollar </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Dollar</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更多的例子</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印乘号。如果不用转义符转义* 号，则* 号会作为一般的通配符使用，结果是将工作目录中的 所有目录和文件名替换它</span> </span><br><span class="line">[root@localhost ~]# echo 8 \* 8 =64</span><br><span class="line">8 * 8 =64</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">句子中含有引号。如果不用转义符转义<span class="string">&#x27; 单引号，则Shell 会等待出现另一个单引号才能结束echo 进程</span></span></span><br><span class="line">[root@localhost ~]# echo john\&#x27;s cat </span><br><span class="line">john&#x27;s cat</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>引用</strong> </li>
</ul>
<p>引用是指将字符串用某种符号括起来，以防止特殊字符被解析为其他意思。比如说上一小节中的转义符就是一种引用。Shell中一共有4种引用符，分别是双引号、单引号、反引号（在键盘上和波浪 号位于同一个键）和转义符。其中双引号又叫“部分引用”或“弱引用”，可以引用除$符、反引号、转义符之外的所有字符；单引号又叫“全引用”或“强引用”，可以引用所有字符；反引号则会将反引号括起的内容解释为系统命令。</p>
<p>1）部分引用</p>
<p>部分引用是指用双引号括起来的引用。在这种 引用方式中，<code>$</code>符、反引号（`）、转义符（\）这3种特殊字符依然会被解析为特殊意义。比如，在定义一个变量后，使用echo打印该变量的时候，将它们用双引号括起来。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明变量VAR03 ，并用<span class="built_in">echo</span> 打印出来。第一次直接打印，第二次用引号括起来，从输出内容看好像没什么区别</span> </span><br><span class="line">[root@localhost ~]# VAR03=100 </span><br><span class="line">[root@localhost ~]# echo $VAR03 </span><br><span class="line">100 </span><br><span class="line">[root@localhost ~]# echo &quot;$VAR03&quot; </span><br><span class="line">100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明变量VAR03，内容为字符串，ABC 之间有多个空格</span> </span><br><span class="line">[root@localhost ~]# VAR04=&quot;A B C&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接打印变量时，输出内容只保留了每个字母间一个空格</span> </span><br><span class="line">[root@localhost ~]# echo $VAR04 </span><br><span class="line">A B C</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用引号括起的输出内容和变量定义时的内容是完全一致的</span></span><br><span class="line">[root@localhost ~]# echo &quot;$VAR04&quot; </span><br><span class="line">A B C</span><br></pre></td></tr></table></figure>

<p>2）全引用 </p>
<p>全引用是指用单引号括起来的引用。单引号中的任何字符都只当作是普通字符（除了单引号本身，也就是说单引号中间无法再包含单引号，即便用转义符转义单引号也不行）。所有在单引号中的字符都只能代表其作为字符的字面意义。如果用单引号引用之前声明的变量，输出的内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &#x27;$VAR03&#x27; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VAR03</span> </span><br><span class="line">[root@localhost ~]# echo &#x27;$VAR04&#x27; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VAR04</span></span><br></pre></td></tr></table></figure>

<p>可以看到，输出内容就是单引号所括起来的所有内容，而不会将变量解析为其值。 </p>
<p>如果全引用括起的字符串中还含有单引号，则 会出现问题，因为Shell无法区分哪个单引号是引用的结束符，就像下面显示的一样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &#x27;It&#x27;s a dog&#x27; </span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要解决这个问题，可以采取如下两种方式： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &#x27;It&#x27;\&#x27;&#x27;s a dog&#x27; </span><br><span class="line">It&#x27;s a dog</span><br><span class="line">[root@localhost ~]# echo &quot;It&#x27;s a dog&quot; </span><br><span class="line">It&#x27;s a dog</span><br></pre></td></tr></table></figure>

<h5 id="8-其他算术运算"><a href="#8-其他算术运算" class="headerlink" title="8)其他算术运算"></a>8)其他算术运算</h5><ul>
<li><strong>使用$[]做运算</strong></li>
</ul>
<p><code>$[]</code>和<code>$(())</code>类似，可用于简单的算术运算，以下 给出使用方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $[1+1] </span><br><span class="line">2</span><br><span class="line">[root@localhost ~]# echo $[2-1]</span><br><span class="line">1</span><br><span class="line">[root@localhost ~]# echo $[2*2] </span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">除法运算，由于是整数操作，舍去小数</span> </span><br><span class="line">[root@localhost ~]# echo $[5/2] </span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">求余运算</span> </span><br><span class="line">[root@localhost ~]# echo $[5%2] </span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">幂运算</span></span><br><span class="line">[root@localhost ~]# echo $[5**2] </span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用expr做运算</strong> </li>
</ul>
<p>expr命令也可用于整数运算。和其他算术运算方式不同，expr要求操作数和操作符之间使用空格隔开（否则只会打印出字符串），所以特殊的操作符要使用转义符转义（比如<code>*</code>）。expr支持的算术运算符有加、减、乘、除、余等，如下所示： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">操作符和操作数之间没有空格则只会打印出字符串</span> </span><br><span class="line">[root@localhost ~]# expr 1+1 </span><br><span class="line">1+1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用空格隔开后可以正常计算</span> </span><br><span class="line">[root@localhost ~]# expr 1 + 1 </span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">特殊符号（元字符）需要用转义符转义，否则出错</span> </span><br><span class="line">[root@localhost ~]# expr 2 * 2 </span><br><span class="line">expr: syntax error </span><br><span class="line">[root@localhost ~]# expr 2 \* 2 </span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内建运算命令declare</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例1 ：不使用<span class="built_in">declare</span> 定义变量</span></span><br><span class="line">[root@localhost ~]# I=1+1 </span><br><span class="line">[root@localhost ~]# echo $I </span><br><span class="line">1+1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例2 ：使用<span class="built_in">declare</span> 定义变量</span></span><br><span class="line">[root@localhost ~]# declare -i J </span><br><span class="line">[root@localhost ~]# J=1+1 </span><br><span class="line">[root@localhost ~]# echo $J </span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意，Shell 中的算术运算要求运算符和操作数之间不能有空格，而是紧密连接的；特殊符号在 这里也不需要用转义符转义（比如这里的+号）；如果算术表达式中含有其他变量也不需要用$ 引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>算术扩展</strong></li>
</ul>
<p>算术扩展是Shell提供的整数变量的运算机制，是Shell的内建命令之一。其基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(( 算术表达式))</span></span><br></pre></td></tr></table></figure>

<p>其中的算术表达式由变量和运算符组成，常见的用法是显示输出和变量赋值。若表达式中的变量没有定义，则在计算时，其值会被假设为0（但是并不会真的因此赋0值给该变量）。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示输出： <span class="built_in">echo</span> $(( 算术表达式))</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例子：计算2*i+1 的值</span></span><br><span class="line">[root@localhost ~]# i=2</span><br><span class="line">[root@localhost ~]# echo $((2*i+1))</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意这里变量i前并没有$符</span></span><br><span class="line">5</span><br><span class="line">[root@localhost ~]# echo $((2*(i+1)))</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用括号改变运算优先级 6<span class="comment">#变量赋值</span></span> </span><br><span class="line">var=$(( 算术表达式)) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例子：将2*i+1 的值赋值给变量var</span></span><br><span class="line">[root@localhost ~]# var=$((2*i+1))</span><br><span class="line">[root@localhost ~]# echo $var </span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">未定义的变量参与算术表达式求值</span></span><br><span class="line">[root@localhost ~]# echo $((2*(j+1)))</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/">https://centlabs.github.io/2022/03/25/Shell%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Shell/">Shell</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/26/ACM/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Coding</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/25/Linux%20%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux 系统命令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/25/Linux%20%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" title="Linux 系统命令"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-25</div><div class="title">Linux 系统命令</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">Shell 脚本语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Shell简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89Shell"><span class="toc-number">1.1.1.</span> <span class="toc-text">1）Shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89Bourne-Shell"><span class="toc-number">1.1.2.</span> <span class="toc-text">2）Bourne Shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89Shell-%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">3）Shell 功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAShell%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">第一个Shell脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）运行脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89Shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E6%8E%92%E9%94%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）Shell 脚本的排错</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">Shell的内建命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%EF%BC%9Atype"><span class="toc-number">1.3.1.</span> <span class="toc-text">1）如何确定内建命令：type</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%9A%E2%80%9C-%E2%80%9D%EF%BC%88%E7%82%B9%E5%8F%B7%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2）执行程序：“.”（点号）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%88%AB%E5%90%8D%EF%BC%9Aalias"><span class="toc-number">1.3.3.</span> <span class="toc-text">3）别名：alias</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E5%88%A0%E9%99%A4%E5%88%AB%E5%90%8D%EF%BC%9Aunalias"><span class="toc-number">1.3.4.</span> <span class="toc-text">4）删除别名：unalias</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E4%BB%BB%E5%8A%A1%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2%EF%BC%9Abg%E3%80%81fg%E3%80%81jobs"><span class="toc-number">1.3.5.</span> <span class="toc-text">5）任务前后台切换：bg、fg、jobs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%89%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%EF%BC%9Adeclare%E3%80%81typeset"><span class="toc-number">1.3.6.</span> <span class="toc-text">6）声明变量：declare、typeset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%EF%BC%89%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%EF%BC%9Aecho"><span class="toc-number">1.3.7.</span> <span class="toc-text">7）打印字符：echo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%89%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%EF%BC%9Abreak"><span class="toc-number">1.3.8.</span> <span class="toc-text">8）跳出循环：break</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%EF%BC%89%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%EF%BC%9Acontinue"><span class="toc-number">1.3.9.</span> <span class="toc-text">9）循环控制：continue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%EF%BC%89%E5%B0%86%E6%89%80%E8%B7%9F%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BAShell%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%8C%E5%B9%B6%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9Aeval"><span class="toc-number">1.3.10.</span> <span class="toc-text">10）将所跟的参数作为Shell的输入，并执行产生的命令：eval</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%EF%BC%89%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%9D%A5%E5%8F%96%E4%BB%A3%E5%BD%93%E5%89%8D%E7%9A%84Shell%EF%BC%9Aexec"><span class="toc-number">1.3.11.</span> <span class="toc-text">11）执行命令来取代当前的Shell：exec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%EF%BC%89%E4%BD%BF%E5%8F%98%E9%87%8F%E8%83%BD%E8%A2%AB%E5%AD%90Shell%E8%AF%86%E5%88%AB%EF%BC%9Aexport"><span class="toc-number">1.3.12.</span> <span class="toc-text">12）使变量能被子Shell识别：export</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%EF%BC%89%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E6%8C%87%E5%AE%9APID%E6%88%96%E8%BF%9B%E7%A8%8B%EF%BC%9Akill"><span class="toc-number">1.3.13.</span> <span class="toc-text">13）发送信号给指定PID或进程：kill</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%EF%BC%89%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%EF%BC%9Alet"><span class="toc-number">1.3.14.</span> <span class="toc-text">14）整数运算：let</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%EF%BC%89%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%9Apwd"><span class="toc-number">1.3.15.</span> <span class="toc-text">15）显示当前工作目录：pwd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%EF%BC%89%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9Alocal"><span class="toc-number">1.3.16.</span> <span class="toc-text">16）声明局部变量：local</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%EF%BC%89%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%88%B0%E5%8F%98%E9%87%8F%EF%BC%9Aread"><span class="toc-number">1.3.17.</span> <span class="toc-text">17）从标准输入读取一行到变量：read</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%EF%BC%89%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9Areturn"><span class="toc-number">1.3.18.</span> <span class="toc-text">18）定义函数返回值：return</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%EF%BC%89%E5%90%91%E5%B7%A6%E7%A7%BB%E5%8A%A8%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%EF%BC%9Ashift"><span class="toc-number">1.3.19.</span> <span class="toc-text">19）向左移动位置参数：shift</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%EF%BC%89%E6%B5%8B%E8%AF%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9Atest"><span class="toc-number">1.3.20.</span> <span class="toc-text">20）测试表达式：test</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.</span> <span class="toc-text">Shell版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.</span> <span class="toc-text">Shell编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1）变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC"><span class="toc-number">1.5.2.</span> <span class="toc-text">2)变量赋值和取值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%8F%96%E6%B6%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">3）取消变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">4）特殊变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">5）数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">6) 只读变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%BD%AC%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">7) 转义和引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%85%B6%E4%BB%96%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">1.5.8.</span> <span class="toc-text">8)其他算术运算</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/23/Mediapipe%E5%85%A5%E9%97%A8/" title="Mediapipe入门:搭建姿态检测模型并实时输出人体关节点3d坐标"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mediapipe入门:搭建姿态检测模型并实时输出人体关节点3d坐标"/></a><div class="content"><a class="title" href="/2022/04/23/Mediapipe%E5%85%A5%E9%97%A8/" title="Mediapipe入门:搭建姿态检测模型并实时输出人体关节点3d坐标">Mediapipe入门:搭建姿态检测模型并实时输出人体关节点3d坐标</a><time datetime="2022-04-23T07:49:34.475Z" title="Created 2022-04-23 15:49:34">2022-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/" title="编程修养"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编程修养"/></a><div class="content"><a class="title" href="/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/" title="编程修养">编程修养</a><time datetime="2022-04-23T07:38:10.494Z" title="Created 2022-04-23 15:38:10">2022-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/22/%E8%A1%8C%E4%B8%9A%E4%B8%87%E8%B1%A1/" title="行业万象：为什么互联网大厂一边裁员，又一边招人"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行业万象：为什么互联网大厂一边裁员，又一边招人"/></a><div class="content"><a class="title" href="/2022/04/22/%E8%A1%8C%E4%B8%9A%E4%B8%87%E8%B1%A1/" title="行业万象：为什么互联网大厂一边裁员，又一边招人">行业万象：为什么互联网大厂一边裁员，又一边招人</a><time datetime="2022-04-22T03:07:21.511Z" title="Created 2022-04-22 11:07:21">2022-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/21/C++%20Primer%20Plus%204/" title="C++ Learning 4"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Learning 4"/></a><div class="content"><a class="title" href="/2022/04/21/C++%20Primer%20Plus%204/" title="C++ Learning 4">C++ Learning 4</a><time datetime="2022-04-21T10:15:08.627Z" title="Created 2022-04-21 18:15:08">2022-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" title="Constructor"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Constructor"/></a><div class="content"><a class="title" href="/2022/04/18/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" title="Constructor">Constructor</a><time datetime="2022-04-18T09:28:45.575Z" title="Created 2022-04-18 17:28:45">2022-04-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>