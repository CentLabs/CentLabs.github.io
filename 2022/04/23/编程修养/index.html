<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>编程修养 | CentLabs</title><meta name="keywords" content="C++"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编程修养 什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。  好的程序员应该有以下几方面的素质  有专研精神，勤学善问、举一反三 积极向上的态度，有创造性思维 与人积极交流沟通的能力，有团队精神 谦虚谨慎，戒骄戒燥 写出的代码质量高。包括：代码的稳定、易读">
<meta property="og:type" content="article">
<meta property="og:title" content="编程修养">
<meta property="og:url" content="https://centlabs.github.io/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="编程修养 什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。  好的程序员应该有以下几方面的素质  有专研精神，勤学善问、举一反三 积极向上的态度，有创造性思维 与人积极交流沟通的能力，有团队精神 谦虚谨慎，戒骄戒燥 写出的代码质量高。包括：代码的稳定、易读">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-23T07:38:10.494Z">
<meta property="article:modified_time" content="2022-04-23T07:44:28.280Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编程修养',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-23 15:44:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编程修养</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-23T07:38:10.494Z" title="Created 2022-04-23 15:38:10">2022-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-23T07:44:28.280Z" title="Updated 2022-04-23 15:44:28">2022-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编程修养"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="编程修养"><a href="#编程修养" class="headerlink" title="编程修养"></a>编程修养</h3><hr>
<p>什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。</p>
<hr>
<p>好的程序员应该有以下几方面的素质</p>
<ol>
<li>有专研精神，勤学善问、举一反三</li>
<li>积极向上的态度，有创造性思维</li>
<li>与人积极交流沟通的能力，有团队精神</li>
<li>谦虚谨慎，戒骄戒燥</li>
<li>写出的代码质量高。包括：代码的稳定、易读、规范、易维护、专业。</li>
</ol>
<p>这些都是程序员的修养，这里我想谈谈”编程修养”，也就是上述中的第5点。</p>
<hr>
<p>我觉得，如果我要了解一个作者，我会看他所写的小说，如果我要了解一个画家，我会看他所画的图画，如果我要了解一个工人，我会看他所做出来的产品，同样，如果我要了解一个程序员，我想首先我最想看的就是他的程序代码，程序代码可以看出一个程序员的素质和修养，程序就像一个作品，有素质有修养的程序员的作品必然是一图精美的图画，一首美妙的歌曲，一本赏心悦目的小说。</p>
<hr>
<p>我看过许多程序，没有注释，没有缩进，胡乱命名的变量名，等等。</p>
<p>此类程序员，他们是在做创造性的工作吗？</p>
<p>不，完全就是在搞破坏，与其说是在编程，还不如说是在对源程序进行”<strong>加密</strong>“。而且他们编的程序所创造的价值，远远小于需要在上面进行维护的价值。</p>
<p>程序员应该有程序员的修养，那怕再累，再没时间，也要对自己的程序负责。我宁可要那种动作慢，技术一般，但有良好的写程序风格的程序员，也不要那种技术强、动作快的”搞破坏”的程序员。有句话叫”字如其人”，我想从程序上也能看出一个程序员的优劣。因为，程序是程序员的作品，作品的好坏直截关系到程序员的声誉和素质。而”修养”好的程序员一定能做出好的程序和软件。</p>
<p>有个成语叫”<strong>独具匠心</strong>“，意思是做什么都要做得很专业，很用心，如果你要做一个”匠”，也就是造诣高深的人，那么，从一件很简单的作品上就能看出你有没有”匠”的特性，我觉得做一个程序员不难，但要做一个”程序匠”就不简单了。编程序很简单，但编出有质量的程序就难了。</p>
<p>这里不讨论过深的技术，我只想在一些容易让人忽略的东西上说一说，虽然这些东西可能很细微，但如果你不注意这些细微之处的话，那么他将会极大的影响你的整个软件质量，以及整个软件程的实施，所谓”<strong>千里之堤，毁于蚁穴</strong>“。</p>
<p>“<strong>细微之处见真功</strong>“，真正能体现一个程序的功底恰恰在这些细微之处。</p>
<p>这就是程序员的–编程修养。我总结了在用C&#x2F;C++语言（主要是C语言）进行程序写作上的三十二个”修养”，通过这些，你可以写出质量高的程序，同时也会让看你程序的人渍渍称道，那些看过你程序的人一定会说：”这个人的编程修养不错”。 </p>
<hr>
<ol>
<li><strong>版权和版本</strong></li>
<li><strong>缩进、空格、换行、空行、对齐</strong></li>
<li><strong>程序注释</strong></li>
<li><strong>函数的<code>[in][out]</code>参数</strong></li>
<li><strong>对系统调用的返回进行判断</strong></li>
<li><strong>if 语句对出错的处理</strong></li>
<li><strong>头文件中的#ifndef</strong></li>
<li><strong>在堆上分配内存</strong></li>
<li><strong>变量的初始化</strong></li>
<li><strong>h和c文件的使用</strong></li>
<li><strong>出错信息的处理</strong></li>
<li><strong>常用函数和循环语句中的被计算量</strong></li>
<li><strong>函数名和变量名的命名</strong></li>
<li><strong>函数的传值和传指针</strong></li>
<li><strong>修改别人程序的修养</strong></li>
<li><strong>把相同或近乎相同的代码形成函数和宏</strong></li>
<li><strong>表达式中的括号</strong></li>
<li><strong>函数参数中的const</strong></li>
<li><strong>函数的参数个数</strong></li>
<li><strong>函数的返回类型，不要省略</strong></li>
<li><strong>goto语句的使用</strong></li>
<li><strong>宏的使用</strong></li>
<li><strong>static的使用</strong></li>
<li><strong>函数中的代码尺寸</strong></li>
<li><strong>typedef的使用</strong></li>
<li><strong>为常量声明宏</strong></li>
<li><strong>不要为宏定义加分号</strong></li>
<li><strong>||和&amp;&amp;的语句执行顺序</strong></li>
<li><strong>尽量用for而不是while做循环</strong></li>
<li><strong>请用sizeof类型而不是变量</strong></li>
<li><strong>不要忽略Warning</strong></li>
<li><strong>书写Debug版和Release版的程序</strong></li>
</ol>
<hr>
<h4 id="1、版权和版本"><a href="#1、版权和版本" class="headerlink" title="1、版权和版本"></a>1、版权和版本</h4><p>好的程序员会给自己的每个函数，每个文件，都注上版权和版本。</p>
<p>对于C&#x2F;C++的文件，文件头应该有类似这样的注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　 文件名：network.c</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　 文件描述：网络通讯函数集</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　 创建人： Cinnamoroll ,  2022年4月22日</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　 版本号：1.0</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　 修改记录：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">********************************************************************/</span></span><br></pre></td></tr></table></figure>

<p>而对于函数来说，应该也有类似于这样的注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*============================================================</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 函 数 名：XXX</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参　　数：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　　　　type name [IN] : descripts</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 功能描述:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*　　　　..............</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返 回 值：成功TRUE，失败FALSE</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 抛出异常：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 作　　者：Cinnamoroll 2022/4/22</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">============================================================*/</span></span><br></pre></td></tr></table></figure>

<p>这样的描述可以让人对一个函数，一个文件有一个总体的认识，对代码的易读性和易维护性有很大的好处。这是好的作品产生的开始。</p>
<h4 id="2、缩进、空格、换行、空行、对齐"><a href="#2、缩进、空格、换行、空行、对齐" class="headerlink" title="2、缩进、空格、换行、空行、对齐"></a>2、缩进、空格、换行、空行、对齐</h4><p>1） 缩进应该是每个程序都会做的，只要学过程序就应该知道这个，但是我仍然看过不缩进的程序，或是乱缩进的程序。缩进，这是不成文规矩，一个缩进一般是一个TAB键或是4个空格。（最好用TAB键）</p>
<p>2）空格。空格能给程序代来什么损失吗？没有，有效的利用空格可以让你的程序读进来更加赏心悦目。而不是一堆表达式挤在一起。看看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ha=(ha*<span class="number">128</span>+*key++)%tabPtr-&gt;size;</span><br><span class="line">ha = ( ha * <span class="number">128</span> + *key++ ) % tabPtr-&gt;size;</span><br></pre></td></tr></table></figure>

<p>有空格和没有空格的感觉不一样吧。<strong>一般来说，语句中要在各个操作符间加空格，函数调用时，要以各个参数间加空格</strong>。如下面这种加空格的和不加的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((hProc=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS,FALSE,pid))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ( hProc = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid) ) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）换行。不要把语句都写在一行上，这样很不好。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;<span class="keyword">if</span>((a[i]&lt;<span class="string">&#x27;0&#x27;</span>||a[i]&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;(a[i]&lt;<span class="string">&#x27;a&#x27;</span>||a[i]&gt;<span class="string">&#x27;z&#x27;</span>)) <span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种即无空格，又无换行的程序一眼看过去真难受，还是加上空格和换行吧。　　</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ( a[i] &lt; <span class="string">&#x27;0&#x27;</span> || a[i] &gt; <span class="string">&#x27;9&#x27;</span> ) &amp;&amp; ( a[i] &lt; <span class="string">&#x27;a&#x27;</span> || a[i] &gt; <span class="string">&#x27;z&#x27;</span> ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，<strong>函数参数多的时候，最好也换行</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateProcess</span>(</span><br><span class="line">　　　　　　　　　<span class="literal">NULL</span>,</span><br><span class="line">　　　　　　　　　cmdbuf,</span><br><span class="line">　　　　　　　　　<span class="literal">NULL</span>,</span><br><span class="line">　　　　　　　　　<span class="literal">NULL</span>,</span><br><span class="line">　　　　　　　　　bInhH,</span><br><span class="line">　　　　　　　　　dwCrtFlags,</span><br><span class="line">　　　　　　　　　envbuf,</span><br><span class="line">　　　　　　　　　<span class="literal">NULL</span>,</span><br><span class="line">　　　　　　　　　&amp;siStartInfo,</span><br><span class="line">　　　　　　　　　&amp;prInfo</span><br><span class="line">　　　　　　　　 );</span><br></pre></td></tr></table></figure>

<p>条件语句也应该在必要时换行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ch &gt;= <span class="string">&#x27;0&#x27;</span> || ch &lt;= <span class="string">&#x27;9&#x27;</span> ||</span><br><span class="line">     ch &gt;= <span class="string">&#x27;a&#x27;</span> || ch &lt;= <span class="string">&#x27;z&#x27;</span> ||</span><br><span class="line">     ch &gt;= <span class="string">&#x27;A&#x27;</span> || ch &lt;= <span class="string">&#x27;Z&#x27;</span> )</span><br></pre></td></tr></table></figure>

<p>4）空行。不要不加空行，空行可以区分不同的程序块，<strong>程序块间，最好加上空行</strong>。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess;</span><br><span class="line">PROCESS_T procInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* open the process handle */</span></span><br><span class="line"><span class="keyword">if</span>((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> LSE_MISC_SYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;procInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(procInfo));</span><br><span class="line"></span><br><span class="line">procInfo.idProc = pid;</span><br><span class="line">procInfo.hdProc = hProcess;</span><br><span class="line">procInfo.misc |= MSCAVA_PROC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>5）对齐。<strong>用TAB键对齐你的一些变量的声明或注释</strong>，一样会让你的程序美观一些。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_pt_man_t_</span> &#123;</span><br><span class="line">　　<span class="type">int</span>　　 numProc;　　<span class="comment">/* Number of processes　　　　　　　　 */</span></span><br><span class="line">　　<span class="type">int</span>　　 maxProc;　　<span class="comment">/* Max Number of processes　　　　　　 */</span></span><br><span class="line">　　<span class="type">int</span>　　 numEvnt;　　<span class="comment">/* Number of events　　　　　　　　　　*/</span></span><br><span class="line">　　<span class="type">int</span>　　 maxEvnt;　　<span class="comment">/* Max Number of events　　　　　　　　*/</span></span><br><span class="line">　　HANDLE* pHndEvnt;　 <span class="comment">/* Array of events　　　　　　　　　　 */</span></span><br><span class="line">　　DWORD　 timeout;　　<span class="comment">/* Time out interval　　　　　　　　　 */</span></span><br><span class="line">　　HANDLE　hPipe;　　　<span class="comment">/* Namedpipe　　　　　　　　　　　　　 */</span></span><br><span class="line">　　TCHAR　 usr[MAXUSR];<span class="comment">/* User name of the process　　　　　　*/</span></span><br><span class="line">　　<span class="type">int</span>　　 numMsg;　　 <span class="comment">/* Number of Message　　　　　　　　　 */</span></span><br><span class="line">　　<span class="type">int</span>　　 Msg[MAXMSG];<span class="comment">/* Space for intro process communicate */</span></span><br><span class="line">&#125; PT_MAN_T;</span><br></pre></td></tr></table></figure>

<p>好看的代码会让人的心情愉快，读起代码也就不累。工整、整洁的程序代码，通常更让人欢迎，也更让人称道。现在的硬盘空间这么大，不要让你的代码挤在一起，这样它们会抱怨你虐待它们的。好了，用”缩进、空格、换行、空行、对齐”装饰你的代码吧，让他们从没有秩序的土匪中变成一排排整齐有秩序的正规部队吧。</p>
<h4 id="3、程序注释"><a href="#3、程序注释" class="headerlink" title="3、程序注释"></a>3、程序注释</h4><p>养成写程序注释的习惯，这是每个程序员所必须要做的工作。</p>
<p>我看过那种几千行，却居然没有一行注释的程序。这就如同在公路上驾车却没有路标一样。用不了多久，连自己都不知道自己的意图了，还要花上几倍的时间才看明白，这种属实浪费别人和自己的时间。</p>
<p>是的，你也许会说，你会写注释，真的吗？注释的书写也能看出一个程序员的功底。</p>
<p>一般来说你需要至少写这些地方的注释：</p>
<ul>
<li>文件的注释</li>
<li>函数的注释</li>
<li>变量的注释</li>
<li>算法的注释</li>
<li>功能块的程序注释</li>
</ul>
<p>主要就是记录你这段程序是干什么的？你的意图是什么？你这个变量是用来做什么的？等等。 </p>
<p>不要以为注释好写，有一些算法是很难说或写出来的，只能意会，我承认有这种情况的时候，但你也要写出来，正好可以训练一下自己的表达能力。而表达能力正是那种闷头搞技术的技术人员最缺的，你有再高的技术，如果你表达能力不行，你的技术将不能得到充分的发挥。因为，这是一个团队的时代。</p>
<p>好了，说几个注释的技术细节：</p>
<p>1）对于行注释（”&#x2F;&#x2F;“）和块注释（”<code>/* */</code>“）择优选择。</p>
<p>2） 你也许会为块注释的不能嵌套而不爽，那么你可以用预编译来完成这个功能。使用”#if 0”和”#endif”括起来的代码，将不被编译，而且还可以嵌套。</p>
<h4 id="4、函数的-in-out-参数"><a href="#4、函数的-in-out-参数" class="headerlink" title="4、函数的[in][out]参数"></a>4、函数的<code>[in][out]</code>参数</h4><p>经常看到这样的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FuncName</span>(<span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">　　.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">GetUserName</span><span class="params">(<span class="keyword">struct</span> user* pUser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> pUser-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不！请不要这样做。</p>
<hr>
<p>你应该先判断一下传进来的那个指针是不是为空。如果传进来的指针为空的话，那么，你的一个大的系统就会因为这一个小的函数而崩溃。一种更好的技术是使用断言（assert），这里我就不多说这些技术细节了。当然，如果是在C++中，引用要比指针好得多，但你也需要对各个参数进行检查。</p>
<hr>
<p>写有参数的函数时，首要工作，就是要对传进来的所有参数进行合法性检查。而对于传出的参数也应该进行检查，这个动作当然应该在函数的外部，也就是说，调用完一个函数后，应该对其传出的值进行检查。</p>
<p>当然，检查会浪费一点时间，但为了整个系统不至于出现”非法操作”或是”Core Dump”的系统级的错误，多花这点时间还是很值得的。</p>
<h4 id="5、对系统调用的返回进行判断"><a href="#5、对系统调用的返回进行判断" class="headerlink" title="5、对系统调用的返回进行判断"></a>5、对系统调用的返回进行判断</h4><p>继续上一条，对于一些系统调用，比如打开文件，我经常看到，许多程序员对fopen返回的指针不做任何判断，就直接使用了。然后发现文件的内容怎么也读出不，或是怎么也写不进去。还是判断一下吧： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fp = <span class="built_in">fopen</span>(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( fp == <span class="literal">NULL</span> )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error: open file error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它还有许多啦，比如：socket返回的socket号，malloc返回的内存。<strong>请对这些系统调用返回的东西进行判断。</strong></p>
<h4 id="6、if-语句对出错的处理"><a href="#6、if-语句对出错的处理" class="headerlink" title="6、if 语句对出错的处理"></a>6、if 语句对出错的处理</h4><p>先看一段程序代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span> )&#123;</span><br><span class="line">    <span class="comment">/* 正常处理代码 */</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/* 输出错误信息 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error ......\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ( FALSE );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种结构很不好，特别是如果”正常处理代码”很长时，对于这种情况，最好不要用else。先判断错误，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span> )&#123;</span><br><span class="line">    <span class="comment">/* 输出错误信息 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error ......\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ( FALSE );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正常处理代码 */</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这样的结构，不是很清楚吗？突出了错误的条件，让别人在使用你的函数的时候，第一眼就能看到不合法的条件，于是就会更下意识的避免。</p>
<h4 id="7、头文件中的-ifndef"><a href="#7、头文件中的-ifndef" class="headerlink" title="7、头文件中的#ifndef"></a>7、头文件中的#ifndef</h4><p>千万不要忽略了头文件中的<code>#ifndef</code>，这是一个很关键的东西。比如你有两个C++文件，这两个C++文件都include了同一个头文件。而编译时，这两个C++文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。</p>
<p>还是把头文件的内容都放在<code>#ifndef</code>和<code>#endif</code>中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>　<span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>&lt;标识&gt;</code>在理论上来说可以是自由命名的，但每个头文件的这个”标识”都应该是唯一的。</p>
<p>标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的”.”也变成下划线，如：stdio.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDIO_H_</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>预编译有多很有用的功能。</p>
<h4 id="8、在堆上分配内存"><a href="#8、在堆上分配内存" class="headerlink" title="8、在堆上分配内存"></a>8、在堆上分配内存</h4><p>可能许多人对内存分配上的”栈 stack”和”堆 heap”还不是很明白。</p>
<p>包括一些科班出身的人也不明白这两个概念。我不想过多的说这两个东西。简单的来讲，&#x3D;&#x3D;stack上分配的内存系统自动释放，heap上分配的内存，系统不释放，哪怕程序退出，那一块内存还是在那里&#x3D;&#x3D;。<strong>stack一般是静态分配内存，heap一般是动态分配内存。</strong></p>
<p>由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己释放。用free释放，不然就是术语–”内存泄露”（或是”内存漏洞”）– Memory Leak。于是，系统的可分配内存会随malloc越来越少，直到系统崩溃。还是来看看”栈内存”和”堆内存”的差别吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈内存分配</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">AllocStrFromStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pstr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">return</span> pstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆内存分配</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">AllocStrFromHeap</span><span class="params">(<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *pstr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( len &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="type">char</span>* ) <span class="built_in">malloc</span>( len );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的<code>char*</code>什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！</p>
<p>在堆上分配内存很容易造成内存泄漏，这是C&#x2F;C++的最大的”克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。</p>
<p>记得有一个UNIX上的服务应用程序，大约有几百的C文件编译而成，运行测试良好，等使用时，每隔三个月系统就是down一次，搞得许多人焦头烂额，查不出问题所在。只好，每隔两个月人工手动重启系统一次。出现这种问题就是Memery Leak在做怪了，在C&#x2F;C++中这种问题总是会发生，所以你一定要小心。一个Rational的检测工作–Purify，可以帮你测试你的程序有没有内存泄漏。</p>
<p>做过许多C&#x2F;C++的工程的程序员，都会对malloc或是new有些感冒。当你什么时候在使用malloc和new时，有一种轻度的紧张和惶恐的感觉时，你就具备了这方面的修养了。</p>
<p>对于malloc和free的操作有以下规则：</p>
<ol>
<li>配对使用，有一个malloc，就应该有一个free。（C++中对应为 new 和 delete ）</li>
<li>尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</li>
<li>malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。</li>
</ol>
<p>　　</p>
<p>注：虽然现在的操作系统（如：UNIX和Win2k&#x2F;NT）都有进程内存跟踪机制，也就是如果你有没有释放的内存，操作系统会帮你释放。但操作系统依然不会释放你程序中所有产生了Memory Leak的内存，所以，最好还是你自己来做这个工作。（有的时候不知不觉就出现Memory Leak了，而且在几百万行的代码中找无异于海底捞针，Rational有一个工具叫Purify，可能很好的帮你检查程序中的 Memory Leak）</p>
<h4 id="9、变量的初始化"><a href="#9、变量的初始化" class="headerlink" title="9、变量的初始化"></a>9、变量的初始化</h4><p>接上一条，变量一定要被初始化再使用。C&#x2F;C++编译器在这个方面不会像JAVA一样帮你初始化，这一切都需要你自己来，如果你使用了没有初始化的变量，结果未知。好的程序员从来都会在使用变量前初始化变量的。如：</p>
<ol>
<li>对 malloc 分配的内存进行 memset 清零操作。（可以使用calloc分配一块全零的内存）</li>
<li>对一些栈上分配的 struct 或数组进行初始化。（最好也是清零）</li>
</ol>
<p>不过话又说回来了，初始化也会造成系统运行时间有一定的开销，所以，也不要对所有的变量做初始化，这个也没有意义。好的程序员知道哪些变量需要初始化，哪些则不需要。如：以下这种情况，则不需要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pstr;　<span class="comment">/* 一个字符串 */</span></span><br><span class="line">pstr = ( <span class="type">char</span>* ) <span class="built_in">malloc</span>( <span class="number">50</span> );</span><br><span class="line"><span class="keyword">if</span> ( pstr == <span class="literal">NULL</span> ) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">strcpy</span>( pstr, <span class="string">&quot;Hello Wrold&quot;</span> );</span><br></pre></td></tr></table></figure>

<p>但如果是下面一种情况，最好进行内存初始化。（指针是一个危险的东西，一定要初始化）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **pstr;　<span class="comment">/* 一个字符串数组 */</span></span><br><span class="line">pstr = ( <span class="type">char</span>** ) <span class="built_in">malloc</span>( <span class="number">50</span> );</span><br><span class="line"><span class="keyword">if</span> ( pstr == <span class="literal">NULL</span> ) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 让数组中的指针都指向NULL */</span></span><br><span class="line"><span class="built_in">memset</span>( pstr, <span class="number">0</span>, <span class="number">50</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>*) );</span><br></pre></td></tr></table></figure>

<p>而<strong>对于全局变量，和静态变量，一定要声明时就初始化</strong>。因为你不知道它第一次会在哪里被使用。所以使用前初始这些变量是比较不现实的，一定要在声明时就初始化它们。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Links *plnk = <span class="literal">NULL</span>;　<span class="comment">/* 对于全局变量plnk初始化为NULL */</span></span><br></pre></td></tr></table></figure>

<h4 id="10、h和c文件的使用"><a href="#10、h和c文件的使用" class="headerlink" title="10、h和c文件的使用"></a>10、h和c文件的使用</h4><p>H文件和C文件怎么用呢？一般来说，H文件中是declare（声明），C文件中是define（定义）。因为C文件要编译成库文件（Windows下是.obj&#x2F;.lib，UNIX下是.o&#x2F;.a），如果别人要使用你的函数，那么就要引用你的H文件，所以，&#x3D;&#x3D;H文件中一般是变量、宏定义、枚举、结构和函数接口的声明，就像一个接口说明文件一样&#x3D;&#x3D;。而&#x3D;&#x3D;C文件则是实现细节&#x3D;&#x3D;。</p>
<p><strong>H文件和C文件最大的用处就是声明和实现分开</strong>。这个特性应该是公认的了，但我仍然看到有些人喜欢把函数写在H文件中，这种习惯很不好。（如果是C++话，对于其模板函数，在VC中只有把实现和声明都写在一个文件中，因为VC不支持export关键字）。而且，如果在H文件中写上函数的实现，你还得在makefile中把头文件的依赖关系也加上去，这个就会让你的makefile很不规范。</p>
<p>最后，有一个最需要注意的地方就是：<strong>带初始化的全局变量不要放在H文件中！</strong></p>
<p>例如有一个处理错误信息的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* errmsg[] = &#123;</span><br><span class="line">    <span class="comment">/* 0 */</span>　　　 <span class="string">&quot;No error&quot;</span>,　　　　　　　　</span><br><span class="line">    <span class="comment">/* 1 */</span>　　　 <span class="string">&quot;Open file error&quot;</span>,　　　　</span><br><span class="line">    <span class="comment">/* 2 */</span>　　　 <span class="string">&quot;Failed in sending/receiving a message&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 3 */</span>　　　 <span class="string">&quot;Bad arguments&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 4 */</span>　　　 <span class="string">&quot;Memeroy is not enough&quot;</span>,</span><br><span class="line">    <span class="comment">/* 5 */</span>　　　 <span class="string">&quot;Service is down; try later&quot;</span>,</span><br><span class="line">    <span class="comment">/* 6 */</span>　　　 <span class="string">&quot;Unknow information&quot;</span>,</span><br><span class="line">    <span class="comment">/* 7 */</span>　　　 <span class="string">&quot;A socket operation has failed&quot;</span>,</span><br><span class="line">    <span class="comment">/* 8 */</span>　　　 <span class="string">&quot;Permission denied&quot;</span>,</span><br><span class="line">    <span class="comment">/* 9 */</span>　　　 <span class="string">&quot;Bad configuration file format&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 10 */</span>　　　<span class="string">&quot;Communication time out&quot;</span>,</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请不要把这个东西放在头文件中，因为如果你的这个头文件被5个函数库（.lib或是.a）所用到，于是他就被链接在这5个.lib或.a中，而如果你的一个程序用到了这5个函数库中的函数，并且这些函数都用到了这个出错信息数组。那么这份信息将有5个副本存在于你的执行文件中。如果你的这个errmsg很大的话，而且你用到的函数库更多的话，你的执行文件也会变得很大。</p>
<p>正确的写法应该把它写到C文件中，然后在各个需要用到errmsg的C文件头上加上 extern char* errmsg[]; 的外部声明，让编译器在链接时才去管他，这样一来，就只会有一个errmsg存在于执行文件中，而且，这样做很利于封装。</p>
<p>我曾遇到过的最疯狂的事，就是在我的目标文件中，这个errmsg一共有112个副本，执行文件有8M左右。当我把errmsg放到C文件中，并为一千多个C文件加上了extern的声明后，所有的函数库文件尺寸都下降了20%左右，而我的执行文件只有5M了。一下子少了3M啊。</p>
<hr>
<p>〔 备注 〕有朋友对我说，这个只是一个特例，因为，如果errmsg在执行文件中存在多个副本时，可以加快程序运行速度，理由是errmsg的多个副本会让系统的内存换页降低，达到效率提升。像我们这里所说的errmsg只有一份，当某函数要用errmsg时，如果内存隔得比较远，会产生换页，反而效率不高。</p>
<p>这个说法不无道理，但是一般而言，对于一个比较大的系统，errmsg是比较大的，所以产生副本导致执行文件尺寸变大，不仅增加了系统装载时间，也会让一个程序在内存中占更多的页面。而对于errmsg这样数据，一般来说，在系统运行时不会经常用到，所以还是产生的内存换页也就不算频繁。权衡之下，还是只有一份errmsg的效率高。即便是像logmsg这样频繁使用的的数据，操作系统的内存调度算法会让这样的频繁使用的页面常驻于内存，所以也就不会出现内存换页问题了。</p>
<hr>
<h4 id="11、出错信息的处理"><a href="#11、出错信息的处理" class="headerlink" title="11、出错信息的处理"></a>11、出错信息的处理</h4><p>你会处理出错信息吗？哦，它并不是简单的输出。看下面的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( p == <span class="literal">NULL</span> )&#123;</span><br><span class="line">	<span class="built_in">printf</span> ( <span class="string">&quot;ERR: The pointer is NULL\n&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种编程很不利于维护和管理，出错信息或是提示信息，应该统一处理，而不是像上面这样，写成一个”硬编码”。第10条对这方面的处理做了一部分说明。如果要管理错误信息，那就要有以下的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明出错代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_NO_ERROR　　0　<span class="comment">/* No error　　　　　　　　 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_OPEN_FILE　 1　<span class="comment">/* Open file error　　　　　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_SEND_MESG　 2　<span class="comment">/* sending a message error　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_BAD_ARGS　　3　<span class="comment">/* Bad arguments　　　　　　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_MEM_NONE　　4　<span class="comment">/* Memeroy is not enough　　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_SERV_DOWN　 5　<span class="comment">/* Service down try later　 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_UNKNOW_INFO 6　<span class="comment">/* Unknow information　　　 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_SOCKET_ERR　7　<span class="comment">/* Socket operation failed　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_PERMISSION　8　<span class="comment">/* Permission denied　　　　*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_BAD_FORMAT　9　<span class="comment">/* Bad configuration file　 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　　 ERR_TIME_OUT　 10　<span class="comment">/* Communication time out　 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明出错信息 */</span></span><br><span class="line"><span class="type">char</span>* errmsg[] = &#123;</span><br><span class="line">    <span class="comment">/* 0 */</span>　　　 <span class="string">&quot;No error&quot;</span>,　　　　　　　　</span><br><span class="line">    <span class="comment">/* 1 */</span>　　　 <span class="string">&quot;Open file error&quot;</span>,　　　　</span><br><span class="line">    <span class="comment">/* 2 */</span>　　　 <span class="string">&quot;Failed in sending/receiving a message&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 3 */</span>　　　 <span class="string">&quot;Bad arguments&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 4 */</span>　　　 <span class="string">&quot;Memeroy is not enough&quot;</span>,</span><br><span class="line">    <span class="comment">/* 5 */</span>　　　 <span class="string">&quot;Service is down; try later&quot;</span>,</span><br><span class="line">    <span class="comment">/* 6 */</span>　　　 <span class="string">&quot;Unknow information&quot;</span>,</span><br><span class="line">    <span class="comment">/* 7 */</span>　　　 <span class="string">&quot;A socket operation has failed&quot;</span>,</span><br><span class="line">    <span class="comment">/* 8 */</span>　　　 <span class="string">&quot;Permission denied&quot;</span>,</span><br><span class="line">    <span class="comment">/* 9 */</span>　　　 <span class="string">&quot;Bad configuration file format&quot;</span>,　</span><br><span class="line">    <span class="comment">/* 10 */</span>　　　<span class="string">&quot;Communication time out&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明错误代码全局变量 */</span></span><br><span class="line"><span class="type">long</span> errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印出错信息函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">( <span class="type">char</span>* info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( info )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, info, errmsg[errno] );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, errmsg[errno] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个基本上是ANSI的错误处理实现细节了，于是当你程序中有错误时你就可以这样处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckPermission</span><span class="params">( <span class="type">char</span>* userName )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcpy</span>(userName, <span class="string">&quot;root&quot;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">        errno = ERR_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">return</span> (FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (! <span class="built_in">CheckPermission</span>( username ) )&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;main()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个即有共性，也有个性的错误信息处理，这样做有利同种错误出一样的信息，统一用户界面，而不会因为文件打开失败，A程序员出一个信息，B程序员又出一个信息。而且这样做，非常容易维护。代码也易读。</p>
<p>当然，物极必反，也没有必要把所有的输出都放到errmsg中，抽取比较重要的出错信息或是提示信息是其关键，但即使这样，这也包括了大多数的信息。 </p>
<h4 id="12、常用函数和循环语句中的被计算量"><a href="#12、常用函数和循环语句中的被计算量" class="headerlink" title="12、常用函数和循环语句中的被计算量"></a>12、常用函数和循环语句中的被计算量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ )&#123;</span><br><span class="line">	GetLocalHostName( hostname );</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetLocalHostName的意思是取得当前计算机名，在循环体中，它会被调用1000次啊。这是多么的没有效率的事啊。应该把这个函数拿到循环体外，这样只调用一次，效率得到了很大的提高。虽然，我们的编译器会进行优化，会把循环体内的不变的东西拿到循环外面，但是，你相信所有编译器会知道哪些是不变的吗？我觉得编译器不可靠。最好还是自己动手吧。</p>
<p>同样，对于常用函数中的不变量，如： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GetLocalHostName(<span class="type">char</span>* name)</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">char</span> funcName[] = <span class="string">&quot;GetLocalHostName&quot;</span>;</span><br><span class="line">　　</span><br><span class="line">　　sys_log( <span class="string">&quot;%s begin......&quot;</span>, funcName );</span><br><span class="line">　　...</span><br><span class="line">　　sys_log( <span class="string">&quot;%s end......&quot;</span>, funcName );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这是一个经常调用的函数，每次调用时都要对funcName进行分配内存，这个开销很大啊。<strong>把这个变量声明成static吧，当函数再次被调用时，就会省去了分配内存的开销，执行效率也很好。</strong></p>
<h4 id="13、函数名和变量名的命名"><a href="#13、函数名和变量名的命名" class="headerlink" title="13、函数名和变量名的命名"></a>13、函数名和变量名的命名</h4><p>许多程序对变量名和函数名的取名很草率，特别是变量名，什么a,b,c,aa,bb,cc，还有什么flag1,flag2, cnt1, cnt2，这同样是一种没有”修养”的行为。即便加上好的注释。好的变量名或是函数名，我认为应该有以下的规则：</p>
<ul>
<li>直观并且可以拼读，可望文知意，不必”解码”。</li>
<li>名字的长度应该即要最短的长度，也要能最大限度的表达其含义。</li>
<li>不要全部大写，也不要全部小写，应该大小写都有，如：GetLocalHostName 或是 UserAccount。</li>
<li>可以简写，但简写得要让人明白，如：ErrorCode -&gt; ErrCode,　ServerListener -&gt; ServLisner，UserAccount -&gt; UsrAcct 等。</li>
<li>为了避免全局函数和变量名字冲突，可以加上一些前缀，一般以模块简称做为前缀。</li>
<li>全局变量统一加一个前缀或是后缀，让人一看到这个变量就知道是全局的。</li>
<li>用匈牙利命名法命名函数参数，局部变量。但还是要坚持”望文生意”的原则。</li>
<li>与标准库（如：STL）或开发库（如：MFC）的命名风格保持一致。</li>
</ul>
<h4 id="14、函数的传值和传指针"><a href="#14、函数的传值和传指针" class="headerlink" title="14、函数的传值和传指针"></a>14、函数的传值和传指针</h4><p>向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针指向内存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因为传值是只是内存拷贝。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetVersion</span><span class="params">(<span class="type">char</span>* pStr)</span></span><br><span class="line">&#123;</span><br><span class="line">　　pStr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">　　<span class="built_in">strcpy</span> ( pStr, <span class="string">&quot;2.0&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">char</span>* ver = <span class="literal">NULL</span>;</span><br><span class="line">　　GetVersion ( ver );</span><br><span class="line">　　...</span><br><span class="line">　　...</span><br><span class="line">　　<span class="built_in">free</span> ( ver );</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针ver分配空间，但这种方法根本没有什么作用，原因就是——这是传值，不是传指针。你或许会和我争论，我分明传的时指针啊？再仔细看看，其实，你传的指针其实是在传值。</p>
<h4 id="15、修改别人程序的修养"><a href="#15、修改别人程序的修养" class="headerlink" title="15、修改别人程序的修养"></a>15、修改别人程序的修养</h4><p>当你维护别人的程序时，<strong>请不要非常主观臆断的把已有的程序删除或是修改</strong>。</p>
<p>我经常看到有的程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序，<strong>如果你觉得别人的程序有所不妥，请注释掉</strong>，然后添加自己的处理程序，毕竟，你不可能100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的程序员所应该做的。</p>
<p>如下所示，这就是一种比较好的修改方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">　　 * ----- commented by haoel 2021/04/22 ------</span></span><br><span class="line"><span class="comment">　　 *</span></span><br><span class="line"><span class="comment">　　 *　 char* p = ( char* ) malloc( 10 );</span></span><br><span class="line"><span class="comment">　　 *　 memset( p, 0, 10 );</span></span><br><span class="line"><span class="comment">　　 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------ Added by haoel　 2022/04/22 ----- */</span></span><br><span class="line"><span class="type">char</span>* p = ( <span class="type">char</span>* )<span class="built_in">calloc</span>( <span class="number">10</span>, <span class="keyword">sizeof</span> <span class="type">char</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------------------------------- */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代码更改的动作和意图，而且这也是对原作者的一种尊敬。</p>
<p><strong>以”注释 - 添加”方式修改别人的程序，要好于直接删除别人的程序。</strong></p>
<h4 id="16、把相同或近乎相同的代码形成函数和宏"><a href="#16、把相同或近乎相同的代码形成函数和宏" class="headerlink" title="16、把相同或近乎相同的代码形成函数和宏"></a>16、把相同或近乎相同的代码形成函数和宏</h4><p>有人说，最好的程序员，就是最喜欢”偷懒”的程序，其中不无道理。</p>
<p>如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。</p>
<p>千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改好几处地方，这种会给维护带来巨大的麻烦，所以，做到”一改百改”，还是要形成函数或是宏。</p>
<h4 id="17、表达式中的括号"><a href="#17、表达式中的括号" class="headerlink" title="17、表达式中的括号"></a>17、表达式中的括号</h4><p>如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避免这种”误解”，还有让自己的程序更为清淅，还是加上括号吧。</p>
<p>比如，对一个结构的成员取地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetUserAge( &amp;( UserInfo-&gt;age ) );</span><br></pre></td></tr></table></figure>

<p>虽然，<code>&amp;UserInfo-&gt;age</code>中，-&gt;操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的代码是什么意思。</p>
<p>再比如，一个很长的条件判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( ch[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> || ch[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span> ) &amp;&amp;</span><br><span class="line">　　 	( ch[<span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span> || ch[<span class="number">1</span>] &lt;= <span class="string">&#x27;z&#x27;</span> ) &amp;&amp;</span><br><span class="line">　　 	( ch[<span class="number">2</span>] &gt;= <span class="string">&#x27;A&#x27;</span> || ch[<span class="number">2</span>] &lt;= <span class="string">&#x27;Z&#x27;</span> )　　)</span><br></pre></td></tr></table></figure>

<p>括号，再加上空格和换行，你的代码是不是很容易读懂了？　</p>
<h4 id="18、函数参数中的const"><a href="#18、函数参数中的const" class="headerlink" title="18、函数参数中的const"></a>18、函数参数中的const</h4><p>对于一些函数中的指针参数，&#x3D;&#x3D;如果在函数中只读，请将其用const修饰&#x3D;&#x3D;，这样，别人一读到你的函数接口时，就会知道你的意图是这个参数是[in]，如果没有const时，参数表示[in&#x2F;out]，注意函数接口中的const使用，利于程序的维护和避免犯一些错误。</p>
<p>虽然，const修饰的指针，如：<code>const char* p</code>，在C中一点用也没有，因为不管你的声明是不是const，指针的内容照样能改，因为编译器会强制转换，但是加上这样一个说明，有利于程序的阅读和编译。因为在C中，修改一个const指针所指向的内存时，会报一个Warning。这会引起程序员的注意。</p>
<p>C++中对const定义的就很严格了，所以&#x3D;&#x3D;C++中要多多的使用const&#x3D;&#x3D;，const的成员函数，const的变量，这样会对让你的代码和你的程序更加完整和易读。（关于C++的const我就不多说了）</p>
<h4 id="19、函数的参数个数（多了请用结构）"><a href="#19、函数的参数个数（多了请用结构）" class="headerlink" title="19、函数的参数个数（多了请用结构）"></a>19、函数的参数个数（多了请用结构）</h4><p>函数的参数个数最好不要太多，一般来说6个左右就可以了，众多的函数参数会让读代码的人一眼看上去就很头昏，而且也不利于维护。&#x3D;&#x3D;如果参数众多，还请使用结构来传递参数&#x3D;&#x3D;。这样做有利于数据的封装和程序的简洁性。</p>
<p>也利于使用函数的人，因为如果你的函数个数很多，比如12个，调用者很容易搞错参数的顺序和个数，而使用结构struct来传递参数，就可以不管参数的顺序。</p>
<p>而且，函数很容易被修改，如果需要给函数增加参数，不需要更改函数接口，只需更改结构体和函数内部处理，而对于调用函数的程序来说，这个动作是透明的。</p>
<h4 id="20、函数的返回类型，不要省略"><a href="#20、函数的返回类型，不要省略" class="headerlink" title="20、函数的返回类型，不要省略"></a>20、函数的返回类型，不要省略</h4><p>看到很多程序员写函数时，在函数的返回类型方面不太注意。<strong>如果一个函数没有返回值，也请在函数前面加上void的修饰符</strong>。而有的程序员偷懒，在返回int的函数则什么都不修饰（因为如果不修饰，则默认返回int），这种习惯很不好，还是为了原代码的易读性，加上int吧。</p>
<p>所以函数的返回值类型，请不要省略。</p>
<p>另外，对于void的函数，我们往往会忘了return，由于某些C&#x2F;C++的编译器比较敏感，会报一些警告，所以<strong>即使是void的函数，我们在内部最好也要加上return的语句，这有助于代码的编译。</strong></p>
<h4 id="21、goto语句的使用"><a href="#21、goto语句的使用" class="headerlink" title="21、goto语句的使用"></a>21、goto语句的使用</h4><p>N年前，软件开发的一代宗师——迪杰斯特拉(Dijkstra)说过：”goto statment is harmful !!”，并建议取消goto语句。因为goto语句不利于程序代码的维护性。</p>
<p>这里我也强烈建议不要使用goto语句，除非下面的这种情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FREE(p) <span class="keyword">if</span>(p) &#123; \</span></span><br><span class="line"><span class="meta">　　　　　　　　　　　　free(p); \</span></span><br><span class="line"><span class="meta">　　　　　　　　　　　　p = NULL; \</span></span><br><span class="line"><span class="meta">　　　　　　　　　　&#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *fname=<span class="literal">NULL</span>, *lname=<span class="literal">NULL</span>, *mname=<span class="literal">NULL</span>;</span><br><span class="line">    fname = ( <span class="type">char</span>* ) <span class="built_in">calloc</span> ( <span class="number">20</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">    <span class="keyword">if</span> ( fname == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="keyword">goto</span> ErrHandle;</span><br><span class="line">    &#125;</span><br><span class="line">    lname = ( <span class="type">char</span>* ) <span class="built_in">calloc</span> ( <span class="number">20</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">    <span class="keyword">if</span> ( lname == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="keyword">goto</span> ErrHandle;</span><br><span class="line">    &#125;</span><br><span class="line">    mname = ( <span class="type">char</span>* ) <span class="built_in">calloc</span> ( <span class="number">20</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">    <span class="keyword">if</span> ( mname == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="keyword">goto</span> ErrHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ErrHandle:</span><br><span class="line">    FREE(fname);</span><br><span class="line">    FREE(lname);</span><br><span class="line">    FREE(mname);</span><br><span class="line">    ReportError(ERR_NO_MEMOEY);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也只有在这种情况下，goto语句会让你的程序更易读，更容易维护。（在用嵌C来对数据库设置游标操作时，或是对数据库建立链接时，也会遇到这种结构）</p>
<h4 id="22、宏的使用"><a href="#22、宏的使用" class="headerlink" title="22、宏的使用"></a>22、宏的使用</h4><p>很多程序员不知道C中的”宏”到底是什么意思？特别是当宏有参数的时候，经常把宏和函数混淆。</p>
<p>在这里我还是先讲讲”宏”，<strong>宏只是一种定义</strong>，它定义了一个语句块，当程序编译时，编译器首先要执行一个”替换”源程序的动作，把宏引用的地方替换成宏定义的语句块，就像文本文件替换一样。这个动作术语叫”宏的展开”。</p>
<p>使用宏是比较”危险”的，因为你不知道宏展开后会是什么一个样子。例如下面这个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>　MAX(a, b) a&gt;b?a:b</span></span><br></pre></td></tr></table></figure>

<p>当我们这样使用宏时，没有什么问题： MAX( num1, num2 )； 因为宏展开后变成 <code>num1&gt;num2?num1:num2；</code>。但是，如果是这样调用的，<code>MAX( 17+32, 25+21 );</code> 呢，编译时出现错误，原因是，宏展开后变成：</p>
<p><code>17+32&gt;25+21?17+32:25+21</code>，哇，这是什么啊？</p>
<p>所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>　MAX( (a), (b) )  (a)&gt;(b)?(a):(b)</span></span><br></pre></td></tr></table></figure>

<p>即使是这样，也不能保证这个宏也还是有Bug，因为如果我这样调用 <code>MAX(i++, j++);</code> ，经过这个宏以后，i 和 j 都被累加了两次，这绝不是我们想要的。</p>
<p>所以，在宏的使用上还是要谨慎考虑，因为宏展开的结果是很难让人预料的。虽然，宏的执行很快（因为没有函数调用的开销），但宏会让源代码膨胀，使目标文件尺寸变大，（如：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得更快（因为执行文件变大，运行时系统换页频繁）。</p>
<p><strong>因此，在决定使用函数，还是用宏时得要小心。</strong></p>
<h4 id="23、static的使用"><a href="#23、static的使用" class="headerlink" title="23、static的使用"></a>23、static的使用</h4><p>static关键字，表示了”静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">getConsumerName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">　　</span><br><span class="line">　　....</span><br><span class="line">　　cnt++;</span><br><span class="line">　　....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入函数，都不为static分配了，而直接使用上一次的值。 </p>
<p><strong>对于一些被经常调用的函数内的常量，最好也声明成static</strong>（参见第12条）</p>
<p>但static的最多的用处却不在这里，其最大的作用的控制访问，在C中如果一个函数或是一个全局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链接时错误。这个特性可以用于数据和程序保密。</p>
<h4 id="24、函数中的代码尺寸"><a href="#24、函数中的代码尺寸" class="headerlink" title="24、函数中的代码尺寸"></a>24、函数中的代码尺寸</h4><p>一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个函数。</p>
<p>另外，函数一般是完成一个特定的功能，千万忌讳在一个函数中做许多件不同的事。函数的功能越单一越好，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。</p>
<p>虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更好的可维护性和代码重用性，是很值得的一件事。</p>
<h4 id="25、typedef的使用"><a href="#25、typedef的使用" class="headerlink" title="25、typedef的使用"></a>25、typedef的使用</h4><p><strong>typedef是一个给类型起别名的关键字</strong>。它对于代码的维护会有很好的作用。比如C中没有bool，于是在一个软件中，一些程序员使用int，一些程序员使用short，会比较混乱，最好就是用一个typedef来定义，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BOOL; <span class="comment">//定义BOOL类型</span></span><br></pre></td></tr></table></figure>

<p>一般来说，一个C的工程中一定要做一些这方面的工作，因为你会涉及到<strong>跨平台</strong>，不同的平台会有不同的字长，所以利用预编译和typedef可以让你最有效的维护你的代码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SOLARIS2_5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">boolean_t</span> BOOL_T;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> BOOL_T;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> INT16_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> UINT16_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT32_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UINT32_T;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="keyword">typedef</span> _int64 INT64_T;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> INT64_T;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> FLOAT32_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* STRING_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE_T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">time_t</span> TIME_T;</span><br><span class="line"><span class="keyword">typedef</span> INT32_T PID_T;</span><br></pre></td></tr></table></figure>

<p>使用typedef的其它规范是，<strong>在结构和函数指针时，也最好用typedef</strong>，这也有利于程序的易读和可维护性。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hostinfo</span> &#123;</span></span><br><span class="line">    HOSTID_T　 host;</span><br><span class="line">    INT32_T　　hostId;</span><br><span class="line">    STRING_T　 hostType;</span><br><span class="line">    STRING_T　 hostModel;</span><br><span class="line">    FLOAT32_T　cpuFactor;</span><br><span class="line">    INT32_T　　numCPUs;</span><br><span class="line">    INT32_T　　nDisks;</span><br><span class="line">    INT32_T　　memory;</span><br><span class="line">    INT32_T　　swap;</span><br><span class="line">&#125; HostInfo;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">INT32_T</span> <span class="params">(*RsrcReqHandler)</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *info,</span></span><br><span class="line"><span class="params">    JobArray *jobs,</span></span><br><span class="line"><span class="params">    AllocInfo *allocInfo,</span></span><br><span class="line"><span class="params">    AllocList *allocList</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>C++中这样也是很让人易读的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> CArray HostInfoArray;</span><br></pre></td></tr></table></figure>

<p>于是，当我们用其定义变量时，会显得十分易读。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HostInfo* phinfo;</span><br><span class="line">RsrcReqHandler* pRsrcHand;</span><br></pre></td></tr></table></figure>

<p>这种方式的易读性，在函数的参数中十分明显。</p>
<p>关键是在程序中使用typedef后，几乎所有的程序的类型声明都显得那么简洁和清淅，而且易于维护，这才是typedef的关键。</p>
<h4 id="26、为常量声明宏"><a href="#26、为常量声明宏" class="headerlink" title="26、为常量声明宏"></a>26、为常量声明宏</h4><p>**最好不要在程序中出现数字式的”硬编码”**，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> user[<span class="number">120</span>];</span><br></pre></td></tr></table></figure>

<p>为这个120声明一个宏吧。<strong>为所有出现在程序中的这样的常量都声明一个宏吧</strong>。比如TimeOut的时间，最大的用户数量，还有其它，只要是常量就应该声明成宏。如果，突然在程序中出现下面一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">120</span>; i++)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>120是什么？为什么会是120？这种”硬编码”不仅让程序很读，而且也让程序很不好维护，如果要改变这个数字，得同时对所有程序中这个120都要做修改，这对修改程序的人来说是一个很大的痛苦。所以还是把常量声明成宏，这样，一改百改，而且也很利于程序阅读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_USR_CNT 120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX_USR_CNT; i++)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就很容易了解这段程序的意图了。</p>
<p>有的程序员喜欢为这种变量声明全局变量，其实，全局变量应该尽量的少用，全局变量不利于封装，也不利于维护，而且对程序执行空间有一定的开销，一不小心就造成系统换页，造成程序执行速度效率等问题。所以<strong>声明成宏，既可以免去全局变量的开销，也会有速度上的优势。</strong></p>
<h4 id="27、不要为宏定义加分号"><a href="#27、不要为宏定义加分号" class="headerlink" title="27、不要为宏定义加分号"></a>27、不要为宏定义加分号</h4><p>有许多程序员不知道在宏定义时是否要加分号，有时，他们以为宏是一条语句，应该要加分号，这就错了。当你知道了宏的原理，你会赞同我为会么不要为宏定义加分号的。看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 1024;</span></span><br></pre></td></tr></table></figure>

<p>这是一个有分号的宏，如果我们这样使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half = MAXNUM/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( num &lt; MAXNUM )</span><br></pre></td></tr></table></figure>

<p>等等，都会造成程序的编译错误，因为，当宏展开后，他会是这个样子的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half = <span class="number">1024</span>;/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( num &lt; <span class="number">1024</span>; )</span><br></pre></td></tr></table></figure>

<p>是的，分号也被展进去了，所以造成了程序的错误。请相信我，有时候，一个分号会让你的程序出现成百个错误。所以还是不要为宏加最后一个分号，哪怕是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LINE <span class="string">&quot;=================================&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_LINE　printf(LINE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_NLINE(n)　while ( n-- &gt;0 ) &#123; PRINT_LINE; &#125;</span></span><br></pre></td></tr></table></figure>

<p>都不要在最后加上分号，当我们在程序中使用时，为之加上分号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p = LINE;</span><br><span class="line">	PRINT_LINE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一点非常符合习惯，而且，如果忘加了分号，编译器给出的错误提示，也会让我们很容易看懂的</p>
<h4 id="28、-和-amp-amp-的语句执行顺序"><a href="#28、-和-amp-amp-的语句执行顺序" class="headerlink" title="28、||和&amp;&amp;的语句执行顺序"></a>28、||和&amp;&amp;的语句执行顺序</h4><p>条件语句中的这两个”与”和”或”操作符一定要小心，它们的表现可能和你想像的不一样，这里条件语句中的有些行为需要和说一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express1 || express2</span><br></pre></td></tr></table></figure>

<p>先执行表达式express1如果为”真”，express2将不被执行；express2仅在express1为”假”时才被执行。因为第一个表达式为真了，整个表达式都为真，所以没有必要再去执行第二个表达式了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express1 &amp;&amp; express2</span><br></pre></td></tr></table></figure>

<p>先执行表达式express1如果为”假”，express2将不被执行，express2仅在express1为”真”时才被执行。因为第一个表达式为假了，整个表达式都为假了，所以没有必要再去执行第二个表达式了。</p>
<p>于是，他并不是你所想像的所有的表达式都会去执行，这点一定要明白，不然你的程序会出现一些莫明的运行时错误。</p>
<p>例如，下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sum &gt; <span class="number">100</span> &amp;&amp;  ( fp=fopen( filename,<span class="string">&quot;a&quot;</span> ) ) != <span class="literal">NULL</span> )　 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Warring: it beyond one hundred\n&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>( fp, <span class="string">&quot; sum is %id \n&quot;</span>, sum );</span><br><span class="line">fclose( fp );</span><br></pre></td></tr></table></figure>

<p>本来的意图是，如果sum &gt; 100 ，向文件中写一条出错信息，为了方便，把两个条件判断写在一起，于是，如果sum&lt;&#x3D;100时，打开文件的操作将不会做，最后，fprintf和fclose就会发现未知的结果。</p>
<p>再比如，如果我想判断一个字符是不是有内容，我得判断这个字符串指针是不为空（NULL）并且其内容不能为空（Empty），一个是空指针，一个是空内容。我也许会这样写： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( p != <span class="literal">NULL</span> ) &amp;&amp; ( <span class="built_in">strlen</span>(p) != <span class="number">0</span> ))</span><br></pre></td></tr></table></figure>

<p>于是，如果p为NULL，那么strlen(p)就不会被执行，于是，strlen也就不会因为一个空指针而”非法操作”或是一个”Core Dump”了。</p>
<p>记住一点，条件语句中，并非所有的语句都会执行，当你的条件语句非常多时，这点要尤其注意。</p>
<h4 id="29、尽量用for而不是while做循环"><a href="#29、尽量用for而不是while做循环" class="headerlink" title="29、尽量用for而不是while做循环"></a>29、尽量用for而不是while做循环</h4><p>基本上来说，<strong>for可以完成while的功能，我是建议尽量使用for语句，而不要使用while语句</strong>，特别是当循环体很大时，for的优点一下就体现出来了。</p>
<p>因为在for中，循环的初始、结束条件、循环的推进，都在一起，一眼看上去就知道这是一个什么样的循环。刚出学校的程序一般对于链接喜欢这样来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( p )&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当while的语句块变大后，你的程序将很难读，用for就好得多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( p = pHead;　p; p=p-&gt;next )&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一眼就知道这个循环的开始条件，结束条件，和循环的推进。大约就能明白这个循环要做个什么事？而且，程序维护进来很容易，不必像while一样，在一个编辑器中上上下下的捣腾。</p>
<h4 id="30、请sizeof类型而不是变量"><a href="#30、请sizeof类型而不是变量" class="headerlink" title="30、请sizeof类型而不是变量"></a>30、请sizeof类型而不是变量</h4><p>许多程序员在使用sizeof中，喜欢sizeof变量名，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score[<span class="number">100</span>];</span><br><span class="line"><span class="type">char</span> filename[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserInfo</span> <span class="title">usr</span>[100];</span></span><br></pre></td></tr></table></figure>

<p>在sizeof这三个的变量名时，都会返回正确的结果，于是许多程序员就开始sizeof变量名。这个习惯虽然没有什么不好，但还是建议用sizeof类型。</p>
<p>我看到过这个的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pScore = (<span class="type">int</span>*) <span class="built_in">malloc</span>( SUBJECT_CNT );</span><br><span class="line"><span class="built_in">memset</span>( pScore, <span class="number">0</span>, <span class="keyword">sizeof</span>(pScore) );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此时，sizeof(pScore)返回的就是4（指针的长度），不会是整个数组，于是，memset就不能对这块内存进行初始化。为了程序的易读和易维护，强烈建议使用类型而不是变量，如：</p>
<ul>
<li><p>对于score：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>　 <span class="comment">/* 100个int */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于filename：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">20</span>　 <span class="comment">/* 20个char */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于usr：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> UserInfo) * <span class="number">100</span>　 <span class="comment">/* 100个UserInfo */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样的代码是不是很易读？一眼看上去就知道什么意思了。</p>
<p>另外一点，sizeof一般用于分配内存，这个特性特别在多维数组时，就能体现出其优点了。</p>
<p>如，给一个字符串数组分配内存，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 分配一个有20个字符串，</span></span><br><span class="line"><span class="comment">* 每个字符串长100的内存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 错误的分配方法 */</span></span><br><span class="line">p = (<span class="type">char</span>**)<span class="built_in">calloc</span>( <span class="number">20</span>*<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) );			</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 正确的分配方法 */</span></span><br><span class="line">p = (<span class="type">char</span>**) <span class="built_in">calloc</span> ( <span class="number">20</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*) );</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">　　<span class="comment">/*p = (char*) calloc ( 100, sizeof(char) );*/</span></span><br><span class="line">　　p[i] = (<span class="type">char</span>*) <span class="built_in">calloc</span> ( <span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了代码的易读，省去了一些判断，请注意这两种分配的方法，有本质上的差别。</p>
<h4 id="31、不要忽略Warning"><a href="#31、不要忽略Warning" class="headerlink" title="31、不要忽略Warning"></a>31、不要忽略Warning</h4><p>对于一些编译时的警告信息，请不要忽视它们。虽然，这些Warning不会妨碍目标代码的生成，但这并不意味着你的程序就是好的。毕竟，并不是编译成功的程序才是正确的，编译成功只是万里长征的第一步，后面还有大风大浪在等着你。从编译程序开始，不但要改正每个error，还要修正每个warning。</p>
<p>一般来说，一些警告信息是常见的：</p>
<p>　　1）声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧）</p>
<p>　　2）使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数）</p>
<p>　　3）没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧）</p>
<p>　　4）类型向下转换。（例如：float f &#x3D; 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了）</p>
<p>不管怎么说，编译器的Warning不要小视，最好不要忽略，一个程序都做得出来，何况几个小小的Warning呢？</p>
<h4 id="32、书写Debug版和Release版的程序"><a href="#32、书写Debug版和Release版的程序" class="headerlink" title="32、书写Debug版和Release版的程序"></a>32、书写Debug版和Release版的程序</h4><p>程序在开发过程中必然有许多程序员加的调试信息。我见过许多项目组，当程序开发结束时，发动群众删除程序中的调试信息，何必呢？为什么不像VC++那样建立两个版本的目标代码？<strong>一个是debug版本的，一个是Release版的</strong>。那些调试信息是那么的宝贵，在日后的维护过程中也是很宝贵的东西，怎么能说删除就删除呢？</p>
<p>利用预编译技术吧，如下所示声明调试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TRACE</span><span class="params">(<span class="type">char</span>* fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> TRACE(char* fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>让所有的程序都用TRACE输出调试信息，只需要在在编译时加上一个参数”-DDEBUG”，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -DDEBUG -o target target.c</span><br></pre></td></tr></table></figure>

<p>于是，预编译器发现DEBUG变量被定义了，就会使用TRACE函数。而如果要发布给用户了，那么只需要把取消”-DDEBUG”的参数，于是所有用到TRACE宏，这个宏什么都没有，所以源程序中的所有TRACE语言全部被替换成了空。一举两得，一箭双雕，何乐而不为呢？</p>
<p>顺便提一下，两个很有用的系统宏，一个是”<code>__FILE__&quot;</code>，一个是”<code>__LINE__</code>“，分别表示，所在的源文件和行号，当你调试信息或是输出错误时，可以使用这两个宏，让你一眼就能看出你的错误，出现在哪个文件中的第几行。这对于用C&#x2F;C++做的大工程非常的管用。</p>
<p>综上所述的32条，都是为了三大目的：</p>
<ol>
<li><strong>程序代码的易读性</strong></li>
<li><strong>程序代码的可维护性</strong></li>
<li><strong>程序代码的稳定可靠性。</strong></li>
</ol>
<p>有修养的程序员，就应该要学会写出这样的代码！这是任何一个想做编程高手所必需面对的细小的问题，编程高手不仅技术要强，基础要好，而且最重要的是要有”修养”！</p>
<p>好的软件产品绝不仅仅是技术，而更多的是整个软件的易维护和可靠性。　　</p>
<p>软件的维护有大量的工作量花在代码的维护上，软件的Upgrade，也有大量的工作花在代码的组织上，所以好的代码，清淅的，易读的代码，将会大大减少软件的维护和升级成本。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/">https://centlabs.github.io/2022/04/23/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/23/Mediapipe%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Mediapipe入门:搭建姿态检测模型并实时输出人体关节点3d坐标</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/22/%E8%A1%8C%E4%B8%9A%E4%B8%87%E8%B1%A1/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">行业万象：为什么互联网大厂一边裁员，又一边招人</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/23/C%20plus%20plus/" title="C plus plus"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">C plus plus</div></div></a></div><div><a href="/2022/04/17/C++%20Primer%20Plus%203/" title="C++ Learning 3"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-17</div><div class="title">C++ Learning 3</div></div></a></div><div><a href="/2022/04/21/C++%20Primer%20Plus%204/" title="C++ Learning 4"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-21</div><div class="title">C++ Learning 4</div></div></a></div><div><a href="/2022/04/08/C++%20Learning%202/" title="C++ Learning 2"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">C++ Learning 2</div></div></a></div><div><a href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">C++ Learning</div></div></a></div><div><a href="/2022/04/18/cstdlib%20%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="cstdlib库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">cstdlib库</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB"><span class="toc-number">1.</span> <span class="toc-text">编程修养</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%89%88%E6%9D%83%E5%92%8C%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">1、版权和版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BC%A9%E8%BF%9B%E3%80%81%E7%A9%BA%E6%A0%BC%E3%80%81%E6%8D%A2%E8%A1%8C%E3%80%81%E7%A9%BA%E8%A1%8C%E3%80%81%E5%AF%B9%E9%BD%90"><span class="toc-number">1.2.</span> <span class="toc-text">2、缩进、空格、换行、空行、对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%A8%8B%E5%BA%8F%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.</span> <span class="toc-text">3、程序注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84-in-out-%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4、函数的[in][out]参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%94%E5%9B%9E%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.</span> <span class="toc-text">5、对系统调用的返回进行判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81if-%E8%AF%AD%E5%8F%A5%E5%AF%B9%E5%87%BA%E9%94%99%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6、if 语句对出错的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84-ifndef"><span class="toc-number">1.7.</span> <span class="toc-text">7、头文件中的#ifndef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text">8、在堆上分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">9、变量的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81h%E5%92%8Cc%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.</span> <span class="toc-text">10、h和c文件的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E5%87%BA%E9%94%99%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.11.</span> <span class="toc-text">11、出错信息的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E8%A2%AB%E8%AE%A1%E7%AE%97%E9%87%8F"><span class="toc-number">1.12.</span> <span class="toc-text">12、常用函数和循环语句中的被计算量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.13.</span> <span class="toc-text">13、函数名和变量名的命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E6%8C%87%E9%92%88"><span class="toc-number">1.14.</span> <span class="toc-text">14、函数的传值和传指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E4%BF%AE%E6%94%B9%E5%88%AB%E4%BA%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%AE%E5%85%BB"><span class="toc-number">1.15.</span> <span class="toc-text">15、修改别人程序的修养</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81%E6%8A%8A%E7%9B%B8%E5%90%8C%E6%88%96%E8%BF%91%E4%B9%8E%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BD%A2%E6%88%90%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F"><span class="toc-number">1.16.</span> <span class="toc-text">16、把相同或近乎相同的代码形成函数和宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.17.</span> <span class="toc-text">17、表达式中的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84const"><span class="toc-number">1.18.</span> <span class="toc-text">18、函数参数中的const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%EF%BC%88%E5%A4%9A%E4%BA%86%E8%AF%B7%E7%94%A8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">19、函数的参数个数（多了请用结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%9C%81%E7%95%A5"><span class="toc-number">1.20.</span> <span class="toc-text">20、函数的返回类型，不要省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81goto%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.21.</span> <span class="toc-text">21、goto语句的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E5%AE%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.22.</span> <span class="toc-text">22、宏的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81static%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.23.</span> <span class="toc-text">23、static的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B0%BA%E5%AF%B8"><span class="toc-number">1.24.</span> <span class="toc-text">24、函数中的代码尺寸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81typedef%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.25.</span> <span class="toc-text">25、typedef的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E4%B8%BA%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E%E5%AE%8F"><span class="toc-number">1.26.</span> <span class="toc-text">26、为常量声明宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81%E4%B8%8D%E8%A6%81%E4%B8%BA%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%8A%A0%E5%88%86%E5%8F%B7"><span class="toc-number">1.27.</span> <span class="toc-text">27、不要为宏定义加分号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81-%E5%92%8C-amp-amp-%E7%9A%84%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.28.</span> <span class="toc-text">28、||和&amp;&amp;的语句执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E5%B0%BD%E9%87%8F%E7%94%A8for%E8%80%8C%E4%B8%8D%E6%98%AFwhile%E5%81%9A%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.29.</span> <span class="toc-text">29、尽量用for而不是while做循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81%E8%AF%B7sizeof%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.30.</span> <span class="toc-text">30、请sizeof类型而不是变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5Warning"><span class="toc-number">1.31.</span> <span class="toc-text">31、不要忽略Warning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E4%B9%A6%E5%86%99Debug%E7%89%88%E5%92%8CRelease%E7%89%88%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.32.</span> <span class="toc-text">32、书写Debug版和Release版的程序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 题库"/></a><div class="content"><a class="title" href="/2023/11/14/Data%20Structure-%E9%A2%98%E5%BA%93/" title="Data Structure - 题库">Data Structure - 题库</a><time datetime="2023-11-14T13:59:04.475Z" title="Created 2023-11-14 21:59:04">2023-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure - 王道"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure-%E7%8E%8B%E9%81%93/" title="Data Structure - 王道">Data Structure - 王道</a><time datetime="2023-11-12T15:05:01.134Z" title="Created 2023-11-12 23:05:01">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure Algorithm"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure%20Algorithm/" title="Data Structure Algorithm">Data Structure Algorithm</a><time datetime="2023-11-12T13:02:28.408Z" title="Created 2023-11-12 21:02:28">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/Data%20Structure/" title="Data Structure"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data Structure"/></a><div class="content"><a class="title" href="/2023/11/12/Data%20Structure/" title="Data Structure">Data Structure</a><time datetime="2023-11-12T09:47:27.180Z" title="Created 2023-11-12 17:47:27">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CTF竞赛介绍以及刷题网址"/></a><div class="content"><a class="title" href="/2023/03/11/CTF%E7%AB%9E%E8%B5%9B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%88%B7%E9%A2%98%E7%BD%91%E5%9D%80/" title="CTF竞赛介绍以及刷题网址">CTF竞赛介绍以及刷题网址</a><time datetime="2023-03-11T03:46:03.959Z" title="Created 2023-03-11 11:46:03">2023-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>