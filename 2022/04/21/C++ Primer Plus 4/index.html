<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ Learning 4 | CentLabs</title><meta name="keywords" content="C++"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第十二章  类和动态内存分配动态内存和类C++在分配内存时的策略：&#x3D;&#x3D;在运行时决定内存分配，而不是在编译时决定&#x3D;&#x3D;。这样，可以根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。 :ship:C++空指针 新关键字nullptr，用于表示空指针。 1str &#x3D; nullptr;		&#x2F;&#x2F; C++11">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Learning 4">
<meta property="og:url" content="https://centlabs.github.io/2022/04/21/C++%20Primer%20Plus%204/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="第十二章  类和动态内存分配动态内存和类C++在分配内存时的策略：&#x3D;&#x3D;在运行时决定内存分配，而不是在编译时决定&#x3D;&#x3D;。这样，可以根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。 :ship:C++空指针 新关键字nullptr，用于表示空指针。 1str &#x3D; nullptr;		&#x2F;&#x2F; C++11">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-21T10:15:08.627Z">
<meta property="article:modified_time" content="2022-04-22T02:18:33.921Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2022/04/21/C++%20Primer%20Plus%204/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Learning 4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-22 10:18:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ Learning 4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-21T10:15:08.627Z" title="Created 2022-04-21 18:15:08">2022-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-22T02:18:33.921Z" title="Updated 2022-04-22 10:18:33">2022-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ Learning 4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章  类和动态内存分配"></a>第十二章  类和动态内存分配</h3><h4 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h4><p>C++在分配内存时的策略：&#x3D;&#x3D;在运行时决定内存分配，而不是在编译时决定&#x3D;&#x3D;。这样，可以根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。</p>
<p>:ship:<strong>C++空指针</strong></p>
<p>新关键字nullptr，用于表示空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">nullptr</span>;		<span class="comment">// C++11 null pointer notation</span></span><br></pre></td></tr></table></figure>

<h4 id="在构造函数中使用new时应注意的事项"><a href="#在构造函数中使用new时应注意的事项" class="headerlink" title="在构造函数中使用new时应注意的事项"></a>在构造函数中使用new时应注意的事项</h4><p>使用new初始化对象的指针成员时必须特别小心。具体来说：</p>
<ul>
<li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。</li>
<li>new和delete必须相互兼容。new对应于delete，new[ ] 对应于delete[ ]。</li>
<li>如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。</li>
</ul>
<p><strong>NULL、0 还是 nullptr</strong>：以前，空指针可以用0或NULL（在很多头文件中，NULL是一个被定义为0的符号常量）来表示。C程序员通常使用NULL而不是0，以指出这是一个指针，就像使用’\0’而不是0来表示空字符，以指出这是一个字符一样。然而，C++传统上更喜欢用简单的0，而不是等价的NULL。C++11提供了新的关键字nullptr。</p>
<h3 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章  类继承"></a>第十三章  类继承</h3><p>C++提供了更高层次的重用性。目前，很多厂商提供了类库，<strong>类库由类声明和实现构成</strong>。因为类组合了数据表示和类方法，因此提供了比函数库更加完整的程序包。例如：单个类就可以提供用于管理对话框的全部资源。通常，<strong>类库是以源代码的方式提供的</strong>，这就意味着可以对其进行修改，以满足需求。然而，C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作&#x3D;&#x3D;类继承&#x3D;&#x3D;，<strong>它能够从已有的类派生出新的类，而派生类继承了原有类（基类）的特征</strong>，<strong>包括方法</strong>。通过继承派生出的类通常比设计新类要容易得多。</p>
<ul>
<li>可以在已有类的基础上添加功能。例如：对于数组类，可以添加数学运算。</li>
<li>可以给类添加数据。例如：对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据成员。</li>
<li>可以修改类方法的行为。例如：对于代表提供给飞机乘客的服务的Passenger类，可以派生出提供更高级别服务的FirstClassPassenger类。</li>
</ul>
<h4 id="一个简单的基类"><a href="#一个简单的基类" class="headerlink" title="一个简单的基类"></a>一个简单的基类</h4><p>&#x3D;&#x3D;从一个类派生出另一个类时，原始类称为基类， 继承类称为派生类。&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RatedPlayer derives from the TableTennisPlayer base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RatedPlayer</span> : <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>冒号</strong>指出RatedPlayer类的基类是TableTennisPlayer类。上述特殊的声明头表明TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。</p>
<ul>
<li><p>派生类对象存储了基类的数据成员（派生类继承了基类的实现）</p>
</li>
<li><p>派生类对象可以使用基类的方法（派生类继续了基类的接口）</p>
</li>
</ul>
<p>需要在继承特性中添加什么？</p>
<ul>
<li>派生类需要自己的构造函数</li>
<li>派生类可以根据需要添加额外的数据成员和成员函数。</li>
</ul>
<p><strong>构造函数：访问权限的考虑</strong></p>
<p>&#x3D;&#x3D;派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。&#x3D;&#x3D;</p>
<p>具体地说，派生类构造函数必须使用基类构造函数。</p>
<p>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表语法来完成这种工作。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将参数从派生类构造函数传递给基类构造函数</span></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="type">unsigned</span> <span class="type">int</span> r, <span class="type">const</span> string &amp; fn,</span><br><span class="line">     <span class="type">const</span> string &amp; ln, <span class="type">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(fn, ln, ht)</span><br><span class="line">    									 <span class="comment">//	基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>: TableTennisPlayer(fn, ln, ht)</code>是成员初始化列表。它是可执行的代码，调用TableTennisPlayer 构造函数。</p>
<p>例如：假设程序包含如下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则RatedPlayer 构造函数将把实参 “Mallory”、”Duck”、 true 赋给形参fn、ln 和 ht，然后将这些参数作为实参传递给TableTennisPlayer 构造函数，后者将创建一个嵌套 TableTennisPlayer  对象，并将数据  “Mallory”、”Duck”和 true 存储在该对象中。然后，程序进入RatedPlayer 构造函数体，完成RatedPlayer 对象的创建，并将参数r的值赋给rating 成员。</p>
<p>有关派生类构造函数的要点如下：</p>
<ul>
<li>首先创建基类对象</li>
<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数</li>
<li>派生类构造函数应初始化派生类新增的数据成员</li>
</ul>
<p>这个例子没有提供显示构造函数，因此将使用隐式构造函数。释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。</p>
<p>注意：<strong>创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</strong></p>
<p>​       &#x3D;&#x3D;派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类析构函数。&#x3D;&#x3D;</p>
<p>:rocket:<strong>成员初始化列表</strong></p>
<p>派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">derived::<span class="built_in">derived</span>(type1 x, type2 y) : <span class="built_in">base</span>(x, y)	  <span class="comment">// initializer list</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中derived 是派生类， base是基类， x和y 是基类构造函数使用的变量。例如：如果派生类构造函数接收到参数 10 和 12，则这种机制将把 10 和 12 传递给被定义为接受这些类型的参数的基类构造函数。除了虚基类外，类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依次类推。如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。成员初始化列表只能用于构造函数。</p>
<p><strong>虚函数：</strong></p>
<ul>
<li>在基类方法的声明中使用<strong>关键字virtual</strong>可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</li>
</ul>
<h4 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h4><p>关键字 protected 与 private 相似， 在类外只能用公有类成员来访问protected部分的类成员。<strong>private和protected之间的区别只有在基类派生的类中才会表现出来</strong>，&#x3D;&#x3D;派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员&#x3D;&#x3D;。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。</p>
<p>警告：<strong>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>继承通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。公有继承建立is-a 关系，这意味着派生类对象也应该是某种基类对象。作为is-a模型的一部分，<strong>派生类继承基类的数据成员和大部分方法，但不继承基类的构造函数、析构函数和赋值运算符</strong>。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类和私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。<strong>每个派生类都必须有自己的构造函数</strong>。&#x3D;&#x3D;程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将调用派生类的析构函数，然后调用基类的析构函数。&#x3D;&#x3D;</p>
<p>如果希望派生类可以重新定义基类的方法，则可以使用关键字virtual将它声明为虚的。这样对于通过指针或引用访问的对象，能够根据对象类型来处理，而不是根据引用或指针的类型来处理。具体来说，&#x3D;&#x3D;基类的析构函数通常应当是虚的&#x3D;&#x3D;。</p>
<h3 id="第十四章-C-中的代码重用"><a href="#第十四章-C-中的代码重用" class="headerlink" title="第十四章  C++中的代码重用"></a>第十四章  C++中的代码重用</h3><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;MAX = <span class="number">10</span>&#125;;		<span class="comment">// constant specific to class</span></span><br><span class="line">    Item item[MAX];			<span class="comment">// holds stack items</span></span><br><span class="line">    <span class="type">int</span> top;				<span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> Item &amp; item)</span></span>;	<span class="comment">// add item to stack</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>;			<span class="comment">// pop top into item</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>采用模板时，将使用模板定义替换Stack声明，使用模板成员函数替换Stack的成员函数。和模板函数一样，模板类以下面这样的代码开头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br></pre></td></tr></table></figure>

<p>关键字template告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。可以把关键字class看作是变量的类型名，该变量接受类型作为其值，把Type看作是该变量的名称。</p>
<p>这里使用class并不意味着Type必须是一个类：而只是表明Type是一个通用的类型说明符，在使用模板时，将使用实际的类型替换它。较新的C++实现允许在这种情况下使用不太容易混淆的关键字typename代替class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;		<span class="comment">// newer choice</span></span><br></pre></td></tr></table></figure>

<p>可以使用自己的泛型代替Type，其命名规则与其他标识符相同。当前流行的选项包括T和Type，我们将使用后者。当模板被调用时，Type将被具体的类型值（如int或string）取代。在模板定义中，可以使用泛型名来标识要存储在栈中的类型。对于Stack来说，这意味着应将声明中的所有的typedef标识符Item替换为Type。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Item items[MAX];		</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type items[MAX];</span><br></pre></td></tr></table></figure>

<p>同样，可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同的模板声明打头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br></pre></td></tr></table></figure>

<p>同样应使用泛型名Type替换typedef标识符Item。另外，还需要将类限定符从<code>Stack::</code> 改为<code>Stack&lt;Type&gt;::</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">const</span> Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应改为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;				<span class="comment">// or template &lt;typename Type&gt;</span></span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">push</span>(<span class="type">const</span> Type &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅在程序包含模板并不能生成模板类，而必须请求实例化。为此，需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛型名。例如，下面的代码创建两个栈，一个用于存储int，另一个用于存储string对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; Kernels;				<span class="comment">// create a stack of ints</span></span><br><span class="line">Stack&lt;string&gt; colonels;			<span class="comment">// create a stack of string objects</span></span><br></pre></td></tr></table></figure>

<p>编译器将按<code>Stack&lt;Type&gt;</code>模板来生成两个独立的类声明和两组独立的类方法。类声明Stack<int>将使用int替换模板中所有的Type，而类声明Stack<string>将使用string替换Type。当然，使用的算法必须与类型一致。</p>
<p>泛型标识符：例如Type称为类型参数（type parameter），这意味着它们类似于变量，但赋给它们的不能是数字，而只能是类型。</p>
<p>编译器可以根据函数的参数类型来确定生成哪种函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple</span><span class="params">(T t)</span> </span>&#123; cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">simple</span>(<span class="number">2</span>);				<span class="comment">// generate void simple(int)</span></span><br><span class="line"><span class="built_in">simple</span>(<span class="string">&quot;two&quot;</span>);			<span class="comment">// generate void simple(const char *)</span></span><br></pre></td></tr></table></figure>



<h3 id="第十五章-友元、异常和其他"><a href="#第十五章-友元、异常和其他" class="headerlink" title="第十五章  友元、异常和其他"></a>第十五章  友元、异常和其他</h3><p>友元声明可以位于公有、私有或包含部分，其所在的位置无关紧要。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Remote</span>;		<span class="comment">// Tv类决定谁是它的友元</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Class Remote</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remote 的所有方法都可能影响到Tv的私有成员</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t, <span class="type">int</span> c)</span></span>;	<span class="comment">// Tv类决定谁是他的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有Remote::set_chan() 能够影响Tv的私有成员</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="type">const</span> Item &amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isfull</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node * add = <span class="keyword">new</span> Node;		<span class="comment">// create node</span></span><br><span class="line">    <span class="comment">// on failure, new throws std::bad_alloc exception</span></span><br><span class="line">    add-&gt;item = item;			<span class="comment">// set node pointers</span></span><br><span class="line">    add-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板中的嵌套</strong></p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUETP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUETP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueTP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;Q_SIZE = <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">			Item item;</span><br><span class="line">        	Node * next;</span><br><span class="line">        	<span class="built_in">Node</span>(<span class="type">const</span> Item &amp; i):<span class="built_in">item</span>(<span class="number">1</span>), <span class="built_in">next</span>(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node * front;</span><br><span class="line">    Node * rear;</span><br><span class="line">    <span class="type">int</span> items;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> qsize;</span><br><span class="line">    <span class="built_in">QueueTP</span>(<span class="type">const</span> QueueTP &amp; q) : <span class="built_in">qsize</span>(<span class="number">0</span>)&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QueueTP&#123;<span class="type">int</span> qs = Q_SIZE&#125;;</span><br><span class="line">    ~<span class="built_in">QueueTP</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items == qsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queuecount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> Item &amp;item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dequeue</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// QueueTP methods</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line">QueueTP&lt;Item&gt;::<span class="built_in">QueueTP</span>(<span class="type">int</span> qs) : <span class="built_in">qsize</span>(qs)</span><br><span class="line">&#123;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line">QueueTP&lt;Item&gt;::~<span class="built_in">QueueTP</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node * temp;</span><br><span class="line">    <span class="keyword">while</span> (front != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line"><span class="type">bool</span> QueueTP&lt;Item&gt;::<span class="built_in">enqueue</span>(<span class="type">const</span> Item &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isfull</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node * add = <span class="keyword">new</span> <span class="built_in">Node</span>(item);</span><br><span class="line">    items++;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="number">0</span>)</span><br><span class="line">        front = add;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next = add;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line"><span class="type">bool</span> QueueTP&lt;Item&gt;::<span class="built_in">dequeue</span>(Item &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    item = front-&gt;item;</span><br><span class="line">    item--;</span><br><span class="line">    Node * temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(items == <span class="number">0</span>)</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>1、调用abort()</strong></p>
<p>如果其中一个参数是另一个参数的负值，则调用abort()函数。Abort()函数的原型位于头文件cstdlib(或stdlib.h)中，其典型实现是向标准错误流（即cerr使用的错误流）发送消息abnormal program termination（程序异常终止），然后终止程序。</p>
<p><strong>2、异常机制</strong></p>
<p>C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另一部分的途径。对异常的处理有3个组成部分：</p>
<ul>
<li>引发异常</li>
<li>使用处理程序捕获异常</li>
<li>使用try块</li>
</ul>
<p>程序在出现问题时将引发异常。</p>
<p>程序使用异常处理程序（exception handler）来捕获异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。异常处理程序也被称为catch块。</p>
<p>try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y ,z;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;					<span class="comment">// start of try block</span></span><br><span class="line">            z = <span class="built_in">hmean</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> * s)	<span class="comment">// start of exception handler</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y</span><br><span class="line">            	  &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == -b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;bad hmean() arguments: a = -b not allowed&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;					<span class="comment">// start of try block</span></span><br><span class="line">	z = <span class="built_in">hmean</span>(x,y);</span><br><span class="line">&#125;						<span class="comment">// end of try block</span></span><br></pre></td></tr></table></figure>

<p>如果其中的某条语句导致异常被引发，则后面的catch块将对异常进行处理。如果程序在try块的外面调用hmean()，将无法处理异常。</p>
<p>引发异常的代码与下面类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == -b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;bad hmean() arguments: a = -b not allowed&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其中被引发的异常是字符串。异常类型可以是字符串或其他C++类型；通常为类类型。</p>
<p>执行throw语句类似于执行返回语句，因为它也将终止函数的执行；但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。</p>
<p>在这个例子中，throw将程序控制权返回给main()。程序将在main()中寻找与引发的异常类型匹配的异常处理程序（位于try块的后面）。</p>
<p>处理程序（或catch块）与下面类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (<span class="type">char</span> * s)	<span class="comment">// start of exception handler</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch块点类似于函数定义，但并不是函数定义。关键字catch表明这是一个处理程序，而<code>char* </code>s 则表明该处理程序与字符串异常匹配。s与函数参数定义极其类似，因为匹配的引发将被赋给s。另外，当异常与该处理程序匹配时，程序将执行括号中的代码。</p>
<p><strong>3、RTTI</strong></p>
<p>RTTI是运行阶段类型的识别（Runtime Type Identification）的简称。</p>
<p>RTTI的工作原理：C++有3个支持RTTI的元素。</p>
<ul>
<li>如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0——空指针。</li>
<li>typeid运算符返回一个指出对象的类型的值。</li>
<li>type_info 结构存储了有关特定类型的信息。</li>
</ul>
<p>只能将RTTI用于包含虚函数的类层次结构，，原因在于只有对于这种类层次结构，才应该将派生类对象的地址赋给基类指针。</p>
<p>警告：<strong>RTTI只适用于包含虚函数的类。</strong></p>
<p><strong>4、类型转换运算符</strong></p>
<p>对于C语言松散的类型转换，C++提供更加严格地限制允许的类型转换，并添加4个类型转换运算符，使转换过程更规范：</p>
<ul>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>static_cast</li>
<li>reinterpret_cast</li>
</ul>
<p>可以根据目的选择一个合适的运算符，而不是使用通用的类型转换。</p>
<p>1）dynamic_cast运算符的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span> &lt; type-name &gt; (expression)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>const_cast运算符的语法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span> &lt; type-name &gt; (expression)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>static_cast运算符的语法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt; type-name &gt; (expression)</span><br></pre></td></tr></table></figure>

<p>4）reinterpret_cast运算符的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reinterpret_cast</span> &lt; type-name &gt; (expression)</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>友元使得能够为类开发更灵活的接口。类可以将其他函数、其他类和其他类的成员函数作为友元。在某些情况下，可能需要使用前向声明，需要特别注意类和方法声明的顺序，以正确地组合友元。</p>
<p>嵌套类是在其他类中声明的类，它有助于设计这样的助手类，即实现其他类，但不必是公有接口的组成部分。</p>
<p>C++异常机制为处理拙劣的编程事件，如不适当的值、I&#x2F;O失败等，提供了一种灵活的方法。引发异常将终止当前执行的函数，将控制权传给匹配的catch块。catch块紧跟在try块的后面，为捕获异常，直接或间接导致异常的函数调用必须位于try块中。这样程序将执行catch块中的代码。</p>
<p>RTTI（运行阶段类型信息）特性让程序能够检测对象的类型。dynamic_cast运算符用于将派生类指针转换为基类指针，其主要用途是确保可以安全地调用虚函数。Typeid运算符返回一个type_info对象。可以对两个typeid的返回值进行比较，以确保对象是否为特定的类型，而返回的type_info对象可用于获得关于对象的信息。</p>
<h3 id="第十六章-string类和标准模板库"><a href="#第十六章-string类和标准模板库" class="headerlink" title="第十六章  string类和标准模板库"></a>第十六章  string类和标准模板库</h3><h4 id="1、string类"><a href="#1、string类" class="headerlink" title="1、string类"></a>1、string类</h4><p>string类包含了大量的方法，其中包括了若干构造函数，用于将字符串赋给变量、合并字符串、比较字符串和访问各个元素的重载运算符以及用于在字符串中查找字符和子字符串的工具等。简而言之，string类包含的内容很多。</p>
<p>​																	<strong>string 类的构造函数</strong></p>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>描   述</th>
</tr>
</thead>
<tbody><tr>
<td><code>string(const char * s)</code></td>
<td>将string对象初始化为s指向的NBTS</td>
</tr>
<tr>
<td><code>string(size_type n, char c)</code></td>
<td>创建一个包含n个元素的string对象，其中每个元素都被初始化为字符c</td>
</tr>
<tr>
<td><code>string(const string &amp; str)</code></td>
<td>将一个string对象初始化为string对象str（复制构造函数）</td>
</tr>
<tr>
<td><code>string( )</code></td>
<td>创建一个默认的string对象，长度为0（默认构造函数）</td>
</tr>
<tr>
<td><code>string(const char * s, size_type n)</code></td>
<td>将string对象初始化为s指向的NBST的前n个字符，即使超过了NBTS结尾</td>
</tr>
<tr>
<td><code>template&lt;class Iter&gt;</code>   <code>string(Iter begin, Iter end)</code></td>
<td>将string对象初始化为区间[begin, end)内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end</td>
</tr>
<tr>
<td><code>string (const string &amp; str, string size_type pos = 0, size_type n = npos)</code></td>
<td>将一个string对象初始化为对象str中从位置pos开始到结尾的字符，或从位置pos开始的n个字符</td>
</tr>
<tr>
<td><code>string(string &amp;&amp; str)  noexcept</code></td>
<td>这是C++11 新增的，它将一个string对象初始化为string对象str，并可能修改str（移动构造函数）</td>
</tr>
<tr>
<td><code>string(initializer_list&lt;char&gt;  il)</code></td>
<td>C++11新增的，它将一个string对象初始化为初始化列表il中的字符</td>
</tr>
</tbody></table>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将string对象初始化为常规的C-风格字符串</span></span><br><span class="line">    <span class="function">string <span class="title">one</span><span class="params">(<span class="string">&quot;Lottery Winner!&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化为由20个$字符组成的字符串</span></span><br><span class="line">    <span class="function">string <span class="title">two</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;$&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; two &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制构造函数将string对象three初始化为string对象one</span></span><br><span class="line">    <span class="function">string <span class="title">three</span><span class="params">(one)</span></span>;</span><br><span class="line">    cout &lt;&lt; three &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载的+=运算符将字符串附加到字符串one的后面</span></span><br><span class="line">    one += <span class="string">&quot; Oops!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载[]运算符使得可以使用数组表示法来访问string对象中的各个字符</span></span><br><span class="line">    two = <span class="string">&quot;Sorry! That was &quot;</span>;</span><br><span class="line">    three[<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">    string four;</span><br><span class="line">    four = two + three;</span><br><span class="line">    cout &lt;&lt; four &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将一个C-风格字符串和一个整数作为参数，其中的整数参数表示要复制多少个字符</span></span><br><span class="line">    <span class="type">char</span> alls[] = <span class="string">&quot;All&#x27;s well that ends well&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">five</span><span class="params">(alls,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; five &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组名相当于指针，所以都是char * 类型</span></span><br><span class="line">    <span class="function">string <span class="title">six</span><span class="params">(alls+<span class="number">6</span>, alls + <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; six &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// five[6]是一个char值，&amp;five[6]是一个地址，可被用作该构造函数的一个参数</span></span><br><span class="line">    <span class="function">string <span class="title">seven</span><span class="params">(&amp;five[<span class="number">6</span>], &amp;five[<span class="number">10</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; seven &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将一个string对象的部分内容复制到构造的对象中</span></span><br><span class="line">    <span class="function">string <span class="title">eight</span><span class="params">(four, <span class="number">7</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; eight &lt;&lt; <span class="string">&quot; in motion!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lottery Winner!</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">Lottery Winner!</span><br><span class="line">Lottery Winner! Oops!</span><br><span class="line">Sorry! That was Pottery Winner!</span><br><span class="line">All&#x27;s well that ends!</span><br><span class="line">well, well...</span><br><span class="line">That was Pottery in motion!</span><br></pre></td></tr></table></figure>

<p><strong>string 类输入</strong></p>
<p>对于类，很有帮助的另一个点是，知道有哪些输入方式可用。对于C-风格字符串，有三种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info;		</span><br><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>);		<span class="comment">// read a line, discard \n</span></span><br><span class="line">cin.<span class="built_in">get</span>(info, <span class="number">100</span>);			<span class="comment">// read a line, leave \n in queue</span></span><br></pre></td></tr></table></figure>

<p>对于string对象，有两种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;				<span class="comment">// read a word</span></span><br><span class="line"><span class="built_in">getline</span>(cin, stuff);		<span class="comment">// read a line, discard \n</span></span><br></pre></td></tr></table></figure>

<p>两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>,<span class="string">&#x27;:&#x27;</span>);		<span class="comment">// read up to :, discard :</span></span><br><span class="line"><span class="built_in">getline</span>(stuff, <span class="string">&#x27;:&#x27;</span>);			<span class="comment">// read up to :, discard :</span></span><br></pre></td></tr></table></figure>

<p>在功能上，它们之间的主要区别在于，string版本的getline()将自动调整目标string对象的大小，使之刚好能够存储输入的字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fname[<span class="number">10</span>];</span><br><span class="line">string lname;</span><br><span class="line">cin &gt;&gt; fname;			<span class="comment">// could be a problem if input size &gt; 9 characters</span></span><br><span class="line">cin &gt;&gt; lname;			<span class="comment">// can read a very, very long word</span></span><br><span class="line">cin.<span class="built_in">getline</span>(fname, <span class="number">10</span>);		<span class="comment">// may truncate input</span></span><br><span class="line"><span class="built_in">getline</span>(cin, lname);		<span class="comment">// no truncation</span></span><br></pre></td></tr></table></figure>

<p>自动调整大小的功能让string版本的getline()不需要指定读取多少个字符的数值参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="keyword">operator</span>&gt;&gt;(fname);		<span class="comment">// ostream class method</span></span><br><span class="line"><span class="keyword">operator</span>&gt;&gt;(cin,lname);		<span class="comment">// regular function</span></span><br></pre></td></tr></table></figure>

<p>string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列三种情况之一：</p>
<ul>
<li>到达文件尾，在这种情况下，输入流的eofbit将被设置，这意味着方法fail()和eof()都将返回true；</li>
<li>遇到分界字符（默认为\n），在这种情况下，将把分界字符从输入流中删除，但不存储它；</li>
<li>读取的字符数达到最大允许值（string::npos  和可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的failbit，这意味着方法fail()将返回true。</li>
</ul>
<p>从文件中读取字符串示例：</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    fin.<span class="built_in">open</span>(<span class="string">&quot;tobuy.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t open file. Bye.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    string item;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getline</span>(fin, item, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(fin)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">getline</span>(fin, item, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>string 还提供了哪些功能</strong></p>
<p>string库提供了很多其他的工具，包括完成下述功能的函数：</p>
<ul>
<li>删除字符串的部分或全部内容</li>
<li>用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容</li>
<li>将数据插入到字符串中删除字符串中的数据</li>
<li>将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较</li>
<li>从字符串中提取子字符串</li>
<li>将一个字符串中的内容复制到另一个字符串中</li>
<li>交换两个字符串的内容。</li>
</ul>
<p>这些函数大多数都被重载，以便能够同时处理C-风格字符串和string对象。</p>
<p><strong>内存块分配限制：</strong></p>
<p>为了 避免字符串不断增大，超过了内存块的大小，或者不断地分配新的内存块，方法capacity()返回当前分配给字符串的内存块的大小，而reserve()方法能够请求内存块的最小长度。</p>
<h4 id="2、智能指针模板类"><a href="#2、智能指针模板类" class="headerlink" title="2、智能指针模板类"></a>2、智能指针模板类</h4><p>智能指针是行为类似于指针的类对象，但这种对象还有其他功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string * ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    </span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能发现了其中的缺陷，每当调用时，该函数部分都分配堆中的内存，但从不回收，从而导致<strong>内存泄漏</strong>。</p>
<p>只要别忘了在return语句前添加下面的语句，以释放分配的内存即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete ps;</span><br></pre></td></tr></table></figure>

<p>但凡涉及”别忘了“的解决办法，很少是最佳的。例如：下面的变体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string * ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当出现异常时，delete将不被执行，因此也将导致内存泄露。</p>
<p><strong>1）使用智能指针</strong></p>
<p>这三个智能指针模板（auto_ptr、unique_ptr和shared_ptr）都定义了类似指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动被释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> * pd = <span class="keyword">new</span> <span class="type">double</span>;	<span class="comment">// 为pd和一个double值分配存储空间，保存地址</span></span><br><span class="line">    *pd = <span class="number">25.5</span>;					<span class="comment">// 将值复制到动态内存中</span></span><br><span class="line">    <span class="keyword">return</span>;						<span class="comment">// 删除pd，值被保留在动态内存中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;	<span class="comment">// 为ap和一个double值分配存储空间，保存地址</span></span><br><span class="line">    *ap = <span class="number">25.5</span>;							<span class="comment">// 将值复制到动态内存中</span></span><br><span class="line">    <span class="keyword">return</span>;								<span class="comment">// 删除ap，ap的析构函数释放动态内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建智能指针对象，必须包含头文件 memory，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。例如：模板auto_ptr包含如下构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X * p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>throw（）意味着构造函数不会引发异常；与aoto_ptr一样，throw()也被掘弃。因此，请求X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;	<span class="comment">// pd an auto_ptr to double</span></span><br><span class="line">									<span class="comment">// (use in place of double * pd)</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>;	<span class="comment">// ps an auto_ptr to string</span></span><br><span class="line">									<span class="comment">// (use in place of string * ps)</span></span><br></pre></td></tr></table></figure>

<p>new double是new返回的指针，指向新分配的内存块。它是构造函数<code>auto_ptr&lt;double&gt;</code>的参数，即对应于原型中形参p的实参，同样，new string也是构造函数的实参。</p>
<p>其他两种智能指针使用同样的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">double</span>&gt; <span class="title">pdu</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pss</span><span class="params">(<span class="keyword">new</span> string)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，要转换remodel()函数，应按下面3个步骤进行：</p>
<ol>
<li>包含头文件memory；</li>
<li>将指向string的指针替换为指向string的智能指针对象；</li>
<li>删除delete语句</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;std::string&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到智能指针模板位于名称空间std中。</p>
<h4 id="3、标准模板库"><a href="#3、标准模板库" class="headerlink" title="3、标准模板库"></a>3、标准模板库</h4><p>STL提供了一组表示容器、迭代器、函数对象和算法的模板。**&#x3D;&#x3D;容器是一个与数组类似的单元，可以存储若干个值&#x3D;&#x3D;<strong>。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务（如堆数组进行排序或在链表中查找特定值）的处方；</strong>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针**；函数对象是类似于函数的对象，可以是类对象或函数指针（包括函数名，因为函数名被用作指针）。STL使得能够构造各种容器（包括数组、队列和链表）和执行各种操作（包括搜素、排序和随机排列）。</p>
<p><strong>1）模板类vector</strong></p>
<p>在计算中，vector对应数组。vector类可以创建vector对象，将一个vector对象赋给另一个对象，使用[ ]运算符来访问vector元素。要使类成为通用的，将它设计为模板类，STL正是这样做的，在头文件vector中定义一个vector模板。</p>
<p>要创建vector模板对象，可使用通常的<type>表示法来指出要使用的类型。另外，vector模板使用动态内存分配，因此可以用初始化参数来指出需要多少矢量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rating</span><span class="params">(<span class="number">5</span>)</span></span>;			<span class="comment">// a vector of 5 ints</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">scores</span><span class="params">(n)</span></span>;		<span class="comment">// a vector of n doubles</span></span><br></pre></td></tr></table></figure>

<p><strong>由于运算符[ ] 被重载，因此创建vector对象后，可以使用通常的数组表示法来访问各个元素</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ratings[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    cout &lt;&lt; scores[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::vector;</span><br><span class="line">    <span class="keyword">using</span> std::string;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ratings</span><span class="params">(NUM)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">titles</span><span class="params">(NUM)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You will do exactly as told. You will enter\n&quot;</span></span><br><span class="line">         &lt;&lt; NUM &lt;&lt; <span class="string">&quot;book titles and your ratings (0.10).\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter title #&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin,title[i]);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter your rating (0 - 10)&quot;</span>;</span><br><span class="line">        cin &gt;&gt; ratings[i];</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thank you. You entered the following:\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;Rating\t Boook\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ratings[i] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; titles[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2) 可对矢量执行的操作</strong></p>
<p>除分配存储空间外，vector模板还可以完成哪些任务呢？所有的STL容器提供了一些基本方法，其中包括：</p>
<ul>
<li>size( ) ： 返回容器中元素数目</li>
<li>swap( ) ：交换两个容器的内容</li>
<li>begin( ) ：返回一个指向容器中第一个元素的迭代器</li>
<li>end( )：返回一个表示超过容器尾的迭代器</li>
</ul>
<p>什么是迭代器？它是一个广义指针。事实上，它可以是指针，也可以是一个对其执行类似指针的操作：如解除引用（如<code>operator*( )</code>）和递增（如<code>operator++( )</code>）的对象。</p>
<p>通过将指针广义化为迭代器，让STL能够为各种不同的容器类（包括那些简单指针无法处理的类）提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为<code>iterator</code>的typedef，其作用域为整个类。</p>
<p>例如：要为vector的double类型规范声明一个迭代器，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator pd;		<span class="comment">// pd an iterator</span></span><br></pre></td></tr></table></figure>

<p>假设scores是一个<code>vector&lt;double&gt;</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; scores;</span><br></pre></td></tr></table></figure>

<p>则可以使用迭代器pd执行这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd = scores.<span class="built_in">begin</span>();	<span class="comment">// have pd pointer to the first element</span></span><br><span class="line">*pd = <span class="number">22.3</span>;				<span class="comment">// dereference pd and assign value to first element</span></span><br><span class="line">++pd;					<span class="comment">// make pd point to the next element</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;迭代器的行为就像指针。&#x3D;&#x3D;</p>
<p>顺便说一句，还有一个C++11 自动类型推断很有用的地方。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator pd = scores.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//转为</span></span><br><span class="line"><span class="keyword">auto</span> pd = scores.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>什么是超过结尾（past-the-end）呢？它是一种迭代器，指向容器最后一个元素后面的那个元素。这与C-风格字符串最后一个字符后面的空字符类似，只是空字符是一个值，而”超过结尾”是一个指向元素的指针（迭代器）。end( )成员函数标识超过结尾的位置。如果将迭代器设置为容器的第一个元素，并不断地递增，则最终它将到达容器结尾，从而遍历整个容器的内容。</p>
<p>vector模板类也包含一些只有某些STL容器才有的方法。<code>push_back( )</code>是一个方便的方法，它将元素添加到矢量末尾。这样做时，它将负责内存管理，增加矢量的长度，使之能够容纳新的成员。这意味着可以编写这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; scores;			<span class="comment">// create an empty vector</span></span><br><span class="line"><span class="type">double</span> temp;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; temp &amp;&amp; temp &gt;= <span class="number">0</span>)</span><br><span class="line">    scores.<span class="built_in">push_back</span>(temp);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You entered &quot;</span> &lt;&lt; scores.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;.scores.\n;&quot;</span></span><br></pre></td></tr></table></figure>

<p>每次循环都给scores对象增加一个元素。在编写或运行程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以根据需要增加scores的长度。</p>
<p><code>erase( )</code>方法删除矢量中给定区间的元素。它接受两个迭代器参数，这些参数定义了要删除的区间。了解STL如何使用两个迭代器来定义区间至关重要。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。</p>
<p>例如：下述代码删除第一个和第二个元素，即删除begin( ) 和begin( )+1指向的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>注意：区间[it1, it2) 由迭代器it1 和 it2 指定，其范围为it1 到it2（不包括it2）。</p>
<p>insert( )方法的功能与erase( )相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入 区间，该区间通常是另一个容器对象的一部分。</p>
<p>例如：下面的代码将矢量new_v中除第一个元素外的所有元素插入到old_v矢量的第一个元素的前面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; new_v;</span><br><span class="line"></span><br><span class="line">old_v.<span class="built_in">insert</span>(old_v.<span class="built_in">begin</span>(),new_v.<span class="built_in">begin</span>()+<span class="number">1</span>, new_v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="4、泛型编程"><a href="#4、泛型编程" class="headerlink" title="4、泛型编程"></a>4、泛型编程</h4><p>STL是一种泛型编程（generic programming）。面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。</p>
<p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。当然，模板使得能够被泛型定义函数或类，而STL通过通用算法更进了一步。模板让这一切成为可能，但必须对元素进行仔细地设计。</p>
<p>不同的算法对迭代器的要求也不同。例如：查找算法需要定义++运算符，以便迭代器能够遍历整个容器；它要求能够读取数据，但不要求能够写数据。而排序算法要求能够随机访问，以便能够交换两个不相邻的元素。如果iter是一个迭代器，则可以通过定义+运算符来实现 随机访问，这样就可以使用像iter + 10这样的表达式了。</p>
<p>STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述。这5种迭代器分别是<strong>输入迭代器</strong>、<strong>输出迭代器</strong>、<strong>正向迭代器</strong>、<strong>双向迭代器</strong>和<strong>随机访问迭代器</strong>。</p>
<p><strong>1）输入迭代器</strong></p>
<p>输入迭代器必须能够访问容器中的所有的值，这是通过支持++运算符来实现的。如果将输入迭代器设置为指向容器中的第一个元素，并不断将其递增，直到到达超尾位置，则它将依次指向容器中的每一个元素，顺便说一句，并不能保证输入迭代器第二次遍历容器时，顺序不变。另外，输入迭代器被递增后，也不能保证其先前的值仍然可以被解除引用。基于输入迭代器的任何算法都应当是单通行的，不依赖于前一次遍历时的迭代器值，也不依赖于本次遍历中前面的迭代器值。</p>
<p>注意：输入迭代器是单向迭代器，可以递增，但不能倒退。</p>
<p><strong>2）输出迭代器</strong></p>
<p>输出迭代器与输入迭代器相似，只是解除引用让程序能修改容器值，而不能读取。</p>
<p>简而言之，对于单通行、只读算法，可以使用输入迭代器；对于单通行、只写算法，则可以使用输出迭代器。</p>
<p><strong>3）正向迭代器</strong></p>
<p>与输入迭代器和输出迭代器相似，正向迭代器只使用++运算符来遍历容器，所以它每次沿容器向前移动一个元素；然而，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一些列值另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到相同的值。这些特征使得多次通行算法成为可能。</p>
<p>正向迭代器既可以使得能够读取和修改数据，也可以使得只能读取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pirw;				<span class="comment">// read-write iterator</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * pir;		<span class="comment">// read-only iterator</span></span><br></pre></td></tr></table></figure>

<p><strong>4）双向迭代器</strong></p>
<p>例如：reverse函数可以交换第一个元素和最后一个元素、将指向第一个元素的指针加1、将指向第二个元素的指针减1，并重复这种处理过程。双向迭代器具有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符。</p>
<p><strong>5）随机访问迭代器</strong></p>
<p>有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫做随机访问，需要随机访问迭代器。随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。</p>
<p> 为何需要这么多迭代器呢？目的是为了在编写算法尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。这样，通过使用级别最低的输入迭代器，find( ) 函数便可用于任何包含可读取值的容器。而sort( ) 函数由于需要随机访问迭代器，所有只能用于支持这种迭代器的容器。</p>
<p>注意：各种迭代器的类型并不是确定的，而只是一种概念性的 描述。每个容器类都定义了一个类级typedef名称——iterator，因此<code>vector&lt;int&gt;</code>类的迭代器类型为<code>vector&lt;int&gt;::iterator</code>。然而，该类的文档指出，矢量迭代器是随机访问迭代器，它允许使用基于任何迭代器类型的算法。因为随机访问迭代器具有所有迭代器的功能。同样，<code>list&lt;int&gt;</code>类的迭代器类型为<code>list&lt;int&gt;::iterator</code>。STL实现了一个双向链表，它使用双向迭代器，因此不能使用基于随机访问迭代器的算法，但可以使用基于要求较低的迭代器的算法。</p>
<h4 id="5、容器种类"><a href="#5、容器种类" class="headerlink" title="5、容器种类"></a>5、容器种类</h4><p>STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、关联容器等）的通用类别；容器类型是可用于创建具体容器对象的模板。</p>
<p>以前的11个容器类型分别是deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset和bitset；C++11 新增了forward_list、unordered_map、unordered_multimap、unordered_set和unordered_multiset，且不将bitset视为容器，而将其视为一种独立的类别。</p>
<p><strong>容器是存储其他对象的对象。被存储的对象必须是同一类型的</strong>，它们可以是OOP意义上的对象，也可以是内置类型值。存储在容器中的数据为容器所有，这意味着当容器过期时，存储在容器中的数据也将过期。</p>
<p><strong>不能将任何类型的对象存储在容器中</strong>，具体地说，类型必须是可复制构造的和可赋值的。基本类型满足这些要求；只要类定义没有将复制构造函数和赋值运算符声明为私有或保护的，则也满足这种要求。</p>
<p>基本容器不能保证其元素都按特定的顺序存储，也不能保证元素的顺序不变，但对概念进行改进后，则可以增加这样的保证。所有的容器都提供某些特征和操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outint</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">one</span><span class="params">(<span class="number">5</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> stuff[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    list&lt;<span class="type">int</span>&gt; two;</span><br><span class="line">    two.<span class="built_in">insert</span>(two.<span class="built_in">begin</span>(), stuff, stuff + <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> more[<span class="number">6</span>] = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">three</span><span class="params">(two)</span></span>;</span><br><span class="line">    three.<span class="built_in">insert</span>(three.<span class="built_in">end</span>(), more, more + <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">    for_each(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List two: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three minus 2s: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">splice</span>(three.<span class="built_in">begin</span>(), one);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after splice: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">    for_each(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">unique</span>();</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after unique: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">sort</span>();</span><br><span class="line">    three.<span class="built_in">unique</span>();</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after sort &amp; unique: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    two.<span class="built_in">sort</span>();</span><br><span class="line">    three.<span class="built_in">merge</span>(two);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Sorted two merged into three: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List one: 2 2 2 2 2</span><br><span class="line">List two: 1 2 4 8 6 6 4 2 6 5 0</span><br><span class="line">List three minus 2s: 1 4 8 6 6 4 6 5 0</span><br><span class="line">List three after splice: 2 2 2 2 2 1 4 8 6 6 4 6 5 0</span><br><span class="line">List one:</span><br><span class="line">List three after unique: 2 1 4 8 6 4 6 5 0</span><br><span class="line">List three after sort &amp; unique: 0 1 2 4 5 6 8</span><br><span class="line">Sorted two merged into three: 0 1 1 2 2 4 4 5 6 6 8 8</span><br></pre></td></tr></table></figure>

<h4 id="6、算法"><a href="#6、算法" class="headerlink" title="6、算法"></a>6、算法</h4><p>STL包含很多处理容器的非成员函数。前面所说的：sort( )、copy( )、find( )、random_shuffle( )、set_union( )、set_intersection( )、set_difference( ) 和 transform( )。它们的总体设计是相同的，都是使用迭代器来标识要处理的数据区间和结果的放置位置。 </p>
<p>对于算法函数设计，有两个主要的通用部分。首先，它们都使用模板来提供泛型；其次，它们都使用迭代器来访问容器中的数据的通用表示。</p>
<h4 id="7、其他库"><a href="#7、其他库" class="headerlink" title="7、其他库"></a>7、其他库</h4><p>C++提供了三个数组模板：vector、valarray 和 array 。这些类是由不同的小组开发的，用于不同的目的。<strong>vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作</strong>，如排序、插入、重新排列、搜素、将数据转移到其他容器中等。而<strong>valarry类模板是面向数值计算的，不是STL的一部分</strong>。例如：它没有push_back( )和 insert( )方法，但为很多数学运算提供了一个简单、直观的接口。最后，<strong>array是为了替代内置数组而设计的，它通过提供更好、更安全的接口，让数组更紧凑，效率更高</strong>。Array表示长度固定的数组，因此不支持push_back( )和insert( )，但提供了多个STL方法，包括begin( )、end( )、rbegin( )和rend( )，这使得很容易将STL算法用于array对象。</p>
<p>例如：有如下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">ved1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">ved2</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">ved3</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">arrat&lt;<span class="type">double</span>,<span class="number">10</span>&gt; vod1, vod2, vod3;</span><br><span class="line"><span class="function">valarray&lt;<span class="type">double</span>&gt; <span class="title">vad1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">vad2</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">vad3</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2022/04/21/C++%20Primer%20Plus%204/">https://centlabs.github.io/2022/04/21/C++%20Primer%20Plus%204/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/22/%E8%A1%8C%E4%B8%9A%E4%B8%87%E8%B1%A1/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">行业万象：为什么互联网大厂一边裁员，又一边招人</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/18/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Constructor</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/23/C%20plus%20plus/" title="C plus plus"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">C plus plus</div></div></a></div><div><a href="/2022/04/08/C++%20Learning%202/" title="C++ Learning 2"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">C++ Learning 2</div></div></a></div><div><a href="/2022/04/17/C++%20Primer%20Plus%203/" title="C++ Learning 3"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-17</div><div class="title">C++ Learning 3</div></div></a></div><div><a href="/2022/04/18/cstdlib%20%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="cstdlib库"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">cstdlib库</div></div></a></div><div><a href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">C++ Learning</div></div></a></div><div><a href="/2022/04/18/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" title="Constructor"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">Constructor</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.</span> <span class="toc-text">第十二章  类和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">动态内存和类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8new%E6%97%B6%E5%BA%94%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">在构造函数中使用new时应注意的事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">第十三章  类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">一个简单的基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9Aprotected"><span class="toc-number">2.2.</span> <span class="toc-text">访问控制：protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-C-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">第十四章  C++中的代码重用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.1.</span> <span class="toc-text">类模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">4.</span> <span class="toc-text">第十五章  友元、异常和其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">4.2.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">第十六章  string类和标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81string%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">1、string类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">2、智能指针模板类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">5.3.</span> <span class="toc-text">3、标准模板库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4、泛型编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">5、容器种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">6、算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-number">5.7.</span> <span class="toc-text">7、其他库</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/Qt%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%87%AA%E5%88%B6Wireshark/" title="Qt项目：自制Wireshark"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt项目：自制Wireshark"/></a><div class="content"><a class="title" href="/2022/08/09/Qt%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%87%AA%E5%88%B6Wireshark/" title="Qt项目：自制Wireshark">Qt项目：自制Wireshark</a><time datetime="2022-08-09T15:22:32.533Z" title="Created 2022-08-09 23:22:32">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/04/Office%E4%B8%8B%E8%BD%BD%E5%90%88%E9%9B%86/" title="Office下载合集"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Office下载合集"/></a><div class="content"><a class="title" href="/2022/08/04/Office%E4%B8%8B%E8%BD%BD%E5%90%88%E9%9B%86/" title="Office下载合集">Office下载合集</a><time datetime="2022-08-04T13:59:51.230Z" title="Created 2022-08-04 21:59:51">2022-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/03/Qt%E9%A1%B9%E7%9B%AEdemo%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%9C%A8ui%E7%95%8C%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA/" title="Qt项目demo：数据在ui界面上显示"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt项目demo：数据在ui界面上显示"/></a><div class="content"><a class="title" href="/2022/08/03/Qt%E9%A1%B9%E7%9B%AEdemo%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%9C%A8ui%E7%95%8C%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA/" title="Qt项目demo：数据在ui界面上显示">Qt项目demo：数据在ui界面上显示</a><time datetime="2022-08-03T14:52:31.613Z" title="Created 2022-08-03 22:52:31">2022-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/06/Qmake%20VS%20Cmake/" title="Qmake VS Cmake"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qmake VS Cmake"/></a><div class="content"><a class="title" href="/2022/05/06/Qmake%20VS%20Cmake/" title="Qmake VS Cmake">Qmake VS Cmake</a><time datetime="2022-05-06T02:36:03.351Z" title="Created 2022-05-06 10:36:03">2022-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/06/Qt%EF%BC%9AMinGW%20%E4%B8%8EMSVC%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Qt： MinGW 与 MSVC的区别"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt： MinGW 与 MSVC的区别"/></a><div class="content"><a class="title" href="/2022/05/06/Qt%EF%BC%9AMinGW%20%E4%B8%8EMSVC%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Qt： MinGW 与 MSVC的区别">Qt： MinGW 与 MSVC的区别</a><time datetime="2022-05-06T01:42:36.943Z" title="Created 2022-05-06 09:42:36">2022-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>