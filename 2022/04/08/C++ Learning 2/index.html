<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ Learning 2 | CentLabs</title><meta name="keywords" content="C++"><meta name="author" content="Cappuccino"><meta name="copyright" content="Cappuccino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第五章  循环和关系表达式5.1 for循环使用for循环访问字符串123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&amp;#123;    cout &lt;&lt; &quot;Enter a word: &quot;;    string word;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Learning 2">
<meta property="og:url" content="https://centlabs.github.io/2022/04/08/C++%20Learning%202/index.html">
<meta property="og:site_name" content="CentLabs">
<meta property="og:description" content="第五章  循环和关系表达式5.1 for循环使用for循环访问字符串123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&amp;#123;    cout &lt;&lt; &quot;Enter a word: &quot;;    string word;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-08T11:30:13.593Z">
<meta property="article:modified_time" content="2022-04-08T12:26:43.346Z">
<meta property="article:author" content="Cappuccino">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centlabs.github.io/2022/04/08/C++%20Learning%202/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Learning 2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-08 20:26:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CentLabs</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ Learning 2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-08T11:30:13.593Z" title="Created 2022-04-08 19:30:13">2022-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-08T12:26:43.346Z" title="Updated 2022-04-08 20:26:43">2022-04-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ Learning 2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章  循环和关系表达式"></a>第五章  循环和关系表达式</h3><h4 id="5-1-for循环"><a href="#5-1-for循环" class="headerlink" title="5.1 for循环"></a>5.1 for循环</h4><h5 id="使用for循环访问字符串"><a href="#使用for循环访问字符串" class="headerlink" title="使用for循环访问字符串"></a>使用for循环访问字符串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a word: &quot;</span>;</span><br><span class="line">    string word;</span><br><span class="line">    cin &gt;&gt; word;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//display letters in reverse order</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = word.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)	<span class="comment">//长度减1是去掉末尾的\0	</span></span><br><span class="line">        cout &lt;&lt; word[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nByte.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter a word: animal</span><br><span class="line">lamina</span><br><span class="line">Byte.</span><br></pre></td></tr></table></figure>

<h5 id="前缀格式和后缀格式："><a href="#前缀格式和后缀格式：" class="headerlink" title="前缀格式和后缀格式："></a>前缀格式和后缀格式：</h5><p><strong>i++是后缀递增，</strong></p>
<p><strong>++i是前缀递增。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(n = lim; n &gt; 0; --n)		// 前缀</span><br><span class="line">......</span><br><span class="line">for(n = lim; n &gt; 0; n--)		// 后缀</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>从逻辑上说，在上述两种情形下，使用前缀格式和后缀格式没有任何区别。表达式的值未被使用，因此只存在副作用。在上述的例子中，使用这些运算符的表达式为完整表达式，因此将n加1和n减1的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同。</p>
<p>然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。对于内置类型的当代的编译器而言，没有什么问题。<strong>对于类而言，前缀版本的效率比后缀版本的高。</strong></p>
<p>总之，对于内置类型，采用哪种格式不会有差别；==<strong>但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高</strong>==。</p>
<h5 id="递增-递减运算符和指针"><a href="#递增-递减运算符和指针" class="headerlink" title="递增/递减运算符和指针"></a>递增/递减运算符和指针</h5><p>可以将递增运算符用于指针和基本变量。将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> arr[<span class="number">5</span>] = &#123;<span class="number">21.1</span>,<span class="number">32.8</span>,<span class="number">23.4</span>,<span class="number">45.2</span>,<span class="number">3.4</span>&#125;;</span><br><span class="line"><span class="type">double</span> *pt  = arr;	<span class="comment">// pt points to arr[0] i.e to 21.1</span></span><br><span class="line">++pt;			<span class="comment">// pt points to arr[1] i.e to 32.8</span></span><br></pre></td></tr></table></figure>

<p>可以结合使用这些运算符和<code>*运算符</code>来修改指针指向的值。前缀递增/递减和解除引用运算符的优先级相同，以从右到左的方式结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式结合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double x = *++pt;	// increment pointer,take the value; arr[2],or 23.4</span><br></pre></td></tr></table></figure>

<p>前缀运算符的从右到左的结合规则意味着<code>*++pt</code>的含义：先将++应用于pt，然后将<code>*</code>应用于被递增后的pt。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++*pt;		<span class="comment">// increment the pointed to value; i.e.,change 23.4 to 24.4</span></span><br></pre></td></tr></table></figure>

<p>意味着先取pt指向的值，然后将这个值加1。在这种情况下，pt仍然指向arr[2]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pt)++;	<span class="comment">// increment pointed-to value</span></span><br></pre></td></tr></table></figure>

<p>圆括号指出，首先对指针解除引用，得到24.4。然后，运算符++将这个值递增到25.4，pt仍然指向arr[2]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = *pt++;	<span class="comment">// dereference original location, then increment pointer</span></span><br><span class="line"><span class="comment">//先解引用，再将指针pt自增</span></span><br></pre></td></tr></table></figure>

<p>后缀运算符++的优先级更高，这意味着将运算符用于pt，而不是<code>*pt</code>，因此对指针递增。</p>
<p>然后后缀运算符意味着将对原来的地址（&amp;arr[2]）而不是递增后的新地址解除引用，因此<code>*pt++</code>的值为arr[2]，即25.4,但该语句执行完毕后，pt的值将为arr[3]的地址。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter five values:\n&quot;</span>;</span><br><span class="line">    <span class="type">double</span> number;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The sum to &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;and average to &quot;</span> &lt;&lt; sum/<span class="number">5</span> &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Please enter five values:</span><br><span class="line">Value 1:1942</span><br><span class="line">Value 2:1948</span><br><span class="line">Value 3:1957</span><br><span class="line">Value 4:1974</span><br><span class="line">Value 5:1980</span><br><span class="line">The sum to 9801</span><br><span class="line">and average to 1960.2.</span><br></pre></td></tr></table></figure>

<h5 id="C风格字符串的比较"><a href="#C风格字符串的比较" class="headerlink" title="C风格字符串的比较"></a>C风格字符串的比较</h5><p>数组名是数组的地址，同样，用引号括起来的字符串常量也是其地址。</p>
<p>C风格字符串库中的strcmp()函数来比较，该函数接受两个字符串地址作为参数，这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前，则strcmp()将返回一个负值；如果第一个字符串按字母顺序排在第二个字符串之后，则strcpm()将返回一个正数值。</p>
<p>在有些语言（如BASIC和标准Pascal）中，存储在不同长度的数组中的字符串彼此不相等。但在C风格字符串是通过结尾的空值字符定义的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> big[<span class="number">80</span>] = <span class="string">&quot;Daffy&quot;</span>;			<span class="comment">// 5 letters plus \0</span></span><br><span class="line"><span class="type">char</span> little[<span class="number">6</span>] = <span class="string">&quot;Daffy&quot;</span>;		<span class="comment">// 5 letters plus \0</span></span><br></pre></td></tr></table></figure>

<p>虽然不能用关系运算符比较字符串，但却可以用它们来比较字符，因为字符实际上是整型。</p>
<p>因此下面的代码可以用来显示字母表中的字符，至少对于ASCII字符集和Unicode字符集来说是有效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ch = <span class="string">&#x27;a&#x27;</span>;ch &lt;= <span class="string">&#x27;z&#x27;</span>;ch++)</span><br><span class="line">    cout &lt;&lt; ch;</span><br></pre></td></tr></table></figure>

<p>程序清单：<br>例如：在for循环的测试条件中使用了strcmp()。该程序显示一个单词，修改其字母，然后再次显示这个单词，这样循环往复，查到strcmp()确定该单词与字符串”matc”相同为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>		<span class="comment">// prototype for strcmp()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> word[<span class="number">5</span>] = <span class="string">&quot;?ate&quot;</span>;		<span class="comment">// or string word = &quot;?ate&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;<span class="built_in">strcmp</span>(word,<span class="string">&quot;mate&quot;</span>);ch++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">        word[<span class="number">0</span>] = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After loop end,word is &quot;</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">?ate</span><br><span class="line">aate</span><br><span class="line">bate</span><br><span class="line">cate</span><br><span class="line">date</span><br><span class="line">eate</span><br><span class="line">fate</span><br><span class="line">gate</span><br><span class="line">hate</span><br><span class="line">iate</span><br><span class="line">jate</span><br><span class="line">kate</span><br><span class="line">late</span><br><span class="line">After loop end,word is mate</span><br></pre></td></tr></table></figure>

<p>程序说明：</p>
<p>strcmp()判断出两个字符串不相同，测试就继续进行，最显而易见的测试是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(word,<span class="string">&quot;mate&quot;</span>) = <span class="number">0</span>;	</span><br></pre></td></tr></table></figure>

<p>如果字符串不相等，则该语句的值为1（true）。如果字符串相等，则语句的值为0（false）。</p>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>C++为类型建立别名的方式有两种。一种是使用预处理器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE char;	<span class="comment">// preprocessor replaces BYTE with char</span></span></span><br></pre></td></tr></table></figure>

<p>这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。</p>
<p>第二种方法是使用C++（和C）的关键字typedef来创建别名。</p>
<p>例如：要将byte作为char的别名，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> byte;		<span class="comment">// make byte an alias for char</span></span><br></pre></td></tr></table></figure>

<p>通用格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typeName aliasName;</span><br></pre></td></tr></table></figure>

<p>换句话说，如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。</p>
<p>例如：要让byte_pointer成为char指针的别名，<strong>可将byte_pointer声明为char指针</strong>，然后在前面加上typedef：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *  byte_pointer;	<span class="comment">// pointer to char type</span></span><br></pre></td></tr></table></figure>

<p>相比于#define，使用typedef是一种更佳的选择，有时候，也是唯一的选择。</p>
<p>注意：==typedef不会创建新类型，而只是为已有的类型建立一个新名称==。如果将word作为int的别名，则cout将把word类型的值视为int类型。</p>
<h4 id="5-2-基于范围的for循环（C-11）"><a href="#5-2-基于范围的for循环（C-11）" class="headerlink" title="5.2  基于范围的for循环（C++11）"></a>5.2  基于范围的for循环（C++11）</h4><p>C++11 新增了一种循环：基于范围（range-based）的for循环。</p>
<p>这简化了一种常见的循环任务：对于数组（或容器类，如vector和array）的每个元素执行相同的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>,<span class="number">10.99</span>,<span class="number">6.87</span>,<span class="number">7.99</span>,<span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> x : prices)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素，每个元素占据一行。总之，该循环显示数组中的每个值。</p>
<p>要修改数组的元素，需要使用不同的循环变量语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span> &amp;x : prices)</span><br><span class="line">   x = x + <span class="number">0.80</span>;		<span class="comment">// 20% of sale</span></span><br></pre></td></tr></table></figure>

<p>符号&amp;表明x是一个引用变量。这种声明让接下来的代码能够修改数组的内容。</p>
<p>还可以结合使用基于范围的for循环和初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>&#125;)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-循环和文本输入"><a href="#5-3-循环和文本输入" class="headerlink" title="5.3 循环和文本输入"></a>5.3 循环和文本输入</h4><p>循环完成的一项最常见、最重要的任务：逐字符地读取来自文件或键盘的文本。例如：可能想要编写一个能够计算输入中的字符数、行数和字数的程序。传统上，C++和C语言一样，也使用while循环来完成这类任务。</p>
<p>cin对象支持3种不同模式的单字符输入，其用户接口各不相同。</p>
<p><strong>1、使用原始的cin进行输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter characters;enter # to quit:\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;#&#x27;</span>)	<span class="comment">// test the character</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;		<span class="comment">// echo the character</span></span><br><span class="line">        ++count;		<span class="comment">// count the character</span></span><br><span class="line">        cin &gt;&gt; ch;		<span class="comment">// get the next character</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter characters;enter # to quit:</span><br><span class="line">see ken run#really fast</span><br><span class="line">seekenrun</span><br><span class="line">9 characters read</span><br></pre></td></tr></table></figure>

<p>注意：cIn在读取char值时，将忽略空格和换行符。因此输入中的空格没有被回显，也没有被包括在计数内。</p>
<p>更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序时，  在#后面输入字符的原因。按下回车键后，整个字符序列将被发送给程序，但程序在遇到#字符后将结束对输入的处理。</p>
<p><strong>2、使用cin.get(char)进行补救</strong></p>
<p> 通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符。cin所属的istream类中包含一个能够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter characters;enter # to quit:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);		<span class="comment">// use the cin.get(ch) function</span></span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;#&#x27;</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;		</span><br><span class="line">        ++count;		</span><br><span class="line">        cin.<span class="built_in">get</span>(ch);		</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter characters;enter # to quit:</span><br><span class="line">Did you use a #2 pencil?</span><br><span class="line">Did you use a</span><br><span class="line">14 characters read</span><br></pre></td></tr></table></figure>

<p>现在，该程序回显了每个字符，并将全部字符计算在内，其中包括空格。输入仍被缓冲，因此输入的字符个数仍可能比最终到达程序的要多。</p>
<p><strong>3、使用哪一个cin.get()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[ArSize];</span><br><span class="line">...</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter your name:\n&quot;</span>;</span><br><span class="line">cin.<span class="built_in">get</span>(name,ArSize).<span class="built_in">get</span>();			</span><br></pre></td></tr></table></figure>

<p>最后一行相当于两个连续的函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name,ArSize);</span><br><span class="line">cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<p>cin.get()的一个版本接受两个参数：数组名（字符串（<code>char *</code> 类型）的地址）和ArSize（int类型的整数）。其中，数组名是第一个元素的地址，因此字符数组名的类型为<code>char *</code>。</p>
<p>另一种用法：只接受一个char参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></table></figure>

<p>在C++中可以这样使用，因此该语言支持被称为函数重载的OOP特性。</p>
<p><strong>函数重载：允许创建多个同名函数，条件是它们的参数列表不同。</strong></p>
<p>例如：如果在C++中使用cin.get(name,ArSize)，则编译器将找到<code>char *</code>和int作为参数的cin.get()版本。如果使用cin.get(ch)，则编译器将使用接受一个char参数的版本。如果没有提供参数，则编译器将使用不接受任何参数的cin.get()版本。</p>
<p>函数重载允许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务。</p>
<p><strong>4、文件尾条件</strong></p>
<p>如果输入来自于文件，则可以使用一种功能更强大的技术：检测文件尾（EOF）。</p>
<p>很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现；在Windows命令提示符模式下，可以在任意位置按Ctrl+Z和Enter。用于PC的Microsoft Visual C++、Borland C++ 5.5 和 GNU C++ 都能够识别行首的Ctrl + Z，但用户必须随后按下回车键。</p>
<p>很多PC编程环境都将Ctrl + Z视为模拟的EOF。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);		<span class="comment">// attempt to read a char</span></span><br><span class="line">    <span class="keyword">while</span>(cin.<span class="built_in">fail</span>() == <span class="literal">false</span> )		<span class="comment">// test for EOF</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;		<span class="comment">// echo character</span></span><br><span class="line">        ++count;</span><br><span class="line">        cin.<span class="built_in">get</span>(ch);	</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-嵌套循环和二维数组"><a href="#5-4-嵌套循环和二维数组" class="headerlink" title="5.4  嵌套循环和二维数组"></a>5.4  嵌套循环和二维数组</h4><p>假设要打印数组所有的内容，可以用一个for循环来改变行，用另一个被嵌套的for循环来改变列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">4</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">5</span>; ++col)</span><br><span class="line">        cout &lt;&lt; maxtemps[row][col] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个值之后打印一个制表符（使用C++转义字符表示时为\t），打印完每行后，打印一个换行符。</p>
<h3 id="第六章-函数：C-的编程模块"><a href="#第六章-函数：C-的编程模块" class="headerlink" title="第六章 函数：C++的编程模块"></a>第六章 函数：C++的编程模块</h3><h4 id="6-1-函数的基本知识"><a href="#6-1-函数的基本知识" class="headerlink" title="6.1  函数的基本知识"></a>6.1  函数的基本知识</h4><p>自定义函数时，需要定义函数、提供函数原型和调用函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple</span><span class="params">()</span></span>;			<span class="comment">// function prototype</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() will call the simple() function:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">simple</span>();			<span class="comment">// function call</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() is finished with the simple() function.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I&#x27;m but a simple function.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义函数：</strong><br>可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数。其通用格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">statement</span>(s)</span><br><span class="line">    <span class="keyword">return</span>;				<span class="comment">// optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，parameterList指定了传递给函数的参数类型和数量。</p>
<p>void函数相当于Pascal中的过程、FORTRAN中的字程序和现代BASIC中的子程序。</p>
<p>通常，可以用void函数来执行某种操作。例如，将Cheers！打印指定次数（n）的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cheers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n ;i++)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cheers! &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有返回值的函数将生成一个值，并将它返回给调用函数。这种函数的类型被声明为返回值的类型。其通用格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    statements</span><br><span class="line">        <span class="keyword">return</span> value;		<span class="comment">// value is type cast to type typeName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必须为typeName类型或可以被转换为typeName。</p>
<p>（例如，如果声明的返回值类型为double，而函数返回一个int表达式，则该int值将被强制转换为double类型）。</p>
<p>C++对于返回值的类型有一定的限制：不能是数组，但可以是其他任何类型：整数、浮点数、指针，甚至可以是结构和对象！（有趣的是，虽然C++函数不能直接返回数组，但可以将数组作为结构或对象组成部分来返回。）</p>
<p><strong>函数原型和函数调用</strong></p>
<p>我们已经熟悉了函数调用，但对函数原型可能不太熟悉，因为它经常隐藏在include文件中。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cheers</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">// prototype: no return value</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span>;	<span class="comment">// prototype: return a double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cheers</span>(<span class="number">5</span>);			<span class="comment">// function call</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Give me a number: &quot;</span>;</span><br><span class="line">    <span class="type">double</span> side;</span><br><span class="line">    cin &gt;&gt; side;</span><br><span class="line">    <span class="type">double</span> volume = <span class="built_in">cube</span>(side);		<span class="comment">// function call</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot;-foot cube has a volume of &quot;</span>;</span><br><span class="line">    cout &lt;&lt; volume &lt;&lt; <span class="string">&quot; cubic feet.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cheers</span>(<span class="built_in">cube</span>(<span class="number">2</span>));		<span class="comment">// prototype protection at work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cheers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cheers! &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cheers! Cheers! Cheers! Cheers! Cheers! </span><br><span class="line">Give me a number: 5</span><br><span class="line">A 5-foot cube has a volume of 125 cubic feet.</span><br><span class="line">Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! </span><br></pre></td></tr></table></figure>

<p><strong>为什么需要原型：</strong></p>
<p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> volume = <span class="built_in">cube</span>(side);</span><br></pre></td></tr></table></figure>

<p>首先，原型告诉编译器，cube()有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数将从这个位置取得返回值。由于原型指出了cube()的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。</p>
<p><strong>原型的语法：</strong></p>
<p>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义的函数头，并添加分号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span>;	<span class="comment">// add ; to header to get prototype</span></span><br></pre></td></tr></table></figure>

<p>然而，函数原型不要求提供变量名，有类型列表就足够了。对于cheer()的原型，该程序只提供了参数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cheers</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">// okay to drop variable names in prototype</span></span><br></pre></td></tr></table></figure>

<p>通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。</p>
<h4 id="6-2-函数参数和按值传递"><a href="#6-2-函数参数和按值传递" class="headerlink" title="6.2  函数参数和按值传递"></a>6.2  函数参数和按值传递</h4><p>C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋值给一个新的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> volume = <span class="built_in">cube</span>(side);</span><br></pre></td></tr></table></figure>

<p>cube()的函数头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure>

<p>==用于接受传递值的变量被称为形参，传递给函数的值被称为实参==。出于简化的目的，C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数。</p>
<p>在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存。这样的变量被称为局部变量。</p>
<h5 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h5><p>函数可以有多个参数，在调用函数时，只需要使用逗号将这些参数分开即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">n_chars</span>(<span class="string">&#x27;R&#x27;</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>在定义函数时，也在函数头中使用由逗号分隔的参数声明列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">n_chars</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> n)</span></span>;		<span class="comment">// two arguments</span></span><br></pre></td></tr></table></figure>

<p>该函数头指出，函数n_char接受一个char参数和一个int参数。传递给函数的值被赋给参数c和n。<strong>如果函数的两个参数的类型相同，则必须分别指定每个参数的类型</strong>，而不能像声明常规变量那样，将声明组合在一起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fifi</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span>		<span class="comment">// declare each variable separately</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fufu</span><span class="params">(<span class="type">float</span> a,b)</span>		<span class="comment">// NOT acceptable</span></span></span><br></pre></td></tr></table></figure>

<p>和其他函数一样，只需要添加分号就可以得到该函数的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">n_chars</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> n)</span></span>;	 <span class="comment">// prototype,style 1</span></span><br></pre></td></tr></table></figure>

<p>和一个参数的情况一样，原型中的变量名不必与定义中的变量名相同，而且可以省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">n_chars</span><span class="params">(<span class="type">char</span>,<span class="type">int</span>)</span></span>;	 <span class="comment">// prototype,style 2</span></span><br></pre></td></tr></table></figure>

<p>然而，提供变量名将使原型更容易理解，尤其是两个参数的类型相同时。这样，变量名可以提醒参量和参数间的对应关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">melon_density</span><span class="params">(<span class="type">double</span> weight,<span class="type">double</span> volume)</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">n_chars</span><span class="params">(<span class="type">char</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;q&#x27;</span>)					<span class="comment">// q to quit</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter an integer:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; times;</span><br><span class="line">        <span class="built_in">n_chars</span>(ch,times);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\nEnter another character or press the&quot;</span></span><br><span class="line">            <span class="string">&quot;q-key to quit: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of times is &quot;</span> &lt;&lt; times &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Byte\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">n_chars</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> n)</span>		<span class="comment">// display  c  n  times</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)				<span class="comment">// continue until n reachers 0</span></span><br><span class="line">        cout &lt;&lt; c;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter a character: W</span><br><span class="line">Enter an integer:50</span><br><span class="line">WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW</span><br><span class="line">Enter another character or press theq-key to quit: a</span><br><span class="line">Enter an integer:20</span><br><span class="line">aaaaaaaaaaaaaaaaaaaa</span><br><span class="line">Enter another character or press theq-key to quit: q</span><br><span class="line">The value of times is 20.</span><br><span class="line">Byte</span><br></pre></td></tr></table></figure>

<h5 id="另外一个接受两个参数的函数"><a href="#另外一个接受两个参数的函数" class="headerlink" title="另外一个接受两个参数的函数"></a>另外一个接受两个参数的函数</h5><p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">probability</span><span class="params">(<span class="type">unsigned</span> numbers, <span class="type">unsigned</span> picks)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> total,choices;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the total number of choices on the game card and \n&quot;</span></span><br><span class="line">        <span class="string">&quot;the number of picks allowed:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((cin &gt;&gt; total &gt;&gt; choices) &amp;&amp; choices &lt;= total)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;You have one chance in &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">probability</span>(total,choices);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; of winning.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Next two numbers(q to quit): &quot;</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bye\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">probability</span> <span class="params">(<span class="type">unsigned</span> numbers,<span class="type">unsigned</span> picks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> result  = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> n;</span><br><span class="line">    <span class="type">unsigned</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(n = numbers, p = picks; p &gt; <span class="number">0</span>; n--,p--)</span><br><span class="line">        result = result * n / p;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enter the total number of choices on the game card and</span><br><span class="line">the number of picks allowed:</span><br><span class="line">49 6</span><br><span class="line">You have one chance in 1.39838e+007 of winning.</span><br><span class="line">Next two numbers(q to quit): 51 6</span><br><span class="line">You have one chance in 1.80095e+007 of winning.</span><br><span class="line">Next two numbers(q to quit): 38 6</span><br><span class="line">You have one chance in 2.76068e+006 of winning.</span><br><span class="line">Next two numbers(q to quit): q</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>

<p>程序说明：<br>首先是形参（number 和 picks），这是在左括号前面的函数头声明的；其次是其他局部变量（result、n和p），它们是在将函数定义括起的括号内声明的。形参与其他局部变量的主要区别是，<strong>形参从调用probability（）的函数那里获得自己的值，而其他变量是从函数中获得自己的值。</strong></p>
<h4 id="6-3-函数和数组"><a href="#6-3-函数和数组" class="headerlink" title="6.3 函数和数组"></a>6.3 函数和数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span>	<span class="comment">// arr = array name , n = size</span></span></span><br></pre></td></tr></table></figure>

<p>方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数，但实际情况并非如此：arr实际上并不是数组，而是一个指针！好消息是，在编写函数的其余部分时，可以将arr看作是数组。</p>
<p>程序清单：<br>演示如同使用数组名那样使用指针的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>;		<span class="comment">// prototype</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cookies[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">sum_arr</span>(cookies,ArSize);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total cookies eaten: 255</span><br></pre></td></tr></table></figure>

<p><strong>函数如何使用指针来处理数组</strong></p>
<p>在大多数情况下，C++和C语言一样，也将数组名视为指针。==C++将数组名解释为其第一个元素的地址==。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>];		<span class="comment">// array name is address of first element</span></span><br></pre></td></tr></table></figure>

<p>该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个 数组的长度（以字节为单位）；第三，将地址运算符&amp;用于数组名时，将返回整个数组的地址。例如：&amp;cookies将返回一个32字节内存块的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">sum_arr</span>(cookies,ArSize);</span><br></pre></td></tr></table></figure>

<p>其中，cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素的类型是int，因此cookies的类型必须是int指针，即<code>int*</code>。这表明，正确的函数头应该是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">sum_arr</span>(<span class="type">int</span> * arr, <span class="type">int</span> n)		</span><br></pre></td></tr></table></figure>

<p>其中用<code>int * arr</code>替换了int arr[ ]。这证明这两个函数头都是正确的，因为在C++中，<strong>当（且仅当）用于函数头或函数原型中，<code>int * arr</code>和int arr[ ]的含义才是相同的</strong>。它们都意味着arr是一个int指针。然而，数组表示法（int arr[ ]）提醒用户，arr不仅指向int，还指向int数组的第一个int。当指针指向数组的第一个元素时，使用数组表示法；而当指针指向一个独立的值时，使用指针表示法。注意：在其他上下文中，<code>int * arr</code>和int arr[ ]的含义并不相同。例如：不能在函数体中使用int tip[ ]来声明指针。</p>
<p>鉴于变量arr实际上就是一个指针，函数的其余部分是合理的。同数组名和指针一样，也可以用方括号表示法来访问数组元素。无论arr是指针还是数组名，表达式arr[3]都指的是数组的第4个元素。就目前而言，下面两个是恒等式，将不会有任何的坏处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(arr + i)		<span class="comment">// values in two notations</span></span><br><span class="line">&amp;arr[i] == arr + i			<span class="comment">// addresses int two notation</span></span><br></pre></td></tr></table></figure>

<p>记住，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。<strong>对于遍历数组而言，使用指针加法和数组下标时等效的。</strong></p>
<p><strong>将数组作为参数意味着什么</strong></p>
<p>实际上并没有将数组的内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。有了这些信息后，函数便可以使用原来的数组。传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">// arr告知数组地址		</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    	    <span class="comment">// arr[]与*arr相同，指出arr是指针</span></span></span><br></pre></td></tr></table></figure>

<p><strong>数组名和指针对应是件好事</strong>。==将数组地址作为参数可以节省复制整个数组所需的时间和内存==。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始的数据增加了破坏数据的风险。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>;		</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cookies[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    cout &lt;&lt; cookies &lt;&lt; <span class="string">&quot; = array address, &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span> cookies &lt;&lt; <span class="string">&quot; = sizeof cookies\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">sum_arr</span>(cookies,ArSize);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    sum = <span class="built_in">sum_arr</span>(cookies,<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First three eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot; cookies.\n&quot;</span>;</span><br><span class="line">    sum = <span class="built_in">sum_arr</span>(cookies + <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Last four eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot; cookies.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; arr &lt;&lt; <span class="string">&quot; = arr, &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span> arr &lt;&lt; <span class="string">&quot; = sizeof arr\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x61fdf0 = array address, 32 = sizeof cookies</span><br><span class="line">0x61fdf0 = arr, 8 = sizeof arr</span><br><span class="line">Total cookies eaten: 255</span><br><span class="line">0x61fdf0 = arr, 8 = sizeof arr</span><br><span class="line">First three eaters ate 7 cookies.</span><br><span class="line">0x61fe00 = arr, 8 = sizeof arr</span><br><span class="line">Last four eaters ate 240 cookies.</span><br></pre></td></tr></table></figure>

<p>注意：地址值和数组的长度随系统而异。</p>
<p>为将数组类型和元素数量告诉数组处理函数，请通过两个不同的参数来传递：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span>;		<span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>

<p>而不要试图使用方括号表示法来传递数组长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fillArray</span><span class="params">(<span class="type">int</span> arr[size])</span></span>;		<span class="comment">// No bad prototype</span></span><br></pre></td></tr></table></figure>

<p><strong>更多数组函数示例：</strong><br><strong>1、填充数组</strong></p>
<p>由于接受数组名参数的函数访问的是一个原始数组，而不是其副本，因此可以通过调用该函数将值赋给数组元素。</p>
<p>可以使用循环连续地将数值读入到数组中，但如何提早结束循环呢？一种方法是，使用一个特殊值来指定输入结束。由于所有的属性都不为负，因此可以使用负数来指出输入结束。另外，函数应对错误输入作反应，如停止输入等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fillArray</span><span class="params">(<span class="type">double</span> ar[], <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; limit;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter value #&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!cin)	<span class="comment">// bad input</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Bad input;input process terminated.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)		<span class="comment">// signal to terminate</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ar[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，代码中包含了对用户的提示。如果用户输入的是非负值，则这个值将被赋给数组，否则循环结束。如果用户输入的都是有效值，则循环将在读取最大数目的值后结束。循环完成的最后一项工作是将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后返回这个值。</p>
<p><strong>2、显示数组及用const保护数组</strong></p>
<p>创建显示数组内容的函数很简单，只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。然而，还有个很重要的问题，确保<strong>显示函数不修改原始数组</strong>。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，这是由于C++按值传递数据，而且函数使用数据的副本。然而，接受数组名的函数将使用原始数据 ，为防止函数无意中修改数组的内容，可以<strong>声明形参时使用关键字const</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该声明表明，指针arr指向的是常量数据，这意味着不能使用arr修改该数据，也就是说，可以使用像arr[0这样的值，但不能修改。注意：这并不是意味着原始数组必须是常量，而只是意味着不能在show_array()函数中使用arr来修改这些数据。因此，show_array()将数组视为只读数据。</p>
<p><strong>3、修改数组</strong></p>
<p>例如：将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">revalue</span><span class="params">(<span class="type">double</span> r,<span class="type">double</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、将上述代码组合起来</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fill_array</span><span class="params">(<span class="type">double</span> ar[], <span class="type">int</span> limit)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span>;		<span class="comment">// don&#x27;t change data</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revalue</span><span class="params">(<span class="type">double</span> r,<span class="type">double</span> ar[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> properties[Max];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">fill_array</span>(properties,Max);</span><br><span class="line">    <span class="built_in">show_array</span>(properties,size);</span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter revaluation factor: &quot;</span>;</span><br><span class="line">            <span class="type">double</span> factor;</span><br><span class="line">            <span class="keyword">while</span> (!(cin &gt;&gt; factor))	<span class="comment">// bad input</span></span><br><span class="line">            &#123;</span><br><span class="line">                cin.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Bad input;input process terminated.\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">revalue</span>(factor,properties,size);</span><br><span class="line">        	<span class="built_in">show_array</span>(properties,size);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fill_array</span><span class="params">(<span class="type">double</span> ar[], <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; limit;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter value #&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!cin)	<span class="comment">// bad input</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Bad input;input process terminated.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)		<span class="comment">// signal to terminate</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ar[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Property # &quot;</span>&lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;: $&quot;</span>;</span><br><span class="line">        cout &lt;&lt; ar[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revalue</span><span class="params">(<span class="type">double</span> r,<span class="type">double</span> ar[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ar[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Enter value #1:100000</span><br><span class="line">Enter value #2:80000</span><br><span class="line">Enter value #3:222000</span><br><span class="line">Enter value #4:240000</span><br><span class="line">Enter value #5:118000</span><br><span class="line">Property # 1: $100000</span><br><span class="line">Property # 2: $80000</span><br><span class="line">Property # 3: $222000</span><br><span class="line">Property # 4: $240000</span><br><span class="line">Property # 5: $118000</span><br><span class="line">Enter revaluation factor: 0.8</span><br><span class="line">Property # 1: $80000</span><br><span class="line">Property # 2: $64000</span><br><span class="line">Property # 3: $177600</span><br><span class="line">Property # 4: $192000</span><br><span class="line">Property # 5: $94400</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<h5 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h5><p>一种给函数提供所需信息的方法：<strong>指定元素区间（range）</strong>。可以通过传递两个指针来完成：一个指针标识数组的开头，另一种指针标识数组的结尾。例如：C++标准模板库，将区间方法广义化了。STL方法使用“超尾”概念来指定区间。也就是说，对于数组而言，标识数组结尾的参数将指向最后一个元素后面的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> elboud[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>则指针elboud和elboud + 20 定义了区间。数组名elboud指向第一个元素，elboud + 20指向数组结尾后面的一个位置。将区间传递给函数将告诉函数应处理哪些元素。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> * begin, <span class="type">const</span> <span class="type">int</span> * end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cookies[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">sum_arr</span>(cookies,cookies + ArSize);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    sum = <span class="built_in">sum_arr</span>(cookies,cookies + <span class="number">3</span>);		<span class="comment">// first 3 elements</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First three eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot; cookies.\n&quot;</span>;</span><br><span class="line">    sum = <span class="built_in">sum_arr</span>(cookies + <span class="number">4</span>,cookies + <span class="number">8</span>);		<span class="comment">// last 4 elements</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Last four eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot; cookies.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return the sum of an integer array</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> * begin, <span class="type">const</span> <span class="type">int</span> * end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * pt;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(pt = begin;pt != end; pt++)</span><br><span class="line">        total = total + *pt;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total cookies eaten: 255</span><br><span class="line">First three eaters ate 7 cookies.</span><br><span class="line">Last four eaters ate 240 cookies.</span><br></pre></td></tr></table></figure>

<p>指针cookies + ArSize 指向最后一个元素后面的一个位置（数组有ArSize个元素，因此cookies[ArSize - 1] 是最后一个元素，其地址为cookies + ArSize - 1）。因此，区间[cookies, cookies + ArSize]指向的是整个数组。</p>
<p>注意：根据指针减法规则，在sum_arr()中，<strong>表达式end - begin 是一个整数值，等于数组的元素数目。</strong></p>
<h5 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h5><p>将const 用于指针有一些微妙的地方。可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure>

<p>该声明指出，pt指向一个const int，因此不能使用pt来修改这个值。换句话来说，<code>*pt</code>的值为const，不能被修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt += <span class="number">1</span>;		<span class="comment">// invalid</span></span><br><span class="line">cin &gt;&gt; *pt;		<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p>pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个 值是常量。例如：pt指向age，而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">20</span>;		<span class="comment">// invalid</span></span><br><span class="line">age = <span class="number">20</span>;		<span class="comment">// valid</span></span><br></pre></td></tr></table></figure>

<p>以前将常规变量的地址赋给常规指针，现在若将常规的地址赋给指向const指针。出现两种可能：将const变量的地址赋给指向const的指针、将const的地址赋给常规指针。第一种是可行的，但是第二种是不可行的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> g_earth  = <span class="number">9.80</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> * pe  = &amp;g_earch;	<span class="comment">// valid</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> g_moon = <span class="number">1.63</span>;</span><br><span class="line"><span class="type">float</span> * pm = &amp;g_moon;		<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p>C++禁止将const的地址赋给非const指针。如果非要这样做，可以使用强制类型转换来突破这种限制。</p>
<p>注意：<strong>如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。</strong></p>
<p><strong>尽可能使用const</strong></p>
<p>将指针参数声明为指向常量数据的指针有两条理由：</p>
<ul>
<li>这样可以避免由于无意间修改数据而导致的编程错误；</li>
<li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。</li>
</ul>
<p>如果条件允许，则应将指针形参声明为指向const的指针。</p>
<h4 id="6-4-函数和二维数组"><a href="#6-4-函数和二维数组" class="headerlink" title="6.4  函数和二维数组"></a>6.4  函数和二维数组</h4><p>为编写将二维数组作为参数的函数。必须牢记，数组名被视为其地址，因此，相应的形参是一个指针，就像一堆数组一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> total = <span class="built_in">sum</span>(data,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>data的类型是指向由4个int组成的数组的指针，其原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> (*ar2)[<span class="number">4</span>],<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中的括号是必不可少的，因为下面的声明将声明一个由4个指向int的指针组成的数组，而不是由一个指向由4个int组成的数组的指针，另外，函数参数不能是数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ar2[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>还有另外一种格式，这种格式与上述原型的含义完全相同，但可读性更强。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> ar2[][<span class="number">4</span>],<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上述两个原型都指出，ar2是指针而不是数组。还需要注意的是，指针类型指出，它指向由4个int组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因。</p>
<p>由于参数ar2是指向数组的指针，那么如何在函数定义中使用它，最简单的方法就是将ar2看作是一个二维数组的名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> ar2[][<span class="number">4</span>],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span> ; r &lt; size; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>;c &lt; <span class="number">4</span>; c++)</span><br><span class="line">            total += ar2[r][c];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，行数被传递给size参数，但无论是参数ar2的声明或是内部for循环中，列数都是固定的：4列。</p>
<p>可以使用数组表示法的原因：由于ar2指向数组的第一个元素，因此表达式ar2+r指向编号为r的元素。因此ar2[r]是编号为r的元素。由于该元素本身就是一个由4个int组成的数组，因此ar2[r]是由4个int组成的数组的名称。将下标用于数组名将得到一个数组元素，因此<code>ar2[r][c]</code>是由4个int组成的数组中的一个元素，是一个int值。必须对指针ar2执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：<code>ar2[r][c]</code>。</p>
<p>或者也可以使用运算符* 两次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar2[r][c] == *(*(ar2 + r) + c)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ar2   				<span class="comment">// pointer to first row of an array of 4 int</span></span><br><span class="line">ar2 + r				<span class="comment">// pointer to row r (an array of 4 int )</span></span><br><span class="line">*(ar2 + r)	<span class="comment">// row r (an array of 4 int ) ，hence the name of an array</span></span><br><span class="line">    		<span class="comment">// thus a pointer to the first int in the row ,i.e.,ar2[r]</span></span><br><span class="line">*(ar2 + r) + c		<span class="comment">// pointer int number c in row r,i.e.,ar2[r] + c</span></span><br><span class="line">*(*(ar2 + r) + c)  	<span class="comment">// value of int number c in row r,i.e. ar2[r][c]</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-函数和C-风格字符串"><a href="#6-5-函数和C-风格字符串" class="headerlink" title="6.5  函数和C-风格字符串"></a>6.5  函数和C-风格字符串</h4><p>C-风格字符串由一系列字符组成，以空值字符结尾。将字符串作为参数时意味着传递的是地址，但可以使用const来禁止对字符串参数进行修改。</p>
<h5 id="将C-风格字符串作为参数的函数"><a href="#将C-风格字符串作为参数的函数" class="headerlink" title="将C-风格字符串作为参数的函数"></a>将C-风格字符串作为参数的函数</h5><p>假设要将字符串作为参数传递给函数，则表示字符串的方式有三种：</p>
<ul>
<li>char 数组；</li>
<li>用引号括起的字符串常量（也称字符串字面值）；</li>
<li>被设置为字符串的地址的char指针</li>
</ul>
<p>上述3种选择的类型都是char指针（准确地说是<code>char *</code>），因此可以将其作为字符串处理函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ghost[<span class="number">15</span>] = <span class="string">&quot;galloping&quot;</span>;</span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;galumphing&quot;</span>;</span><br><span class="line"><span class="type">int</span> n1 = <span class="built_in">strlen</span>(ghost);			<span class="comment">// ghost is &amp;ghost[0]</span></span><br><span class="line"><span class="type">int</span> n2 = <span class="built_in">strlen</span>(str);			<span class="comment">// pointer to char</span></span><br><span class="line"><span class="type">int</span> n3 = <span class="built_in">strlen</span>(<span class="string">&quot;gamboling&quot;</span>);	<span class="comment">// address of string</span></span><br></pre></td></tr></table></figure>

<p>可以说是将字符串作为参数来传递，但实际传递的是字符第一个字符的地址。这意味着字符串函数原型应将其表示字符串的形参声明为<code>char *</code>类型。</p>
<p>C-风格字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符（包含字符，但不以空值字符结尾的char数组只是数组，而不是字符串）。这意味着不必将字符串长度作为</p>
<p>参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">c_in_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> mmm[<span class="number">15</span>] = <span class="string">&quot;minimum&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * wail = <span class="string">&quot;ululate&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ms = <span class="built_in">c_in_str</span>(mmm,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> us = <span class="built_in">c_in_str</span>(wail,<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; ms &lt;&lt; <span class="string">&quot; m characters in &quot;</span> &lt;&lt; mmm &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; us &lt;&lt; <span class="string">&quot; u characters in &quot;</span> &lt;&lt; wail &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">c_in_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str)			<span class="comment">// quit when * str is &#x27;\0&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch)</span><br><span class="line">            count++;</span><br><span class="line">        str++;				<span class="comment">// move pointer to next char</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 m characters in minimum</span><br><span class="line">2 u characters in ululate</span><br></pre></td></tr></table></figure>

<p>c_in_str()函数不应修改原始字符串，因此它在声明形参str时使用了限定符const。这样，如果错误地址函数修改了字符串的内容，编译器将捕获这种错误。</p>
<p><strong>处理字符串中字符的标准方式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(*str)</span><br><span class="line">&#123;</span><br><span class="line">    statements</span><br><span class="line">    str++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str最初指向字符串的第一个字符，因此<code>*str</code>表示的是第一个字符。例如：第一次调用该函数后，<code>*str</code>的值将为m——“minimum”的第一个字符。只要字符不为空值字符（\0），<code>*str</code>就为非零值，因此循环将继续。在每轮循环的结尾处，<strong>表达式str++将指针增加一个字节，使之指向字符串的下一个字符</strong>。最终，str将指向结尾的空值字符，使得<code>*str</code>等于0——空值字符的数字编码，从而结束循环。</p>
<h5 id="返回C-风格字符串的函数"><a href="#返回C-风格字符串的函数" class="headerlink" title="返回C-风格字符串的函数"></a>返回C-风格字符串的函数</h5><p>==函数无法返回一个字符串，但是可以返回字符串的地址==，这样做效率更高。例如：下面程序定义一个buildstr()的函数，该函数返回一个指针。该函数接受两个参数：一个字符和一个数字。函数使用new创建一个长度与数字参数相等的字符串，然后将每个元素都初始化为该字符，然后，返回指向新字符串的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">buildstr</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> n)</span></span>;		<span class="comment">// prototype</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; times;</span><br><span class="line">    <span class="type">char</span> *ps = <span class="built_in">buildstr</span>(ch,times);</span><br><span class="line">    cout &lt;&lt; ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] ps;							<span class="comment">// free memory</span></span><br><span class="line">    ps = <span class="built_in">buildstr</span>(<span class="string">&#x27;+&#x27;</span>,<span class="number">20</span>);					<span class="comment">// reuse pointer</span></span><br><span class="line">    cout &lt;&lt; ps &lt;&lt; <span class="string">&quot; DONE &quot;</span> &lt;&lt; ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] ps;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">buildstr</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数使用new创建一个长度与数字参数相等的字符串</span></span><br><span class="line">    <span class="type">char</span> * pstr = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];	</span><br><span class="line">    pstr[n] = <span class="string">&#x27;\0&#x27;</span>;							<span class="comment">// terminate string</span></span><br><span class="line">    <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">        pstr[n] = c;						<span class="comment">// fill rest of string</span></span><br><span class="line">    <span class="keyword">return</span> pstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a character: V</span><br><span class="line">Enter an integer: 46</span><br><span class="line">VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV</span><br><span class="line">++++++++++++++++++++ DONE ++++++++++++++++++++</span><br></pre></td></tr></table></figure>

<p>程序说明：==要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符==。该函数请求分配n+1个字节的内存来存储该字符串，并将最后一个字符设置为空值字符，然后从后向前对数组进行填充。</p>
<p>下面的循环将循环n次，直到n减少为0，这将填充n个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    ptsr[n] = c;</span><br></pre></td></tr></table></figure>

<p>在最后一轮循环开始时，n的值为1。由于n是先使用这个值，然后将其递减，因此while循环测试条件将对1和0进行比较，发现测试为true，循环继续。测试后，函数将n减为0，因此pstr[0]是最后一个被设置为c的元素。之所以从后向前（而不是从前向后）填充字符串，是为了避免使用额外的变量。</p>
<p>从前向后填充代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    pstr[i++] = c;</span><br></pre></td></tr></table></figure>

<p>注意：变量pstr的作用域为buildstr函数内，因此该函数结束时，pstr（而不是字符串）使用的内存将被释放。但由于函数返回了pstr的值，因此程序仍然可以通过main()中的指针ps来访问新建的字符串。</p>
<h4 id="6-6-函数和结构"><a href="#6-6-函数和结构" class="headerlink" title="6.6  函数和结构"></a>6.6  函数和结构</h4><p>现在将注意力从数组到结构。<strong>为结构编写函数比为数组编写函数简单得多</strong>。虽然结构变量和数组一样，都可以存储多个数据项，但在涉及到函数时，结构变量的行为更接近于基本的单值变量。也就是说，与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。可以将一个结构赋给另外一个结构，同样，也可以按值传递结构，就像普通变量那样。在这种情况下，函数将使用原始结构的副本。另外，函数也可以返回结构。与数组名（数组第一个元素的地址）不同的是，**结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;**。在C语言和C++中，都使用==符号&amp;来表示地址运算符==；另外，C++还使用该运算符来表示引用变量。</p>
<h5 id="1、传递和返回结构："><a href="#1、传递和返回结构：" class="headerlink" title="1、传递和返回结构："></a>1、传递和返回结构：</h5><p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">travel_time</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hours;</span><br><span class="line">    <span class="type">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mins_per_hr = <span class="number">60</span>;</span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1,travel_time t2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    travel_time day1 = &#123;<span class="number">5</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    travel_time day2 = &#123;<span class="number">4</span>,<span class="number">55</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    travel_time trip = <span class="built_in">sum</span>(day1,day2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Two-day total: &quot;</span>;</span><br><span class="line">    <span class="built_in">show_time</span>(trip);</span><br><span class="line">    </span><br><span class="line">    travel_time day3 = &#123;<span class="number">4</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Three-day total: &quot;</span>;</span><br><span class="line">    <span class="built_in">show_time</span>(<span class="built_in">sum</span>(trip,day3));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1,travel_time t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    travel_time total;</span><br><span class="line">    total.mins = (t1.mins + t2.mins) % Mins_per_hr;</span><br><span class="line">    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span></span><br><span class="line">        &lt;&lt; t.mins &lt;&lt; <span class="string">&quot; minutes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Two-day total: 10 hours, 40 minutes</span><br><span class="line">Three-day total: 15 hours, 12 minutes</span><br></pre></td></tr></table></figure>

<p>其中，<strong>travel_time就像是一个标准的类型名，可被用来声明变量、函数的返回值和函数的参数类型</strong>。由于total和t1变量是travel_time结构，因此可以对它们使用句点成员运算符。由于sum（）函数返回travel_time结构，因此可以将其用作show_time()函数的参数。</p>
<h5 id="2、另一个处理结构的函数示例"><a href="#2、另一个处理结构的函数示例" class="headerlink" title="2、另一个处理结构的函数示例"></a>2、另一个处理结构的函数示例</h5><p>介绍个处理空间，而不是时间的案例。具体地说，这个例子将定义两个结构，用于表示两种不同的描述位置的方法，然后开发一个函数，将一种格式转换为另一种格式，并显示结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// structure declarations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">polar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distance;	<span class="comment">// distance from origin</span></span><br><span class="line">    <span class="type">double</span> angle;		<span class="comment">// direction from origin</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;		<span class="comment">// horizontal distance from origin</span></span><br><span class="line">    <span class="type">double</span> y;		<span class="comment">// vertical distance from origin</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototypes</span></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(polar dapos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rect rplace;</span><br><span class="line">    rect pplace;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the x and y values: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)</span><br><span class="line">    &#123;</span><br><span class="line">        pplace = <span class="built_in">rect_to_polar</span>(rplace);</span><br><span class="line">        <span class="built_in">show_polar</span>(pplace);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Next two numbers (q to quit): &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert rectangular to plar coordinates</span></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    polar answer;</span><br><span class="line">    </span><br><span class="line">    answer.distance = <span class="built_in">sqrt</span>(xypos.x*xypos.x+xypos.y*xypos.y);</span><br><span class="line">    answer.angle = <span class="built_in">atan2</span>(xypos.y,xypos.x);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show polar coordinates,converting angle to degree</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span> <span class="params">(polar dapos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Rad_to_deg = <span class="number">57.29577951</span>;</span><br><span class="line">    </span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;distance = &quot;</span> &lt;&lt; dapos.distance;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, angle = &quot;</span> &lt;&lt; dapos.angle * Rad_to_deg;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; degrees\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序说明：<br>该程序如何使用cin来控制while循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; rplace.x &gt;&gt; rplace.y)</span><br></pre></td></tr></table></figure>

<p>cin是istream类的一个对象。抽取运算符（&gt;&gt;）被设计成使得cin &gt;&gt; rplace.x也是一个istream对象。类运算符是使用函数实现的，使用cin &gt;&gt; rplace.x时，程序将调用一个函数，该函数返回一个istream值。整个while循环的测试表达式的最终结果为cin，而cin被用于测试表达式中时，将根据输入是否成功，被转换为bool值true或者false。在该程序中，cin期望用户输入两个数字，如果用户输入了q，cin&gt;&gt;将知道q不是数字，从而将q留在输入队列中，并返回一个将被转换为false的值，导致循环结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter value #&quot;</span> &lt;&lt; (i+<span class="number">1</span>)&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; temp;</span><br><span class="line">    <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ar[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要提早结束该循环，可以输入一个负值。将cin&gt;&gt;用作测试条件消除了这种限制，因为它接受任何有效的数字输入。在需要使用循环来输入数字时，可以采用这种方式。==如果程序在输入循环后还需要进行输入，则必须使用cin.clear()重置输入==，然后还可能需要通过读取不合法的输入来丢弃它们。</p>
<h5 id="3、传递结构的地址"><a href="#3、传递结构的地址" class="headerlink" title="3、传递结构的地址"></a>3、传递结构的地址</h5><p>假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。重新编写show_polar()函数，需要修改三个地方：</p>
<ul>
<li>调用函数时，将结构的地址（&amp;pplace）而不是结构本身（pplace）传递给它；</li>
<li>将形参声明为指向polar的指针，即<code>polar*</code> 类型。由于函数不应该修改结构，因此使用const修饰符；</li>
<li>由于形参是指针而不是结构，因此应使用间接运算符（-&gt;），而不是成员运算符（句点）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span> <span class="params">(<span class="type">const</span> polar * pda)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Rad_to_deg = <span class="number">57.29577951</span>;</span><br><span class="line">    </span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;distance = &quot;</span> &lt;&lt; pda-&gt;distance;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, angle = &quot;</span> &lt;&lt; pda-&gt;angle * Rad_to_deg;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; degrees\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-函数和string对象"><a href="#6-7-函数和string对象" class="headerlink" title="6.7  函数和string对象"></a>6.7  函数和string对象</h4><p>虽然C- 风格字符串和string对象的用途几乎相同，但与数组相比，<strong>string对象与结构的更相似</strong>。例如：可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。如果需要使用多个字符串，可以声明一个string对象数组，而不是二维char数组。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> string sa[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string list[SIZE];		<span class="comment">// an array holding 5 string object</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your &quot;</span> &lt;&lt; SIZE &lt;&lt; <span class="string">&quot; favorite astronomical sights:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin,list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your list : \n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(list,SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> string sa[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sa[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Enter your 5 favorite astronomical sights:</span><br><span class="line">1:Orion Nebula</span><br><span class="line">2:M13</span><br><span class="line">3:Saturn</span><br><span class="line">4:Jupiter</span><br><span class="line">5:Moon</span><br><span class="line">Your list :</span><br><span class="line">1: Orion Nebula</span><br><span class="line">2: M13</span><br><span class="line">3: Saturn</span><br><span class="line">4: Jupiter</span><br><span class="line">5: Moon</span><br></pre></td></tr></table></figure>

<p><strong>如果需要string数组，只需要使用通常的数组声明格式即可</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string list[SIZE];		<span class="comment">// an array holding 5 string object</span></span><br></pre></td></tr></table></figure>

<p>这样，数组list的每个元素都是一个string对象，可以如此使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,list[i]);</span><br></pre></td></tr></table></figure>

<p>==getline()函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中==。</p>
<p>同样，形参sa是一个指向string对象的指针，因此sa[i]是一个string对象，可以这样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sa[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>string与char的区别</strong>：</p>
<p>string 是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\0’;</p>
<p>char 是定义一个字符，存储一个字符，占一个字节。</p>
<p>char数组可以表示字符串，比如：char[10]就是一个字符串</p>
<h4 id="6-8-函数与array对象"><a href="#6-8-函数与array对象" class="headerlink" title="6.8  函数与array对象"></a>6.8  函数与array对象</h4><p> 在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。例如：可按值将对象传递给函数，在这种情况下，函数处理的是原始对象的副本。另外，==也可以传递指向对象的指针，这让函数能够操作原始对象==。</p>
<p>请注意：模板array并非只能存储基本数据类型，它还可以存储类的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constant data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Seasons = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> std::array&lt;std::string,Seasons&gt; Snames = &#123;<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;Fall&quot;</span>,<span class="string">&quot;Winter&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to modify array object</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(std::array&lt;<span class="type">double</span>,Seasons&gt; *pa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function that uses array object without modifying it</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::array&lt;<span class="type">double</span>,Seasons&gt; da)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">double</span>,Seasons&gt; expenses;</span><br><span class="line">    <span class="built_in">fill</span>(&amp;expenses);</span><br><span class="line">    <span class="built_in">show</span>(expenses);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span> <span class="params">(std::array&lt;<span class="type">double</span>,Seasons&gt; *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Seasons;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; Snames[i] &lt;&lt; <span class="string">&quot; expenses: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; (*pa)[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">(std::array&lt;<span class="type">double</span>,Seasons&gt; da)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nEXPENSES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Seasons;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; Snames[i] &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; da[i] &lt;&lt; endl;</span><br><span class="line">        total += da[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total Expenses: $&quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Enter Spring expenses: 212</span><br><span class="line">Enter Summer expenses: 255</span><br><span class="line">Enter Fall expenses: 208</span><br><span class="line">Enter Winter expenses: 244</span><br><span class="line"></span><br><span class="line">EXPENSES</span><br><span class="line">Spring: $212</span><br><span class="line">Summer: $255</span><br><span class="line">Fall: $208</span><br><span class="line">Winter: $244</span><br><span class="line">Total Expenses: $919</span><br></pre></td></tr></table></figure>

<p>程序说明：<br>由于const array 对象Sname是在所有函数之前声明的，因此可后面的任何函数定义中使用它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; (*pa)[i];</span><br></pre></td></tr></table></figure>

<p>pa是一个指向array&lt;double,4&gt;对象的指针，因此<code>*pa</code>为这种对象，而<code>（*pa）[i]</code>是该对象的一个元素。由于运算符优先级的影响，其中的括号必不可少。</p>
<h4 id="6-9-递归"><a href="#6-9-递归" class="headerlink" title="6.9  递归"></a>6.9  递归</h4><p>C++函数有一种有趣的特点——可以调用自己（然而，与C语言不同的是，C++ 不允许main（）调用自己），这种功能被称为递归。</p>
<h5 id="1、包含一个递归调用的递归"><a href="#1、包含一个递归调用的递归" class="headerlink" title="1、包含一个递归调用的递归"></a>1、包含一个递归调用的递归</h5><p>如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中。</p>
<p>例如：void类型的递归函数recurs()的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recurs</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">statements1</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(test)</span></span></span><br><span class="line"><span class="function">        	<span class="title">recurs</span><span class="params">(arguments)</span></span></span><br><span class="line"><span class="function">    statements2</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>test最终将为false，调用链将断开。只要if语句为true，每个recurs()调用都将执行statements1，然后再调用recurs()，而不会执行statements2。当if语句为false时，当前调用将执行statements2。当前调用结束后，程序控制权将返回给调用它的recurs()，而该recurs()将执行其statements2部分，然后结束，并将控制权返回给前一个调用，依次类推。</p>
<p>因此，如果recurs()进行了5次递归调用，则第一个statements1部分将按函数调用的顺序执行5次，然后statements2部分将以与函数调用相反的顺序执行5次。进入5层递归后，程序将沿进入的路径返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countdown</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">countdown</span>(<span class="number">4</span>);			<span class="comment">// call the recursive function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countdown</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Counting down ... &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">countdown</span>(n - <span class="number">1</span>);			<span class="comment">// function calls itself</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;:Kaboom!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Counting down ... 4</span><br><span class="line">Counting down ... 3</span><br><span class="line">Counting down ... 2</span><br><span class="line">Counting down ... 1</span><br><span class="line">Counting down ... 0</span><br><span class="line">0:Kaboom!</span><br><span class="line">1:Kaboom!</span><br><span class="line">2:Kaboom!</span><br><span class="line">3:Kaboom!</span><br><span class="line">4:Kaboom!</span><br></pre></td></tr></table></figure>

<p>注意：每个递归调用都创建自己的一套变量，因此当程序到达第5次调用时，将有5个独立的n变量，其中每个变量的值都不同。</p>
<p>为验证这一点，可以修改程序，使之显示n的地址和值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Counting down ... &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; (n at &quot;</span> &lt;&lt; &amp;n &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&quot;: Kaboom!&quot;</span> &lt;&lt; <span class="string">&quot;          (n at &quot;</span> &lt;&lt; &amp;n &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Counting down ... 4 (n at 0x61fe00)</span><br><span class="line">Counting down ... 3 (n at 0x61fdd0)</span><br><span class="line">Counting down ... 2 (n at 0x61fda0)</span><br><span class="line">Counting down ... 1 (n at 0x61fd70)</span><br><span class="line">Counting down ... 0 (n at 0x61fd40)</span><br><span class="line">0: Kaboom!          (n at 0x61fd40)</span><br><span class="line">1: Kaboom!          (n at 0x61fd70)</span><br><span class="line">2: Kaboom!          (n at 0x61fda0)</span><br><span class="line">3: Kaboom!          (n at 0x61fdd0)</span><br><span class="line">4: Kaboom!          (n at 0x61fe00)</span><br></pre></td></tr></table></figure>

<h5 id="2、包含多个递归调用的递归"><a href="#2、包含多个递归调用的递归" class="headerlink" title="2、包含多个递归调用的递归"></a>2、包含多个递归调用的递归</h5><p>在需要将一项工作不断分为两项较小的，类似的工作时，递归非常的有用。</p>
<p>例如：考虑使用这种方法来绘制标尺的情况，标出两端，找到中点并将其标出。然后将同样的操作用于标尺的左半部分和右半部份。如果进一步细分，可将同样的操作用于当前的每一部分。递归方法有时被称为分而治之策略。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Len = <span class="number">66</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Divs = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subdivide</span><span class="params">(<span class="type">char</span> ar[],<span class="type">int</span> low ,<span class="type">int</span> high ,<span class="type">int</span> level)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ruler[Len];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; Len - <span class="number">2</span>; i++)</span><br><span class="line">        ruler[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ruler[Len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> max = Len - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    ruler[min] = ruler[max] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; ruler &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Divs;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">subdivide</span>(ruler,min,max,i);</span><br><span class="line">        cout &lt;&lt; ruler &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; Len - <span class="number">2</span>;j++)</span><br><span class="line">            ruler[j] = <span class="string">&#x27; &#x27;</span>;				<span class="comment">// reset to blank ruler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subdivide</span><span class="params">(<span class="type">char</span> ar[], <span class="type">int</span> low ,<span class="type">int</span> high , <span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">    ar[mid] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="built_in">subdivide</span>(ar, low, mid, level - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">subdivide</span>(ar, mid, high, level - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|                                                               |</span><br><span class="line">|                               |                               |</span><br><span class="line">|               |               |               |               |</span><br><span class="line">|       |       |       |       |       |       |       |       |</span><br><span class="line">|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line">| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |</span><br><span class="line">|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</span><br></pre></td></tr></table></figure>

<h4 id="6-10-函数指针"><a href="#6-10-函数指针" class="headerlink" title="6.10  函数指针"></a>6.10  函数指针</h4><p>与数据项相似，函数也有地址。==函数的地址是存储其机器语言代码的内存的开始地址==。通常，这些地址对用户而言，既不重要，也没有什么用处，但对程序而言，却很有用。例如：可以编写将另一个函数的地址作为参数的函数，这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。</p>
<h5 id="1、函数指针的基础知识"><a href="#1、函数指针的基础知识" class="headerlink" title="1、函数指针的基础知识"></a>1、函数指针的基础知识</h5><p>假设要设计一个名为estimate()的函数，估算编写指定行数的代码所需要的时间，并且希望不同的程序员都将使用该函数。对于所有的用户来说，estimate()中一部分代码都是相同的，但该函数允许每个程序员提供自己的算法来估算时间。为实现这种目标，采用的机制是，将程序员使用的算法函数的地址传递给estimate()。为此，需要完成：</p>
<ul>
<li>获取函数的地址</li>
<li>声明一个函数指针</li>
<li>使用函数指针来调用函数</li>
</ul>
<p><strong>1）获取函数的地址</strong></p>
<p>获取函数的地址很简单：只要使用函数名即可。也就是说，如果think()是一个函数，则think就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(think);		<span class="comment">// passes address of think() to process()</span></span><br><span class="line"><span class="built_in">thought</span>(<span class="built_in">think</span>());	<span class="comment">// passes return value of think() to thought()</span></span><br></pre></td></tr></table></figure>

<p>process()调用使得process()函数能够在其内部调用think()函数。thought()调用首先调用think()函数，然后将think()的返回值传递给thought()函数。</p>
<p><strong>2）声明函数指针</strong></p>
<p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，<strong>声明指向函数的指针时，也必须指定指针指向的函数类型</strong>。这意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息。</p>
<p>例如：假设编写一个估算时间的函数，其原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>

<p>则正确的指针类型声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//pf points to function that takes one int argument </span></span><br><span class="line"><span class="comment">//and that returns type double</span></span><br></pre></td></tr></table></figure>

<p>这与pam()声明类似，这是将pam替换为（<code>*pf</code>）。由于pam是函数，因此（<code>*pf</code>）也是函数。而如果（<code>*pf</code>）是函数，则pf就是函数指针。</p>
<p>提示：通常，要声明指向特定类型的函数指针，可以首先编写这种函数的原型，然后用（<code>*pf</code>）替换函数名。这样pf就是这类的函数的指针。</p>
<p>为提供正确的运算符优先级，必须在声明中使用括号将<code>*pf</code>括起。<strong>括号的优先级比<code>*</code>运算符高</strong>，因此<code>*pf(int)</code>==意味着pf（）是一个返回指针的函数==，而<code>(*pf)(int)</code>意==味着pf是一个指向函数的指针==。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);	<span class="comment">// pf points to a function that returns double</span></span><br><span class="line"><span class="comment">//指针函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> *<span class="title">pf</span><span class="params">(<span class="type">int</span>)</span></span>;	<span class="comment">// pf() a function that returns a pointer-to-double</span></span><br></pre></td></tr></table></figure>

<p>正确地声明pf后，便可以将相应函数的地址赋给它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line">pf = pam;			<span class="comment">// pf now points to the pam() function</span></span><br></pre></td></tr></table></figure>

<p>注意：pam()的特征标和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ned</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ted</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line">pf = ned;				<span class="comment">// invalid -- mismatched signature</span></span><br><span class="line">pf = ted;				<span class="comment">// invalid -- mismatched return types</span></span><br></pre></td></tr></table></figure>

<p>假设要将编写的代码行数和估算算法（如pam()函数）的地址传递给它，则原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines,<span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>第二个参数是函数指针，它指向的函数接受一个int参数，并返回一个double值。</p>
<p>要让estimate()使用pam()函数，需要将pam()的地址传递给它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">estimate</span>(<span class="number">50</span>,pam);	<span class="comment">// function call telling estimate() to use pam()</span></span><br></pre></td></tr></table></figure>

<p>显然，使用函数指针时，比较棘手的是编写原型，而传递地址则非常简单。</p>
<p><strong>3） 使用指针来调用函数</strong></p>
<p>现在进入最后一步，即使用指针来调用被指向的函数。线索来自指针声明。<code>(*pf)</code>扮演的角色与函数名相同，因此使用<code>(*pf)</code>时，只需将它看作函数名即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line">pf = pam;			</span><br><span class="line"><span class="type">double</span> x = <span class="built_in">pam</span>(<span class="number">4</span>);		<span class="comment">// call pam() using the function name</span></span><br><span class="line"><span class="type">double</span> y = (*pf)(<span class="number">5</span>);	<span class="comment">// call pam() using the pointer pf</span></span><br></pre></td></tr></table></figure>

<p>实际上，C++也允许像使用函数名那样使用pf：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> y = <span class="built_in">pf</span>(<span class="number">5</span>);  <span class="comment">// also call pam() using the pointer pf</span></span><br></pre></td></tr></table></figure>

<p>第一种格式虽然不太好看，但是给出了强有力的提示：代码正在使用函数指针。</p>
<h5 id="2、函数指针示例"><a href="#2、函数指针示例" class="headerlink" title="2、函数指针示例"></a>2、函数指针示例</h5><p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How many lines of code do you need? &quot;</span>;</span><br><span class="line">    cin &gt;&gt; code;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here&#x27;s Betsy&#x27;s estimate:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">estimate</span>(code,betsy);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here&#x27;s Pam&#x27;s estimate:\n&quot;</span>; </span><br><span class="line">    <span class="built_in">estimate</span>(code,pam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.05</span> * lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.03</span> * lns + <span class="number">0.0004</span> * lns *lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines,<span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; lines &lt;&lt; <span class="string">&quot; lines will take &quot;</span>;</span><br><span class="line">    cout &lt;&lt; (*pf)(lines) &lt;&lt; <span class="string">&quot; hour(s)\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">How many lines of code do you need? 30</span><br><span class="line">Here&#x27;s Betsy&#x27;s estimate:</span><br><span class="line">30 lines will take 1.5 hour(s)</span><br><span class="line">Here&#x27;s Pam&#x27;s estimate:</span><br><span class="line">30 lines will take 1.26 hour(s)</span><br></pre></td></tr></table></figure>

<h5 id="3、-深入探讨函数指针"><a href="#3、-深入探讨函数指针" class="headerlink" title="3、 深入探讨函数指针"></a>3、 深入探讨函数指针</h5><p>函数指针的表示可能非常的恐怖。</p>
<p>下面是一些函数的原型，它们的特征标和返回值类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>三者是等价的。但是函数定义必须提供标识符，因此需要使用const double ar[] 或者const double * ar。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> av[<span class="number">3</span>] = &#123;<span class="number">1112.3</span>, <span class="number">1542.6</span>, <span class="number">2227.9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*p1)(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span>) = f1;</span><br><span class="line">    <span class="keyword">auto</span> p2 = p1;		<span class="comment">// C++ automatic type deduction</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using pointers to function:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Address Value\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; (*p1)(av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *(*p1)(av,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p2</span>(av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *<span class="built_in">p2</span>(av,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span>) = &#123;f1,f2,f3&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pb = pa;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nUsing an array of pointers to functions:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Address Value\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; pa[i](av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *pa[i](av,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nUsing a pointer to a pointers to a function:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Address Value\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; pb[i](av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *pb[i](av,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nUsing pointers to an array of pointers:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Address Value\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> pc = &amp;pa;				<span class="comment">// C++11 automatic type deduction</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*(*pd)[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>) = &amp;pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> * pdb = (*pd)[<span class="number">1</span>](av,<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; pdb &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *pdb &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; (*(*pd)[<span class="number">2</span>])(av,<span class="number">3</span>) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *(*(*pd)[<span class="number">2</span>])(av,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> * ar,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Using pointers to function:</span><br><span class="line"> Address Value</span><br><span class="line">0x61fdc0: 1112.3</span><br><span class="line">0x61fdc0: 1112.3</span><br><span class="line"></span><br><span class="line">Using an array of pointers to functions:</span><br><span class="line"> Address Value</span><br><span class="line">0x61fdc0: 1112.3</span><br><span class="line">0x61fdc8: 1542.6</span><br><span class="line">0x61fdd0: 2227.9</span><br><span class="line"></span><br><span class="line">Using a pointer to a pointers to a function:</span><br><span class="line"> Address Value</span><br><span class="line">0x61fdc0: 1112.3</span><br><span class="line">0x61fdc8: 1542.6</span><br><span class="line">0x61fdd0: 2227.9</span><br><span class="line"></span><br><span class="line">Using pointers to an array of pointers:</span><br><span class="line"> Address Value</span><br><span class="line">0x61fdc8: 1542.6</span><br><span class="line">0x61fdd0: 2227.9</span><br></pre></td></tr></table></figure>



<p><strong>感谢 auto</strong></p>
<p>C++11 的目标之一是让C++更容易使用，从而让程序员将主要精力放在设计上而不是细节上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pc = &amp;pa;				<span class="comment">// C++11 automatic type deduction</span></span><br></pre></td></tr></table></figure>

<p>自动类型推动功能表明，编译器的角色发生了改变。在C++98中，编译器利用其知识帮助您发现错误，而在C++11中，编译器利用其知识帮助您进行正确的声明。</p>
<p>存在一个潜在的缺点，自动类型推断确保变量的类型与赋给它的初值的类型一致，但您提供的初值可能不对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pc = *pa;		<span class="comment">// oops! used *pa instead of &amp;pa</span></span><br></pre></td></tr></table></figure>

<p>该声明导致pc的类型与<code>*pa</code>一致。后面使用它时假定其类型与&amp;pa相同，这将导致编译错误。</p>
<h5 id="4、-使用typedef进行简化"><a href="#4、-使用typedef进行简化" class="headerlink" title="4、 使用typedef进行简化"></a>4、 使用typedef进行简化</h5><p>除了auto外，C++还提供了其他简化声明的工具。==关键字typedef能够创建类型的别名==：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> real;	<span class="comment">// makes real another name for double</span></span><br></pre></td></tr></table></figure>

<p>这里采用的方法是，将别名当做标识符进行声明，并在开头使用typedef。因此，可将p_fun声明为使用的函数指针类型的别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">double</span> *(*p_fun)(<span class="type">const</span> <span class="type">double</span> *, <span class="type">int</span>);	</span><br><span class="line"><span class="comment">//p_fun now a type name</span></span><br><span class="line">p_fun p1 = f1;			<span class="comment">// p1 points to the f1() function </span></span><br></pre></td></tr></table></figure>

<p>然后使用这个别名来简化代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_fun pa[<span class="number">3</span>] = &#123;f1,f2,f3&#125;;	<span class="comment">// pa an array of 3 function pointers</span></span><br><span class="line"><span class="built_in">p_fun</span> (*pd)[<span class="number">3</span>] = &amp;pa;	<span class="comment">// pd points to an array of 3 function pointers</span></span><br></pre></td></tr></table></figure>

<p>使用typedef可以减少输入量，在编写代码时不容易犯错，并让程序更容易理解。</p>
<h4 id="6-11-总结"><a href="#6-11-总结" class="headerlink" title="6.11 总结"></a>6.11 总结</h4><p>函数是C++的编程模块。要使用函数，必须提供定义和原型，并调用该函数。函数定义是实现函数的功能的代码；函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，并执行函数的代码。</p>
<p>在默认情况下，C++函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。因此，C++函数通过使用拷贝，保护了原始数据的完整性。</p>
<p>C++将数组名参数视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，因为指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。当且仅当声明函数的形参时，下面两个声明才是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeName arr[];</span><br><span class="line">typeName * arr;</span><br></pre></td></tr></table></figure>

<p>这两个声明都表明，arr是指向typeName的指针，但在编写函数代码时，可以像使用数组名那样使用arr来访问元素：arr[i]。即使在传递指针时，也可以将形参声明为const指针，来保护原始数据的完整性。由于传递数据的地址时，并不会传输有关数组长度的信息，因此通常将数组长度作为独立的参数来传递。另外，也可以传递两个指针（其中一个指向数组开头，另一个指向数组末尾的下一个元素），以指定一个范围，就像STL使用的算法一样。</p>
<p>C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是<code>char*</code>（char指针），因此被作为<code>char*</code>类型参数传递给函数。C++使用空值（\0）来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。</p>
<p>C++还提供了string类，用于表示字符串。函数可以接受string对象作为参数以及将string对象作为返回值。string类的方法size()可用于判断其存储的字符串的长度。</p>
<p>C++处理结构的方式与基本类型完全相同，这意味着可以按值传递结构，并将其用作函数返回类型。然而，如果结构非常大，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于对象。</p>
<p>C++函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。</p>
<p>C++函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。</p>
<h3 id="第七章-函数探幽"><a href="#第七章-函数探幽" class="headerlink" title="第七章  函数探幽"></a>第七章  函数探幽</h3><h4 id="7-1-C-内联函数"><a href="#7-1-C-内联函数" class="headerlink" title="7.1  C++内联函数"></a>7.1  C++内联函数</h4><p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。要了解内联函数与常规函数的区别，必须深入到程序内部。</p>
<p>编译过程的最终产品是可执行程序：由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时，将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数地址），并在函数结束时返回。</p>
<p>C++内联函数提供了另一种选择，内联函数的编译代码与其他程序代码”内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。</p>
<p>应该有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p>
<p>要使用这项特性，必须采取下述措施之一：</p>
<ul>
<li>在函数声明前加上关键字inline</li>
<li>在函数定义前加上关键字inline</li>
</ul>
<p>通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">13.0</span>;</span><br><span class="line">    a = <span class="built_in">square</span>(<span class="number">5.0</span>);</span><br><span class="line">    b = <span class="built_in">square</span>(<span class="number">4.5</span> + <span class="number">7.5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,c square = &quot;</span> &lt;&lt; <span class="built_in">square</span>(c++) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 25,b = 144</span><br><span class="line">c = 13,c square = 169</span><br><span class="line">Now c = 14</span><br></pre></td></tr></table></figure>

<p>输出表明，内联函数和常规函数一样，也是按值来传递参数的。如果参数为表达式，则函数将传递表达式的值。这使得C++的内联功能远远胜过C-语言的宏定义。</p>
<p>尽管程序没有提供独立的原型，但C++原型特性仍在起作用。这是因为在函数首次使用前出现的整个函数定义充当了原型。这意味着可以给square()传递int或者long值，将值传递给函数前，程序自动将这个值强制转换为double类型。</p>
<p>:ship:<strong>内联与宏</strong></p>
<p>inline工具是C++新增的特性。C语言使用预处理器语句#define来提供宏——内联代码的原始实现。例如：计算平方的宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure>

<p>这并不是通过传递参数实现的，而是通过文本替换来实现的——X是”参数”的符号标记。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">SQUARE</span>(<span class="number">5.0</span>);  is replaced by a = <span class="number">5.0</span> * <span class="number">5.0</span>;</span><br><span class="line">b = <span class="built_in">SQUAER</span>(<span class="number">4.5</span> + <span class="number">7.5</span>); is replaced by b = <span class="number">4.5</span> + <span class="number">7.5</span> * <span class="number">4.5</span> + <span class="number">7.5</span>;</span><br><span class="line">d = <span class="built_in">SQUARE</span>(c++);  is replaced by d = c++ * c++;</span><br></pre></td></tr></table></figure>

<p>上述示例只有第一个能正常工作。可以通过使用括号来进行改进：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure>

<p>但仍然存在这样的问题，即宏不能按值传递。即使使用新的定义，SQUARE（c++）仍将c递增两次，但是上面程序中的内联函数square()能计算c的结果，传递它，以计算其平方值，然后将c递增一次。</p>
<p>这里的目的不是演示如何编写C宏，而是要指出，如果使用C语言的宏执行了类似函数的功能，应考虑将其转换为C++内联函数。</p>
<h4 id="7-2-引用变量"><a href="#7-2-引用变量" class="headerlink" title="7.2  引用变量"></a>7.2  引用变量</h4><p>C++新增了一个复合类型：引用变量。==引用是已定义的变量的别名（另一个名称）==。</p>
<p>例如：如果将twain作为clement变量的引用，则可以交替使用twain和clement来表示该变量。</p>
<p>引用变量的主要用途是用作函数的形参，通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除了指针外，引用也可以为函数处理大型结构提供了一种非常方便的途径。同时对于设计类来说，引用也是必不可少的。</p>
<p><strong>1、创建引用变量</strong></p>
<p>C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。</p>
<p>例如：将rodents 作为 rats变量的别名，可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;	<span class="comment">// makes rodents an alias for rats</span></span><br></pre></td></tr></table></figure>

<p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的<code>char*</code>指的是指向char的指针一样，==int &amp; 指 的是指向int的引用==。上述引用声明允许将rats和rodents互换，它们<strong>指向相同的值和内存单元</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rats = <span class="number">101</span>;</span><br><span class="line">    <span class="type">int</span> &amp; rodents = rats;		<span class="comment">// rodents is a reference</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;</span><br><span class="line">    rodents++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;,rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rats = 101,rodents = 101</span><br><span class="line">rats = 102,rodents = 102</span><br><span class="line">rats address = 0x61fe14, rodents address = 0x61fe14</span><br></pre></td></tr></table></figure>

<p>请注意：下述语句中的&amp;运算符不是地址运算符，而是将rodents的类型声明为 <code>int &amp;</code>，即指向int变量的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure>

<p>但下面语句中的&amp;运算符是地址运算符，其中&amp;rodents表示rodents引用的变量的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>由此可知，rats和rodents的值和地址都相同。将rodents加1将影响这两个变量。更准确地说，rodents++操作是将一个有两个名称的变量加1.</p>
<p>指针和引用之间是有区别的。例如：可以创建指向rats的引用和指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rats = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;	<span class="comment">// rodents a reference</span></span><br><span class="line"><span class="type">int</span> * prats = &amp;rats;    <span class="comment">// prats a pointer</span></span><br></pre></td></tr></table></figure>

<p>这样，表达式rodents和 <code>*prats</code> 都可以同rats互换，而表达式&amp;rodents和prats都可以同&amp;rats互换。从这一点来说，引用看上去像是伪装表示的指针（其中，<code>*解除引用运算符</code>被隐式理解 ）。实际上，引用还是不同于指针的，除了表示法不同外，还有其它的区别。</p>
<p>例如：必须在声明引用的同时将其初始化。而不能像指针那样，先声明，再赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rat;</span><br><span class="line"><span class="type">int</span> &amp; rodent;</span><br><span class="line">rodent = rat;		<span class="comment">// No,you can&#x27;t do this</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>必须在声明引用变量时进行初始化</strong>。</p>
<p>引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure>

<p>实际上是下述代码的伪装表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> pr = &amp; rats;</span><br></pre></td></tr></table></figure>

<p>其中，引用rodents扮演的角色与表达式<code>*pr</code>相同。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rats = <span class="number">101</span>;</span><br><span class="line">    <span class="type">int</span> &amp; rodents = rats;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>  bunnies = <span class="number">50</span>;</span><br><span class="line">    rodents = bunnies;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bunnies = &quot;</span> &lt;&lt; bunnies;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bunnies address = &quot;</span> &lt;&lt; &amp;bunnies;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rats = 101, rodents = 101</span><br><span class="line">rats address = 0x61fe14, rodents address = 0x61fe14</span><br><span class="line">bunnies = 50, rats = 50, rodents = 50</span><br><span class="line">bunnies address = 0x61fe10, rodents address = 0x61fe14</span><br></pre></td></tr></table></figure>

<p>最初，rodents引用的是rats，但随后程序试图将rodents作为bunnies的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rodents = bunnies;</span><br></pre></td></tr></table></figure>

<p>乍一看，这种意图暂时是成功的，因为rodents的值从101变成了50.但仔细研究将发现，rats也变成了50，同时rats和rodents的地址相同，而地址与bunnies的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rats = bunnies;</span><br></pre></td></tr></table></figure>

<p>也就是说，这意味着：将bunnies变量的值赋给rat变量。简而言之，<strong>可以通过初始化声明来设置引用，但不能通过赋值来设置。</strong></p>
<p><strong>2、将引用用作函数参数</strong></p>
<p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。</p>
<p>解决常见的计算机问题：交换两个变量的值，对使用引用和使用指针做一下比较。</p>
<p>交换函数必须能够修改调用程序中的变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量的副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用原始数据。另一种方法是，传递指针来访问原始数据。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapr</span><span class="params">(<span class="type">int</span> &amp; a, <span class="type">int</span> &amp; b)</span></span>;	<span class="comment">// a,b are aliases for ints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapp</span><span class="params">(<span class="type">int</span> * p, <span class="type">int</span> * q)</span></span>;	<span class="comment">// p,q are addresses of ints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;		<span class="comment">// a,b are new variables</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> wallet1 = <span class="number">300</span>;</span><br><span class="line">    <span class="type">int</span> wallet2 = <span class="number">350</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using references to swap contents:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">swapr</span>(wallet1,wallet2);		    <span class="comment">// pass  variables</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using pointers to swap contents again:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">swapp</span>(&amp;wallet1,&amp;wallet2);		<span class="comment">// pass addresses of variables</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Trying to use passing by value:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">swapv</span>(wallet1,wallet2);				<span class="comment">// passing values of variables</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapr</span><span class="params">(<span class="type">int</span> &amp; a,<span class="type">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapp</span><span class="params">(<span class="type">int</span> * p, <span class="type">int</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapv</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wallet1 = $300 wallet2 = $350				&lt;&lt; original values</span><br><span class="line">Using references to swap contents:</span><br><span class="line">wallet1 = $350 wallet2 = $300				&lt;&lt; values swapped</span><br><span class="line">Using pointers to swap contents again:</span><br><span class="line">wallet1 = $300 wallet2 = $350				&lt;&lt; values swapped again</span><br><span class="line">Trying to use passing by value:</span><br><span class="line">wallet1 = $300 wallet2 = $350				&lt;&lt; swap failed</span><br></pre></td></tr></table></figure>

<p><strong>引用和指针方法都成功得交换了两个钱包（wallet）中的内容，而按值传递的方法没能完成这项任务。</strong></p>
<p>程序说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapr</span>(wallet1,wallet2);		    <span class="comment">// pass  variables</span></span><br><span class="line"><span class="built_in">swapp</span>(&amp;wallet1,&amp;wallet2);		<span class="comment">// pass addresses of variables</span></span><br><span class="line"><span class="built_in">swapv</span>(wallet1,wallet2);				<span class="comment">// passing values of variables</span></span><br></pre></td></tr></table></figure>

<p>按引用传递和按值传递看起来调用相同，只能通过原型或函数定义才能知道是如何传递的。然而，地址运算符（&amp;）使得按地址传递（swapp()）(类型声明<code>int *p</code>表明，p是一个int指针，因此与p对应的参数应为地址，如&amp;wallet1)。</p>
<p>比较函数swapr()（按引用传递）和swapv()（按值传递）的代码，唯一的外在区别是声明函数参数的方式不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapr</span><span class="params">(<span class="type">int</span> &amp; a, <span class="type">int</span> &amp; b)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;		</span><br></pre></td></tr></table></figure>

<p>内在区别是：在swapr()中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值；但在swapv()中，变量a和b是复制了wallet1和wallet2的值的新变量。因此交换a和b的值并不会影响wallet1和wallet2的值。</p>
<p>比较函数swapr()（传递引用）和swapp()（传递指针），第一个区别是声明函数参数的方式不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapr</span><span class="params">(<span class="type">int</span> &amp; a, <span class="type">int</span> &amp; b)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapp</span><span class="params">(<span class="type">int</span> * p, <span class="type">int</span> * q)</span></span>;	</span><br></pre></td></tr></table></figure>

<p>另一个区别是指针版本需要在函数使用p和q的整个过程中使用<code>解除引用运算符*</code>。</p>
<p>应在<strong>定义引用变量时对其进行初始化</strong>。函数调用使用实参初始化形参，因此<strong>函数的引用参数被初始化为函数调用传递的实参</strong>。也就是说，下面的函数调用将形参a和b分别初始化为wallet1和wallet2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapr</span>(wallet1,wallet2);	</span><br></pre></td></tr></table></figure>

<p><strong>3、 引用的属性和特别之处</strong></p>
<p>使用引用参数时，需要了解其一些特点。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">double</span> &amp;ra)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x =<span class="number">3.0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">cube</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">refcube</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a *= a * a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">double</span> &amp;ra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ra *= ra * ra;</span><br><span class="line">    <span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">27 = cube of 3</span><br><span class="line">27 = cube of 27</span><br></pre></td></tr></table></figure>

<p>refcube()函数修改了main()中的x值，而cube()没有，这提醒了我们为何通常按值传递。变量a位于cube()中，它被初始化为x的值，但修改a并不会影响到x。但由于refcube()使用了引用参数，因此修改ra实际上就是修改了x。如果意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。</p>
<p>例如：应在函数原型和函数头中使用const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;ra)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果这样做，当编译器发现代码修改了ra的值，将生成错误的消息。</p>
<p>顺便说一句，如果要编写类似于上述示例 的函数（即使用基本数值类型），应采用按值传递的方式，而不要采用按引用传递的方式。</p>
<p><strong>临时变量、引用参数和const</strong></p>
<p>如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做。</p>
<p>何种情况下，C++将生成临时变量，以及为何对const引用的限制是合理的。</p>
<p>首先，什么时候将创建临时变量呢？如果引用参数是const，则编译器将在下面两种情况下生成临时变量：</p>
<ul>
<li>实参的类型正确，但不是左值；</li>
<li>实参的类型不正确，但可以转换为正确的类型。</li>
</ul>
<p><strong>左值参数是可以被引用的数据对象</strong>。例如：变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量（用引号括起的字符串除外，它们由地址表示）和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况，现在，常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。</p>
<p>注意：如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p>
<p>:ship:<strong>应尽可能使用const</strong></p>
<p>将引用参数声明为常量数据的引用的理由有三个：</p>
<ul>
<li>使用const可以避免无意中修改数据的编程错误；</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li>
<li>使用const引用使函数能够正确生成并使用临时变量。</li>
</ul>
<p>因此，应尽可能将引用参数声明为const。</p>
<p>C++11 新增了另一种引用：右值引用（rvalue reference）。这种引用可指向右值，是使用&amp;&amp;声明的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> &amp;&amp; rref = std::<span class="built_in">sqrt</span>(<span class="number">36.00</span>);	<span class="comment">//not allowed for double &amp;</span></span><br><span class="line"><span class="type">double</span> j = <span class="number">15.0</span>;</span><br><span class="line"><span class="type">double</span> &amp;&amp; jref = <span class="number">2.0</span> * j + <span class="number">18.5</span>;	<span class="comment">//not allowed for double &amp;</span></span><br><span class="line">std::cout &lt;&lt; rref &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;			<span class="comment">// display 6.0</span></span><br><span class="line">std::cout &lt;&lt; jref &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;			<span class="comment">// display 48.5</span></span><br></pre></td></tr></table></figure>

<p>新增右值引用的主要目的是：让库设计人员能够提供有些操作的更有效实现。</p>
<p><strong>4、将引用用于结构</strong></p>
<p>引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。</p>
<p>使用结构引用参数的方式与使用基本变量引用相同，只需要在声明结构参数时使用引用运算符&amp;即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">free_throws</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> made;</span><br><span class="line">    <span class="type">int</span> attempts;</span><br><span class="line">    <span class="type">float</span> percent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>则可以这样编写函数原型，在函数中指向该结构的引用作为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span></span>;		<span class="comment">// use-a reference to a structure</span></span><br></pre></td></tr></table></figure>

<p>如果不希望函数修改传入的结构，可用const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws &amp; ft)</span></span>;  <span class="comment">//don&#x27;t allow changes to strcture</span></span><br></pre></td></tr></table></figure>

<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">free_throws</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> made;</span><br><span class="line">    <span class="type">int</span> attempts;</span><br><span class="line">    <span class="type">float</span> percent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws  &amp; ft)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span></span>;</span><br><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp; target,<span class="type">const</span> free_throws &amp; source)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//partial initializations - remaining members set to 0</span></span><br><span class="line">    free_throws one = &#123;<span class="string">&quot;Ifelsa Branch&quot;</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    free_throws two = &#123;<span class="string">&quot;Andor knott&quot;</span>,<span class="number">10</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    free_throws three = &#123;<span class="string">&quot;Minnie Max&quot;</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    free_throws four = &#123;<span class="string">&quot;Whily Looper&quot;</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    free_throws five = &#123;<span class="string">&quot;Long LOng&quot;</span>,<span class="number">6</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    free_throws team = &#123;<span class="string">&quot;Throwgoods&quot;</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no initialization</span></span><br><span class="line">    free_throws dup;</span><br><span class="line">    <span class="built_in">set_pc</span>(one);</span><br><span class="line">    <span class="built_in">display</span>(one);</span><br><span class="line">    <span class="built_in">accumulate</span>(team,one);</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line">    <span class="comment">// use return value as argument</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="built_in">accumulate</span>(team,two));</span><br><span class="line">    <span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(team,three),four);</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line">    <span class="comment">// use return value in assignment</span></span><br><span class="line">    dup = <span class="built_in">accumulate</span>(team,five);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dispalying team:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Displaying dup after assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(dup);</span><br><span class="line">    <span class="built_in">set_pc</span>(four);</span><br><span class="line">    <span class="comment">// ill - advised assignment</span></span><br><span class="line">    <span class="built_in">accumulate</span>(dup,five) = four;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Displaying dup after ill-advised assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(dup);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws &amp; ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Name: &quot;</span> &lt;&lt; ft.name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;	Made: &quot;</span> &lt;&lt; ft.made &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Attempts: &quot;</span> &lt;&lt; ft.attempts &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Percent: &quot;</span> &lt;&lt; ft.percent &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ft.attempts != <span class="number">0</span>)</span><br><span class="line">        ft.percent = <span class="number">100.0f</span> * <span class="built_in">float</span>(ft.made) / <span class="built_in">float</span>(ft.attempts);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ft.percent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp; target,<span class="type">const</span> free_throws &amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target.attempts += source.attempts;</span><br><span class="line">    target.made += source.made;</span><br><span class="line">    <span class="built_in">set_pc</span>(target);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Name: Ifelsa Branch</span><br><span class="line">        Made: 13        Attempts: 14    Percent: 92.8571</span><br><span class="line"> Name: Throwgoods</span><br><span class="line">        Made: 13        Attempts: 14    Percent: 92.8571</span><br><span class="line"> Name: Throwgoods</span><br><span class="line">        Made: 23        Attempts: 30    Percent: 76.6667</span><br><span class="line"> Name: Throwgoods</span><br><span class="line">        Made: 35        Attempts: 48    Percent: 72.9167</span><br><span class="line">Dispalying team:</span><br><span class="line"> Name: Throwgoods</span><br><span class="line">        Made: 41        Attempts: 62    Percent: 66.129</span><br><span class="line">Displaying dup after assignment:</span><br><span class="line"> Name: Throwgoods</span><br><span class="line">        Made: 41        Attempts: 62    Percent: 66.129</span><br><span class="line">Displaying dup after ill-advised assignment:</span><br><span class="line"> Name: Whily Looper</span><br><span class="line">        Made: 5 Attempts: 9     Percent: 55.5556</span><br></pre></td></tr></table></figure>

<p><strong>5、将引用用于类对象</strong></p>
<p>将类对象传递给函数时，C++通常的做法是使用引用。例如：可以通过使用引用，让函数将类string、ostream、istream、ofstream和ifstream等类的对象作为参数。</p>
<p><strong>6、对象、继承和引用</strong></p>
<p>ofstream对象可以使用ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。使得==能够将特性从一个类传递给另一个类的语言特性被称为继承==。简单来说，ostream是基类（因为ofstream是建立在它的基础之上的），而ofstream是派生类（因为它是从ostream派生而来的）。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision()和setf()。</p>
<p>==继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换==。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。例如：参数类型ostream &amp;的函数可以接受ostream对象(如cout)或声明的ofstream对象作为参数。</p>
<p><strong>7、何时使用引用参数</strong></p>
<p>使用引用参数的主要原因有两个：</p>
<ul>
<li>程序员能够修改调用函数中的数据对象</li>
<li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li>
</ul>
<p>当数据对像较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。</p>
<p>什么时候应使用引用、什么时候应使用指针、什么时候应按值传递呢？</p>
<p>对于使用传递的值而不作为修改的函数。</p>
<ul>
<li>如果数据对象很小，如内置数据类型或小型结构，则按值传递。</li>
<li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</li>
<li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li>
<li>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</li>
</ul>
<p>对于修改调用函数中数据的函数：</p>
<ul>
<li>如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码（其中x是int），则很明显，该函数将修改x。</li>
<li>如果数据对象是数组，则只能使用指针。</li>
<li>如果数据对象是结构，则使用引用或指针。</li>
<li>如果数据对象是类对象，则使用引用。</li>
</ul>
<h4 id="7-3-默认参数"><a href="#7-3-默认参数" class="headerlink" title="7.3 默认参数"></a>7.3 默认参数</h4><p>默认参数值的是当函数调用中省略了实参时自动使用的一个值。例如：如果将void wow(int n)设置成n有默认值为1，则函数调用wow()相当于wow(1)。这极大得提高了使用函数的灵活性。假设有一个名为left()的函数，它将字符串和n作为参数，并返回该字符串的前n个字符。更准确地说，该函数返回一个指针，该指针指向原始字符串中被选中的部分组成的字符串。例如：函数调用left(“theory”,3)将创建新字符串”the”,并返回一个指向该字符串的指针。现假设第二个参数的默认值被设置为1，则函数调用left(“theory”,3)仍像前面那样工作，3将覆盖默认值。但函数调用left(“theory”)不会出错，它认为第二个参数的值为1，并返回指向字符串”t”的指针。如果程序经常需要抽取一个字符组成的字符串，而偶尔需要抽取较长的字符串，则这种默认值将很有帮助。</p>
<p>默认值的设置必须通过函数原型。由于编译器通过查看原型来了解函数所使用的参数数目，因此函数原型也必须将可能的默认参数告知程序。方法是将值赋给原型中的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">int</span> n = <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>==对于带参数列表的函数，必须从右向左添加默认值。==也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m = <span class="number">4</span>,<span class="type">int</span> j = <span class="number">5</span>)</span></span>;	<span class="comment">// valid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chico</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m = <span class="number">6</span>,<span class="type">int</span> j)</span></span>;		<span class="comment">// invalid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">groucho</span><span class="params">(<span class="type">int</span> k = <span class="number">1</span>, <span class="type">int</span> m = <span class="number">2</span>,<span class="type">int</span> n = <span class="number">3</span>)</span></span>;	<span class="comment">// valid</span></span><br></pre></td></tr></table></figure>

<p>例如，harpo()原型允许调用该函数时提供1个、2个、3个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beeps = <span class="built_in">harpo</span>(<span class="number">2</span>);			<span class="comment">// same as harpo(2,4,5)</span></span><br><span class="line">beeps = <span class="built_in">harpo</span>(<span class="number">1</span>,<span class="number">8</span>);			<span class="comment">// same as harpo(1,8,5)</span></span><br><span class="line">beeps = <span class="built_in">harpo</span>(<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>);		<span class="comment">// no default arguments used</span></span><br></pre></td></tr></table></figure>

<p>==实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。==因此，下面的调用是不允许的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beeps = <span class="built_in">harpo</span>(<span class="number">3</span>，，<span class="number">8</span>);		<span class="comment">// invalid , doesn&#x27;t set m to 4</span></span><br></pre></td></tr></table></figure>

<p>默认参数只是提供了一种便捷的方式。在设计类时，可以通过使用默认参数，减少要定义的析构函数、方法以及方法重载的数量。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">80</span>;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">int</span> n = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sample[ArSize];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a string:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(sample,ArSize);</span><br><span class="line">    <span class="type">char</span> *ps = <span class="built_in">left</span>(sample,<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] ps;					<span class="comment">// free old string</span></span><br><span class="line">    ps = <span class="built_in">left</span>(sample);</span><br><span class="line">    cout &lt;&lt; ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] ps;					<span class="comment">// free new string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> * p = <span class="keyword">new</span> <span class="type">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n &amp;&amp; str[i];i++)</span><br><span class="line">        p[i] = str[i];			<span class="comment">// copy characters</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n) </span><br><span class="line">        p[i++] = <span class="string">&#x27;\0&#x27;</span>;			<span class="comment">// set rest of string to &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a string:</span><br><span class="line">forthcoming</span><br><span class="line">fort</span><br><span class="line">f</span><br></pre></td></tr></table></figure>

<p>该程序使用new创建一个新的字符串，以存储被选择的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; n &amp;&amp; str[i]</span><br></pre></td></tr></table></figure>

<p>i &lt; n 测试让循环复制了n个字符后终止。测试的第二部分：表达式str[i]，是要复制的字符的编码。遇到空值字符（其编码为0）后，循环将结束。这样，while循环将使字符串以空值字符结束，并将余下的空间设置为空值字符。</p>
<p>另一种设置新字符串长度的方法是，将n设置为传递的值和字符串长度中较小的一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">n = (n &lt; len) ? n : len;		<span class="comment">// the lesser of n and len</span></span><br><span class="line"><span class="type">char</span> * p = <span class="keyword">new</span> <span class="type">char</span>[n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>这将确保new分配的空间不会多于存储字符串所需的空间。</p>
<p>例：当m的值等于n或到达字符串结尾时，下面的值循环都将终止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m &lt;= n &amp;&amp; str[m] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    m++;</span><br><span class="line"><span class="type">char</span> * p = <span class="keyword">new</span> <span class="type">char</span>[m+<span class="number">1</span>];		<span class="comment">//use m instead of n in rest of code</span></span><br></pre></td></tr></table></figure>

<p>在str[m]不是空值字符时，表达式str[m] != ‘\0’的结果为true，否则为false。由于在&amp;&amp;表达式中，非零值被转换为true，而零被转换为false，因此也可以这样编写这个while测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m &lt;= n &amp;&amp; str[m])</span><br></pre></td></tr></table></figure>

<h4 id="7-4-函数重载"><a href="#7-4-函数重载" class="headerlink" title="7.4  函数重载"></a>7.4  函数重载</h4><p>函数重载指的是可以用多个同名的函数，因此对名称进行了重载。函数重载完成相同的工作，但使用不同的参数列表。</p>
<p><strong>函数重载的关键是函数的参数列表，也称为函数特征标（function signature）</strong>。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。</p>
<p>一些看起来彼此不同的特征标是不能共存的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> &amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可能认为在此处使用函数重载，因为它们的特征标看起来不同。然而，从编译器的角度来考虑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">cube</span>(x);</span><br></pre></td></tr></table></figure>

<p>参数x与double x原型和double &amp; x原型都匹配，因此编译器无法确定究竟应使用哪个原型。为避免这种混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一种特征标。</p>
<p>匹配函数时，并不区分const和非const变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dribble</span> <span class="params">(<span class="type">char</span> * bits)</span></span>;			<span class="comment">//overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dribble</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * cbits)</span></span>;	<span class="comment">//overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dabble</span> <span class="params">(<span class="type">char</span> * bits)</span></span>;			<span class="comment">//not overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drivel</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * bits)</span></span>;		<span class="comment">//not overloaded</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>是特征标，而不是函数类型使得可以对函数进行重载</strong>。</p>
<p>例如：下面两个声明是互斥的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">gronk</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span> m)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gronk</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span> m)</span></span>;</span><br><span class="line"><span class="comment">//same signatures hence not allowed </span></span><br></pre></td></tr></table></figure>

<p>因此，C++不允许以这种方式重载gronk()。<strong>返回类型可以不同，但特征标也必须不同</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">gronk</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span> m)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gronk</span> <span class="params">(<span class="type">float</span> n, <span class="type">float</span> m)</span></span>;</span><br><span class="line"><span class="comment">//different signatures hence allowed </span></span><br></pre></td></tr></table></figure>

<p><strong>何时使用函数重载</strong></p>
<p>虽然函数重载很吸引人，但也不要滥用。<strong>仅当函数基本上执行相同的任务，但使用不同的数据时，才应采用函数重载</strong>。另外，是否可以通过使用默认参数来实现同样的目的。</p>
<p>例如：可以用两个重载函数来代替面向字符串的left()函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">unsigned</span> n)</span></span>;	<span class="comment">// two arguments</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str)</span></span>;				<span class="comment">// one argument</span></span><br></pre></td></tr></table></figure>

<p>使用一个默认参数的函数要简单些，只需编写一个函数（而不是两个函数），程序也只需为一个函数（而不是两个）请求内存；需要修改函数时，只需修改一个。然而，如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下，应该使用函数重载。</p>
<h4 id="7-5-函数模板"><a href="#7-5-函数模板" class="headerlink" title="7.5  函数模板"></a>7.5  函数模板</h4><p>函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如int 或 double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。</p>
<p>例如：定义一个交换两个int值的函数。假设要交换两个double值，则一种方法是复制原来的代码，并用double替换所有的int。如果需要交换两个char 值，可以再次使用同样的技术。进行这种修改将浪费宝贵的时间，且容易出错。如果进行手工修改，则可能会漏掉一个int。如果进行全局查找和替换（如用double替换int）时，可能将：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">short</span> interval;</span><br><span class="line"><span class="comment">//转换为：</span></span><br><span class="line"><span class="type">double</span> x;				<span class="comment">//intended change of type</span></span><br><span class="line"><span class="type">short</span> doubleerval;		<span class="comment">//unintended change of variable name</span></span><br></pre></td></tr></table></figure>

<p>C++的函数模板功能能自动完成这一过程，可以节省时间，而且更可靠。</p>
<p>函数模板允许以任意类型的方式来定义函数。例如：可以建立一个交换模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行指出，要建立一个模板，并将类型命名为AnyType。<strong>关键字template 和 typename是必需的</strong>，除非可以使用关键字class代替typename。另外，<strong>必须使用尖括号</strong>。类型名可以任意选择（这里是AnyType）,只要遵守C++命名规则即可；许多程序员都使用简单的名称，如 T。</p>
<p>==模板并不创建任何函数，而只是告诉编译器如何定义函数==。需要交换int的函数时，编译器将按模板模式创建这样的函数，并用int代替AnyType。同样，需要交换double函数时，编译器将按模板模式创建这样的函数，并用double代替AnyType。</p>
<p>在标准C++98 添加关键字typename之前，C++使用关键字class来创建模板。也就是说，可以这样编写模板定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AnyType</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typename关键字使得参数AnyType表示类型这一点更为明显；然而，有大量代码库是使用关键字class开发的。在这种上下文中，这两个关键字是等价的。</p>
<p>提示：<strong>如果需要多个将同一种算法用于不同类型的函数，请使用模板</strong>。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不使用calss。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;		<span class="comment">// or class T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated int swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(i,j);		<span class="comment">// generates void Swap(int &amp;,int &amp;)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; j &lt;&lt;<span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x = <span class="number">24.5</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">81.7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x, y = &quot;</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated double swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x,y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now x, y = &quot;</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function template definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	<span class="comment">// or calss T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;				<span class="comment">// temp a variable of type T</span></span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, j = 10, 20.</span><br><span class="line">Using compiler-generated int swapper:</span><br><span class="line">Now i, j = 20, 10.</span><br><span class="line">x, y = 24.5, 81.7.</span><br><span class="line">Using compiler-generated double swapper:</span><br><span class="line">Now x, y = 81.7, 24.5.</span><br></pre></td></tr></table></figure>

<p>程序说明：</p>
<p>第一个Swap()函数接受两个int参数，因此编译器生成该函数的int版本。也就是说，用int替换所有的T，生成下面这样的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序员看不到这些代码，但编译器确实生成并在程序中使用了它们。第二个Swap()函数接受两个double参数，因此编译器将生成double版本。也就是说，用double替换T，生成下述代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span> &amp;a, <span class="type">double</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doouble temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：函数模板不能缩短可执行程序。对于上述程序清单，最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。最终的代码不包含任何模板，而只包含了为程序生成的实际函数。使用模板的好处是，它使生成多个函数定义更简单、更可靠。</p>
<p><strong>1、重载的模板</strong></p>
<p>需要对多个不同类型使用同一种算法的函数时，可使用模板。然而，并非所有的类型都使用相同的算法，为满足这种需求，可以像重载常规函数定义那样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须不同。</p>
<p>例如：下面程序新增一个交换模板，用于交换两个数组中的元素。原来的模板的特征标为（T &amp;,T &amp;）,而新模板的特征标为（T [ ], T [ ]，int）。注意，在后一个模板中，最后一个参数的类型为具体类型（int），而不是泛型。并非所有的模板参数都必须是模板参数类型。</p>
<p>程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;		<span class="comment">// original template</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;		<span class="comment">// new template</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a,T *b, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> a[])</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Lim = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated int swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(i,j);		<span class="comment">// matches original template</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; j &lt;&lt;<span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> d1[Lim] = &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> d2[Lim] = &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original arrays:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Show</span>(d1);</span><br><span class="line">    <span class="built_in">Show</span>(d2);</span><br><span class="line">    <span class="built_in">Swap</span>(d1,d2,Lim);			<span class="comment">// matches new template</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Swapped arrays:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Show</span>(d1);</span><br><span class="line">    <span class="built_in">Show</span>(d2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function template definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;				</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T a[],T b[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;				</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>;i &lt; Lim;i++)</span><br><span class="line">        cout &lt;&lt; a[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i, j = 10, 20.</span><br><span class="line">Using compiler-generated int swapper:</span><br><span class="line">Now i, j = 20, 10.</span><br><span class="line">Original arrays:</span><br><span class="line">07/04/1776</span><br><span class="line">07/20/1969</span><br><span class="line">Swapped arrays:</span><br><span class="line">07/20/1969</span><br><span class="line">07/04/1776</span><br></pre></td></tr></table></figure>

<p><strong>2、模板的局限性</strong></p>
<p>假设有如下模板函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;			<span class="comment">// or template &lt;typename T&gt;	</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a,T b)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>通常，代码假定可执行哪些操作。例如：下面的代码假定定义了赋值，但如果T为数组，这种假设将不成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b</span><br></pre></td></tr></table></figure>

<p>同样，下面的语句假设定义了&lt;,但如果T为结构，该假设便不成立:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br></pre></td></tr></table></figure>

<p>另外，为数组名定义了运算符 &gt; ，但由于数组名为地址，因此它比较的是数组的地址，而这种不是您希望的。</p>
<p>下面的语句假定为类型T定义了乘法运算符，但如果T为数组、指针或结构，这种假设便不成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T c = a * b;</span><br></pre></td></tr></table></figure>

<p>总之，编写的模板函数很可能无法处理某些类型。</p>
<p><strong>3、显式具体化</strong></p>
<p>假设定义了如下结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">job</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">    <span class="type">int</span> floor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外，假设希望能够交换两个这种结构的内容。原来的模板使用下面的代码来完成交换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>

<p>由于C++允许将一个结构赋给另一个结构，因此即使T是一个job结构，上述代码也适用。然而，假设只想交换salary和floor成员，而不交换name成员，则需要使用不同的代码，但Swap()的参数将保持不变（两个job结构的引用），因此无法使用模板重载来提供其他的代码。</p>
<p>然而，可以提供一个具体化函数定义，称为显示具体化（explicit specialization）。其中包含所需的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。</p>
<p>具体化机制随着C++的演变而不断变化。下面介绍C++标准定义的形式。</p>
<p>试验其他具体化方法后，C++98标准选择了下面的方法。</p>
<ul>
<li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。</li>
<li>显式具体化的原型和定义应以template&lt;&gt;开头，并通过名称来指出类型。</li>
<li>具体化优先于常规模板，而非模板函数优于具体化和常规模板。</li>
</ul>
<p>下面是用于交换job结构的非模板函数、模板函数和具体化的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non template function prototype</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(job &amp;, job &amp;)</span>；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// template prototype</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;,T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicit specialization for the job type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;job&gt;(job &amp;, job &amp;);</span><br></pre></td></tr></table></figure>

<p>如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。</p>
<p>例如：在下面的代码中，第一次调用Swap()时使用通用版本，而第二次调用使用基于job类型的显示具体化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;, T &amp;)</span>；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//explicit specialization for the job type</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> Swap&lt;job&gt;<span class="params">(job &amp;, job &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> u,v;</span><br><span class="line">    <span class="built_in">Swap</span>(u,v);	<span class="comment">// use template</span></span><br><span class="line">    job a, b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">SWap</span>(a,b);	<span class="comment">// use void Swap&lt;job&gt;(job &amp;,job &amp;)</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>Swap&lt;job&gt;</code>中的job是可选的，因为函数的参数类型表明，这是job的一个具体化。因此，该原型也可以这样编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(job &amp;, job &amp;)</span></span>;	<span class="comment">// simpler from</span></span><br></pre></td></tr></table></figure>

<p><strong>4、模板函数的发展</strong></p>
<p>在C++发展的早期，大多数人都没有想到模板函数和模板类会有这么强大而有用。C++98标准做出了相应的修改，并添加了标准模板库。从此以后，模板程序员在不断探索各种可能性，并消除模板的局限性。C++11标准根据这些程序员的反馈做出了相应的修改。</p>
<p><strong>1）是什么类型</strong></p>
<p>在C++98中，编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ft</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ?type? xpy = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xpy应为什么类型呢？由于不知道ft()将如何使用，因此无法预先知道这一点。正确的类型可能是T1、T2或其他类型。例如，T1可能是double，而T2可能是int，在这种情况下，两个变量的和将为double类型。T1可能是short，而T2可能是int，在这种情况下，两个变量的和将为int类型。T1还可能是short，而T2可能是char，在这种情况下，加法运算符将导致自动整型提升，因此结果类型为int。另外，结构和类可能重载运算符+，这导致问题更加复杂。因此，在C++98中，没有办法声明xpy的类型。</p>
<p><strong>2）关键字decltype（C++11）</strong></p>
<p>C++11 新增的关键字decltype提供了解决方案。可这样使用该关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">decltype</span>(x) y;		<span class="comment">// make y the same type as x</span></span><br></pre></td></tr></table></figure>

<p>给decltype提供的参数可以是表达式，因此在前面的模板函数ft()中，可使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x + x) xpy;	<span class="comment">// make xpy the same type as x + y</span></span><br><span class="line">xpy = x + y;</span><br></pre></td></tr></table></figure>

<p>或者，将这两条语句合而为一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x + x) xpy = x + y;</span><br></pre></td></tr></table></figure>

<p>因此，可以这样修复前面的模板函数ft()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ft</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(x + x) xpy = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为确定类型，编译器必须遍历一个核对表。假设有如下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;</span><br></pre></td></tr></table></figure>

<p>则核对表的简化版如下：</p>
<p>第一步：如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">5.5</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">7.9</span>;</span><br><span class="line"><span class="type">double</span> &amp;rx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> * pd;</span><br><span class="line"><span class="keyword">decltype</span>(x) w;			<span class="comment">// w is type double</span></span><br><span class="line"><span class="keyword">decltype</span>(rx) u = y;		<span class="comment">// u is type double &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(pd) v;			<span class="comment">// v is type const double *</span></span><br></pre></td></tr></table></figure>

<p>第二步：如果expression是一个函数调用，则var的类型与函数的返回值类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">indeed</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span> (<span class="built_in">indeed</span>(<span class="number">3</span>)) m;		<span class="comment">// m is type int</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>并不会实际调用函数。编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。</strong></p>
<p>第三步：如果expression是一个左值，则var为指向其类型的引用。这好像意味着前面的w应为引用类型。因为x是一个左值。但别忘了，这种情况已经在第一步处理过了，要进入第三步，expression不能是未用括号括起的标识符。那么，expression是什么时候将进入第三步呢？一种显而易见的情况是，expression是用括号括起的标识符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> xx = <span class="number">4.4</span>;</span><br><span class="line"><span class="keyword">decltype</span> ((xx)) r2 = xx;	<span class="comment">// r2 is double &amp;</span></span><br><span class="line"><span class="keyword">decltype</span> (xx) w = xx; 		<span class="comment">// w is double (Stage 1 match)</span></span><br></pre></td></tr></table></figure>

<p>顺便说一句，括号并不会改变表达式的值和左值性。例如：下面两条语句是等效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx = <span class="number">98.6</span>;</span><br><span class="line">(xx) = <span class="number">98.6</span>; 	<span class="comment">// () don&#x27;t affect use of xx </span></span><br></pre></td></tr></table></figure>

<p>第四步：如果前面的条件都不满足，则var的类型与expression的类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;k = j;</span><br><span class="line"><span class="type">int</span> &amp;n = j;</span><br><span class="line"><span class="keyword">decltype</span>(j+<span class="number">6</span>) <span class="number">11</span>;			<span class="comment">// 11 type int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">100L</span>) i2;			<span class="comment">// i2 type long</span></span><br><span class="line"><span class="keyword">decltype</span>(k+n) i3;			<span class="comment">// i3 type int</span></span><br></pre></td></tr></table></figure>

<p>请注意：虽然k和n都是引用，但表达式k+n不是引用；它是两个int的和，因此类型为int。</p>
<p>如果需要多次声明，可结合使用typedef和decltype。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ft</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(x + x)</span> xytype</span>;</span><br><span class="line">    xytype xpy = x + y;</span><br><span class="line">    xytype arr[<span class="number">10</span>];</span><br><span class="line">    xytype &amp; rxy = arr[<span class="number">2</span>];		<span class="comment">// rxy a reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3) 另一种函数声明语法（C++11 后置返回类型）</strong></p>
<p>有一个相关的问题是decltype本身无法解决的。请看下面这个不完整的模板函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">?type? <span class="built_in">gt</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，无法预先知道将x和y相加得到的类型。好像可以将返回类型设置为decltype(x + y)。但不幸的是，此时还未声明参数x和y，它们不在作用域内（编译器看不到它们，也无法使用它们）。必须在声明参数后使用decltype。为此，C++新增了一种声明和定义函数的语法。</p>
<p>例如：使用内置类型来说明这种语法的工作原理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x, <span class="type">float</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用新增的语法可编写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x, <span class="type">float</span> y)</span> -&gt; <span class="type">double</span></span>;</span><br></pre></td></tr></table></figure>

<p>这将返回类型移到了参数声明的后面。**-&gt;double被称为后置返回类型（trailing return type）**。其中auto是一个占位符，表示后置返回类型提供的类型。</p>
<p>也可用于函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x, <span class="type">float</span> y)</span> -&gt; <span class="type">double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* function body */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过结合使用这种语法和decltype，便可给gt()指定返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span>	-&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>现在，decltype再参数声明后面，因此x和y位于作用域内，可以使用它们。</p>
<h4 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6  总结"></a>7.6  总结</h4><p>C++扩展了C语言的函数功能，通过将inline关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用，只有在函数很短时才能采用内联方式。</p>
<p>引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。通常，被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类（如ofstream）是从另一个类（如ostream）派生出来的，则基类引用可以指向派生类对象。</p>
<p>C++原型可以定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。</p>
<p>函数的特征标是参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。通常，通过重载函数来为不同的数据类型提供相同的服务。</p>
<p>函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cappuccino</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://centlabs.github.io/2022/04/08/C++%20Learning%202/">https://centlabs.github.io/2022/04/08/C++%20Learning%202/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/04/04/golangChannel/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">golangChannel</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/23/C%20plus%20plus/" title="C plus plus"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">C plus plus</div></div></a></div><div><a href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">C++ Learning</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cappuccino</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">第五章  循环和关系表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用for循环访问字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%90%8E%E7%BC%80%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">前缀格式和后缀格式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%A2%9E-%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">递增&#x2F;递减运算符和指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.4.</span> <span class="toc-text">C风格字符串的比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.1.5.</span> <span class="toc-text">类型别名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%88C-11%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">5.2  基于范围的for循环（C++11）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 循环和文本输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">5.4  嵌套循环和二维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0%EF%BC%9AC-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">第六章 函数：C++的编程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">6.1  函数的基本知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">2.2.</span> <span class="toc-text">6.2  函数参数和按值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">多个参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%97%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">另外一个接受两个参数的函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.</span> <span class="toc-text">6.3 函数和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用数组区间的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">2.3.2.</span> <span class="toc-text">指针和const</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">6.4  函数和二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%87%BD%E6%95%B0%E5%92%8CC-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">6.5  函数和C-风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86C-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">将C-风格字符串作为参数的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9EC-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">返回C-风格字符串的函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">6.6  函数和结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.6.1.</span> <span class="toc-text">1、传递和返回结构：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">2、另一个处理结构的函数示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.6.3.</span> <span class="toc-text">3、传递结构的地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-%E5%87%BD%E6%95%B0%E5%92%8Cstring%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.</span> <span class="toc-text">6.7  函数和string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-%E5%87%BD%E6%95%B0%E4%B8%8Earray%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.</span> <span class="toc-text">6.8  函数与array对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-%E9%80%92%E5%BD%92"><span class="toc-number">2.9.</span> <span class="toc-text">6.9  递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">2.9.1.</span> <span class="toc-text">1、包含一个递归调用的递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">2.9.2.</span> <span class="toc-text">2、包含多个递归调用的递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.10.</span> <span class="toc-text">6.10  函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.10.1.</span> <span class="toc-text">1、函数指针的基础知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.10.2.</span> <span class="toc-text">2、函数指针示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.10.3.</span> <span class="toc-text">3、 深入探讨函数指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81-%E4%BD%BF%E7%94%A8typedef%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8C%96"><span class="toc-number">2.10.4.</span> <span class="toc-text">4、 使用typedef进行简化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-%E6%80%BB%E7%BB%93"><span class="toc-number">2.11.</span> <span class="toc-text">6.11 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD"><span class="toc-number">3.</span> <span class="toc-text">第七章  函数探幽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">7.1  C++内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">7.2  引用变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">7.3 默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.4.</span> <span class="toc-text">7.4  函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.5.</span> <span class="toc-text">7.5  函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">7.6  总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/08/C++%20Learning%202/" title="C++ Learning 2"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Learning 2"/></a><div class="content"><a class="title" href="/2022/04/08/C++%20Learning%202/" title="C++ Learning 2">C++ Learning 2</a><time datetime="2022-04-08T11:30:13.593Z" title="Created 2022-04-08 19:30:13">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/04/golangChannel/" title="golangChannel"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golangChannel"/></a><div class="content"><a class="title" href="/2022/04/04/golangChannel/" title="golangChannel">golangChannel</a><time datetime="2022-04-04T13:29:40.145Z" title="Created 2022-04-04 21:29:40">2022-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E6%88%91%E4%BB%AC/" title="同一个世界，同一个疫情"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="同一个世界，同一个疫情"/></a><div class="content"><a class="title" href="/2022/04/01/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E6%88%91%E4%BB%AC/" title="同一个世界，同一个疫情">同一个世界，同一个疫情</a><time datetime="2022-04-01T15:43:24.955Z" title="Created 2022-04-01 23:43:24">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Learning"/></a><div class="content"><a class="title" href="/2022/03/31/C++%20Primer%20Plus/" title="C++ Learning">C++ Learning</a><time datetime="2022-03-31T14:50:54.350Z" title="Created 2022-03-31 22:50:54">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/30/Qt%205%20%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%9E%E4%BE%8B/" title="Qt 5 模板库、工具类及控件"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt 5 模板库、工具类及控件"/></a><div class="content"><a class="title" href="/2022/03/30/Qt%205%20%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%9E%E4%BE%8B/" title="Qt 5 模板库、工具类及控件">Qt 5 模板库、工具类及控件</a><time datetime="2022-03-30T09:03:06.304Z" title="Created 2022-03-30 17:03:06">2022-03-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Cappuccino</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>